
msgid ""
msgstr ""
"Project-Id-Version: Hyperledger Iroha Documentation\n"
"Report-Msgid-Bugs-To: EMAIL@ADDRESS\n"
"POT-Creation-Date: 2019-03-14 16:19+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.3\n"

#: ../iroha/docs/source/guides/libraries/python.rst:2
msgid "Python Library"
msgstr "Pythonライブラリ"

#: ../iroha/docs/source/guides/libraries/python.rst:5
msgid "Where to Get"
msgstr "入手先"

#: ../iroha/docs/source/guides/libraries/python.rst:7
msgid ""
"A supported python library for Iroha is available at its `own Hyperledger"
" iroha-python repo <https://github.com/hyperledger/iroha-python/>`__. "
"Python 3+ is supported."
msgstr ""

#: ../iroha/docs/source/guides/libraries/python.rst:10
msgid "You can also install Python library via pip:"
msgstr ""

#: ../iroha/docs/source/guides/libraries/python.rst:17
msgid "Example Code"
msgstr "コード例"

#~ msgid "Configuration"
#~ msgstr "設定"

#~ msgid ""
#~ "In this section we will understand "
#~ "how to configure Iroha. Let's take "
#~ "a look at ``example/config.sample``"
#~ msgstr "このセクションでは、Irohaの設定方法を説明します。 まず「example/config.sample」を見てみましょう。"

#~ msgid ""
#~ "As you can see, configuration file "
#~ "is a valid ``json`` structure. Let's "
#~ "go line-by-line and understand "
#~ "what every parameter means."
#~ msgstr "ご覧の通り、設定ファイルは有効な `json`の構造体です。 それでは、行ごとに各パラメータが何を意味するのかを見てゆきましょう。"

#~ msgid "Deployment-specific parameters"
#~ msgstr "運用時のパラメーター"

#~ msgid "``block_store_path`` sets path to the folder where blocks are stored."
#~ msgstr "`block_store_path`は、ブロックが格納されているフォルダへのパスを設定します。"

#~ msgid ""
#~ "``torii_port`` sets the port for "
#~ "external communications. Queries and "
#~ "transactions are sent here."
#~ msgstr "`torii_port`は、外部通信用のポートを設定します。 クエリーとトランザクションがここに送られます。"

#~ msgid ""
#~ "``internal_port`` sets the port for "
#~ "internal communications: ordering service, "
#~ "consensus and block loader."
#~ msgstr ""
#~ "`internal_port`は、内部通信用のポートを設定します。内部通信には、注文サービス（ordering "
#~ "service）、コンセンサス（consensus）、ブロックローダー（block loader）があります。"

#~ msgid ""
#~ "``pg_opt`` is used for setting "
#~ "credentials of PostgreSQL: hostname, port, "
#~ "username and password."
#~ msgstr "pg_optは、PostgreSQLの認証情報の設定に使用されます。認証情報には、ホスト名、ポート、ユーザ名、パスワードがあります。"

#~ msgid "Environment-specific parameters"
#~ msgstr "環境設定用パラメーター"

#~ msgid ""
#~ "``max_proposal_size`` is the maximum amount"
#~ " of transactions that can be in "
#~ "one proposal, and as a result in"
#~ " a single block as well. So, by"
#~ " changing this value you define the"
#~ " size of potential block. For a "
#~ "starter you can stick to ``10``. "
#~ "However, we recommend to increase this"
#~ " number if you have a lot of"
#~ " transactions per second."
#~ msgstr ""
#~ "`max_proposal_size`は1つのプロポーザルに入れることができるトランザクションの最大数であり、それらは全て1つのブロックに格納されます。"
#~ " したがって、この値を変更することによって、新規作成されるブロックのサイズが定義されます。 "
#~ "はじめは「10」に設定しておくと良いでしょう。 ただし、秒間取引量が多い場合には、この値を大きくすることをお勧めします。"

#~ msgid ""
#~ "``proposal_delay`` is a maximum waiting "
#~ "time in milliseconds before emitting a"
#~ " new proposal. Proposal is emitted if"
#~ " the ``max_proposal_size`` is reached or"
#~ " ``proposal_delay`` milliseconds had passed. "
#~ "You can start with ``5000`` and "
#~ "increase this number if you have a"
#~ " lot of transactions per second since"
#~ " it is likely that with an "
#~ "intense load (over 100 transactions per"
#~ " second) and low value of "
#~ "``proposal_delay`` there will be many "
#~ "proposals of small size."
#~ msgstr ""
#~ "`proposal_delay`は、新規ブロックの生成を発信するまでの最大待ち時間（ミリ秒単位）です。新規ブロック生成のプロポーザルは、``max_proposal_size``に達するか、"
#~ " `proposal_delay`ミリ秒が経過した場合に生成されます。 "
#~ "はじめは「5000」に設定しておくとよいでしょう。多くの取引量がある場合は、この値を大きくしてください。負荷が大きく（毎秒100トランザクション以上）、かつ`proposal_delay`の値が小さい場合は、小さなサイズの新規ブロック生成要求が発信される可能性が高くなることが予想されるためです。"

#~ msgid ""
#~ "``vote_delay`` is a waiting time in "
#~ "milliseconds before sending vote to the"
#~ " next peer. Optimal value depends "
#~ "heavily on the amount of Iroha "
#~ "peers in the network (higher amount "
#~ "of nodes requires longer ``vote_delay``). "
#~ "We recommend to start with 100-1000 "
#~ "milliseconds."
#~ msgstr ""
#~ "`vote_delay`は、次のピア（ネットワークノード）に投票を送るまでの待ち時間（ミリ秒）です。 "
#~ "最適な値は、ネットワーク内のいろはピア数に大きく依存します（ノード数が多いほど、「vote_delay」には長い値が必要）。 "
#~ "はじめは100〜1000ミリ秒で設定することをお勧めします。"

#~ msgid ""
#~ "``load_delay`` is a waiting time in "
#~ "milliseconds before loading committed block"
#~ " from next peer. We recommend setting"
#~ " this number the same value as "
#~ "``proposal_delay`` or even higher."
#~ msgstr ""
#~ "`load_delay`は、次のピアからコミットされたブロックをロードするまでの待ち時間（ミリ秒単位）です。 この数値は "
#~ "`proposal_delay`またはそれ以上の値に設定することをお勧めします。"

#~ msgid "Commands"
#~ msgstr "利用可能なコマンド一覧"

#~ msgid "Add asset quantity"
#~ msgstr "該当資産の量を追加する"

#~ msgid "Add peer"
#~ msgstr "ピア（ノード）を追加する"

#~ msgid "Add signatory"
#~ msgstr "署名者を追加する"

#~ msgid "Append role"
#~ msgstr "役割を追加する"

#~ msgid "Create account"
#~ msgstr "アカウントを新規作成する"

#~ msgid "Create asset"
#~ msgstr "アセットを発行する"

#~ msgid "Create domain"
#~ msgstr "ドメインを作成する"

#~ msgid "Create role"
#~ msgstr "役割を作成する"

#~ msgid "Detach role"
#~ msgstr "役割を切り離す"

#~ msgid "Grant permission"
#~ msgstr "権限を与える"

#~ msgid "Revoke permission"
#~ msgstr "権限を取り消す"

#~ msgid "Set account detail"
#~ msgstr "アカウントの詳細を設定する"

#~ msgid "Set account quorum"
#~ msgstr "アカウントの定足数を設定する"

#~ msgid "Subtract asset quantity"
#~ msgstr "資産量を減らす"

#~ msgid "Transfer asset"
#~ msgstr "資産を移転させる"

#~ msgid "С++ library"
#~ msgstr "C++ライブラリ"

#~ msgid ""
#~ "This section only contains code "
#~ "reference (autogenerated docs are possible "
#~ "with a description of arguments and "
#~ "return values)"
#~ msgstr "このセクションには、参照コードのみが含まれています（引数と戻り値の説明がされたドキュメントの自動生成も可能です）"

#~ msgid "Iroha API reference"
#~ msgstr "いろは（Hyperledger Iroha）のAPIリファレンス"

#~ msgid ""
#~ "In API section we will take a "
#~ "look at building blocks of an "
#~ "application interacting with Iroha. We "
#~ "will overview commands and queries that"
#~ " the system have, and the set "
#~ "of client libraries encompassing transport "
#~ "and application layer logic."
#~ msgstr ""
#~ "APIセクションでは、実際にいろはでの動作を見ながら、いろはを構成する要素について見ていきます。 "
#~ "システムが持つコマンドやクエリの種類、およびトランスポート層とアプリケーション層にわたるクライアントライブラリを概観します。"

#~ msgid "Table of contents"
#~ msgstr "目次"

#~ msgid "Java library"
#~ msgstr "Javaライブラリ"

#~ msgid "NodeJS library"
#~ msgstr "NodeJSライブラリ"

#~ msgid "Objective-C library"
#~ msgstr "Objective-Cライブラリ"

#~ msgid "Python library"
#~ msgstr "Pythonライブラリ"

#~ msgid "Queries"
#~ msgstr "クエリの一覧"

#~ msgid "Get account"
#~ msgstr "アカウントを取得する"

#~ msgid "Get signatories"
#~ msgstr "署名者を取得する"

#~ msgid "Get transactions"
#~ msgstr "トランザクションを取得する"

#~ msgid "Get account transactions"
#~ msgstr "特定のアカウントに関連した取引情報を取得する"

#~ msgid "Get account asset transactions"
#~ msgstr "アカウントに関連した特定の資産取引に関する情報を取得する"

#~ msgid "Get account assets"
#~ msgstr "アカウントの資産情報を取得する"

#~ msgid "Get asset info"
#~ msgstr "資産情報を取得する"

#~ msgid "Get roles"
#~ msgstr "役割を得る"

#~ msgid "Get role permissions"
#~ msgstr "役割に対する権限を得る"

#~ msgid "Swift library"
#~ msgstr "Swiftライブラリ"

#~ msgid "Contribution"
#~ msgstr "貢献"

#~ msgid "Code of conduct"
#~ msgstr "規定・規範"

#~ msgid "Process"
#~ msgstr "プロセス"

#~ msgid "Communication"
#~ msgstr "コミュニケーション（問い合わせ）"

#~ msgid "Issue tracker"
#~ msgstr "用件の履歴表示"

#~ msgid "A term"
#~ msgstr "規定A"

#~ msgid "B term"
#~ msgstr "規定B"

#~ msgid "C term"
#~ msgstr "規定C"

#~ msgid "Remaining parts (WSV, etc.)"
#~ msgstr "残っている部分（ワールドステートビュー（WSV）等）"

#~ msgid "Core concepts"
#~ msgstr "重要な概念"

#~ msgid ""
#~ "Why Iroha runs in a network? How"
#~ " to understand the objects inside and"
#~ " outside the system? How peers in "
#~ "the network collaborate and decide which"
#~ " data to put into the blockchain? "
#~ "We will look through the basics of"
#~ " Iroha in this section."
#~ msgstr ""
#~ "「いろは」はなぜネットワーク上で動くのでしょうか。 システムの内部と外部のオブジェクトをどのようにすれば理解できるのでしょうか。"
#~ " ネットワーク上のピアはどのように協力してブロックチェーンに入れるべきデータを決定するのでしょうか。 "
#~ "本セクションでは、こうしたいろはシステムの基本的な部分を見ていきましょう。"

#~ msgid "Is having an account in Iroha means being a user?"
#~ msgstr "いろはシステムの上でアカウントを持っているということは、ユーザーであるということなのでしょうか。"

#~ msgid "Are there differences compared to client-server systems?"
#~ msgstr "従来のクライアント・サーバー型システムとの違いはあるのでしょうか。"

#~ msgid "Assets, domains and other internal objects"
#~ msgstr "資産、ドメインおよびその他の内部オブジェクト"

#~ msgid "Does everyone have to maintain their own peer?"
#~ msgstr "すべてのいろはユーザーがそれぞれのノードを運用しなければいけないのでしょうか。"

#~ msgid "How peers communicate with each other?"
#~ msgstr "どのようにノード達は通信し合うのでしょうか。"

#~ msgid "ER model"
#~ msgstr "ERモデル（実体関連モデル）"

#~ msgid "Transaction"
#~ msgstr "トランザクション"

#~ msgid "Transaction statuses"
#~ msgstr "トランザクションの状態"

#~ msgid "Query"
#~ msgstr "クエリー（問い合わせ）"

#~ msgid "Validation"
#~ msgstr "検証"

#~ msgid "Stateless"
#~ msgstr "ステートレス"

#~ msgid "Stateful"
#~ msgstr "ステートフル"

#~ msgid "Glossary"
#~ msgstr "用語集"

#~ msgid "Getting Started"
#~ msgstr "はじめる"

#~ msgid ""
#~ "In this guide, we will create a"
#~ " very basic Iroha network, launch it,"
#~ " create a couple of transactions, and"
#~ " check the data written in the "
#~ "ledger. To keep things simple, we "
#~ "will use Docker."
#~ msgstr ""
#~ "このガイドでは、基本的ないろはネットワークを作成し、立ち上げ、いくつかのトランザクションを作成し、台帳に記録されたデータを確認します。"
#~ " 単純にするために、Dockerを利用します。"

#~ msgid ""
#~ "Ledger is the synonym for a "
#~ "blockchain, and Hyperledger Iroha is "
#~ "known also as Distributed Ledger "
#~ "Technology — which in essence is "
#~ "the same as \"blockchain framework\". "
#~ "You can check the rest of "
#~ "terminology used in the Glossary "
#~ "section."
#~ msgstr ""
#~ "台帳はブロックチェーンの同義語で、ハイパーレジャーいろは（Hyperledger "
#~ "Iroha）は分散型台帳技術（Distributed Ledger "
#~ "Technology）としても知られています。本質的には「ブロックチェーンフレームワーク」と同じです。 "
#~ "その他の用語は、「用語集」で確認できます。"

#~ msgid "Prerequisites"
#~ msgstr "前提となる環境"

#~ msgid ""
#~ "For this guide, you need a "
#~ "computer running Unix-like system with"
#~ " ``docker`` installed. You can read "
#~ "how to install it on a `Docker's"
#~ " website <https://www.docker.com/community-edition/>`_."
#~ msgstr ""
#~ "このガイドでは、dockerがインストールされたUnix系システムが起動されているコンピュータが必要です。`Dockerのウェブサイト<https://www.docker.com"
#~ "/community-edition/>`_ でインストール方法を読むことができます。"

#~ msgid ""
#~ "Please note that you can use Iroha"
#~ " without ``docker`` as well. You can"
#~ " read about it in other parts "
#~ "of documentation."
#~ msgstr "「いろは」はもちろんDockerなしで使用することも可能です。 この点については、ドキュメントの他の部分で説明されています。"

#~ msgid "Starting Iroha Node"
#~ msgstr "いろはノードを起動する"

#~ msgid "Creating a Docker Network"
#~ msgstr "Dockerネットワークを作成する"

#~ msgid ""
#~ "To operate, Iroha requires a "
#~ "``PostgreSQL`` database. Let's start with "
#~ "creating a Docker network, so containers"
#~ " for Postgres and Iroha can run "
#~ "on the same virtual network and "
#~ "successfully communicate. In this guide "
#~ "we will call it ``iroha-network``, "
#~ "but you can use any name. In "
#~ "your terminal write following command:"
#~ msgstr ""
#~ "Irohaが動作するためには  `PostgreSQL` データベースが必要です。 "
#~ "PostgresとIroha用のコンテナが同じ仮想ネットワーク上で実行され、正常に通信が行われるようにするため、まずはDockerネットワークの作成から始めましょう。"
#~ " 本ガイドでは、「iroha-"
#~ "network」と呼んでいますが、任意の名前を使用することができます。任意の名前を使用するためには、ターミナル上で次のコマンドを実行します。"

#~ msgid "Starting PostgreSQL Container"
#~ msgstr "PostgreSQLのコンテナを起動する"

#~ msgid ""
#~ "Now we need to run ``PostgreSQL`` "
#~ "in a container, attach it to the"
#~ " network you have created before, and"
#~ " expose ports for communication:"
#~ msgstr "では次に、コンテナ内でPostgreSQLを実行し、これまでに作成したネットワークに接続し、通信用ポートを公開します。これらのステップを以下に示します。"

#~ msgid ""
#~ "If you already have Postgres running "
#~ "on a host system on default port"
#~ " (5432), then you should pick another"
#~ " free port that will be occupied. "
#~ "For example, 5433: ``-p 5433:5432 \\``"
#~ msgstr ""
#~ "ホストシステム上のデフォルトポート（5432番）で既にPostgresを実行している場合は、別の空きポートをもう1つ選択する必要があります。"
#~ " たとえば、5433番を指定する場合は、以下のコマンドを実行します。`-p 5433:5432`"

#~ msgid "Creating Blockstore"
#~ msgstr "Blockstoreを作成する"

#~ msgid ""
#~ "Before we run Iroha container, we "
#~ "should create persistent volume to store"
#~ " files, storing blocks for the chain."
#~ " It is done via the following "
#~ "command:"
#~ msgstr ""
#~ "Irohaコンテナを実行する前に、今後ファイルやブロックチェーンを保存していくボリュームを作成する必要があります。 "
#~ "これは次のコマンドで行います。"

#~ msgid "Configuring Iroha Network"
#~ msgstr "Irohaネットワークを設定する"

#~ msgid ""
#~ "To keep things simple, in this "
#~ "guide we will create a network "
#~ "containing only one node. To understand"
#~ " how to run several peers, follow "
#~ "this guide."
#~ msgstr ""
#~ "単純化のために、このガイドでは1つのノードだけで構成されるネットワークを構築します。 "
#~ "複数ピアでの実行方法を理解するためには、このガイドに沿って行ってください。"

#~ msgid ""
#~ "Now we need to configure our Iroha"
#~ " network. This includes creating a "
#~ "configuration file, generating keypairs for"
#~ " a users, writing a list of "
#~ "peers and creating a genesis block. "
#~ "However, we have prepared an example "
#~ "configuration for this guide, so you "
#~ "can start playing with Iroha faster. "
#~ "In order to get those files, you"
#~ " need to clone the `Iroha repository"
#~ " <github.com/hyperledger/iroha>`_ from Github."
#~ msgstr ""
#~ "それでは次に、Irohaネットワークを設定する必要があります。 "
#~ "そのためには、設定ファイルの作成、ユーザーの鍵ペアの生成、ピアノリストの作成、genesis blockの作成が必要です。"
#~ " しかし、私たちはこのガイドの設定例を用意していますので、すぐにIrohaを試してみることができます。 "
#~ "これらのファイルを取得するには、Githubの `Iroha repository "
#~ "<github.com/hyperledger/iroha>`_ をクローンする必要があります。"

#~ msgid ""
#~ "``--depth-1`` option allows us to "
#~ "download only latest commit and save "
#~ "some time and bandwidth. If you "
#~ "want to get a full commit history,"
#~ " you can omit this option."
#~ msgstr ""
#~ "`--depth-1` オプションを使うと、最新のコミットだけをダウンロードし、時間と帯域を節約することができます。 "
#~ "コミット履歴全てを取得する場合は、このオプションを省略してください。"

#~ msgid "Starting Iroha Container"
#~ msgstr "Irohaコンテナを起動する"

#~ msgid ""
#~ "We are ready to launch our Iroha"
#~ " container. Let's do it with the "
#~ "following command"
#~ msgstr "これでIrohaコンテナを起動する準備が整いました。 次のコマンドで早速実行してみましょう。"

#~ msgid "Let's look in detail what this command does:"
#~ msgstr "このコマンドが何を行っているのか詳しくみてみましょう。"

#~ msgid ""
#~ "``docker run -it --name iroha \\`` "
#~ "attaches you to docker container called"
#~ " ``iroha``"
#~ msgstr "`docker run -it --name iroha` は、irohaと名づけられたDockerコンテナへの接続を実行します。"

#~ msgid ""
#~ "with ``$(pwd)/iroha/example:/opt/iroha_data \\`` we"
#~ " add a folder containing our prepared"
#~ " configuration to a docker container "
#~ "into ``/opt/iroha_data``."
#~ msgstr ""
#~ "`$(pwd)/iroha/example:/opt/iroha_data` "
#~ "で、すでに準備されている設定を含むフォルダをDockerのコンテナに``/opt/iroha_data``を追加します。"

#~ msgid ""
#~ "``-v blockstore:/tmp/block_store \\`` adds a"
#~ " persistent block storage which we "
#~ "created before to a container, so "
#~ "our blocks won't be lost after we"
#~ " stop the container"
#~ msgstr ""
#~ "`-v blockstore:/tmp/block_store` "
#~ "では、コンテナに先ほど作成した永続的なブロックストレージを追加するので、コンテナが停止された後でもブロックは失われません。"

#~ msgid ""
#~ "``--network=iroha-network \\`` adds our "
#~ "container to previously created ``iroha-"
#~ "network``, so Iroha and Postgres could"
#~ " see each other."
#~ msgstr ""
#~ "`--network=iroha-network` で、先ほど作成したiroha-"
#~ "networkにコンテナが追加されるので、IrohaとPostgresはお互いを認識することができるようになります。"

#~ msgid ""
#~ "``--entrypoint=/bin/bash \\`` Because ``hyperledger"
#~ "/iroha-docker`` has the custom script "
#~ "which runs after starting the container,"
#~ " we want to override it so we"
#~ " can start Iroha Daemon manually."
#~ msgstr ""
#~ "`--entrypoint =/bin/bash` hyperledger / "
#~ "iroha-"
#~ "dockerはコンテナを起動した後に実行するカスタムスクリプトを持っているので、手動でIrohaデーモンを起動できるようにオーバーライドします。"

#~ msgid ""
#~ "``hyperledger/iroha-docker:develop`` is the "
#~ "image which has the ``develop`` branch."
#~ msgstr "`hyperledger/iroha-docker:develop` は、developブランチを持つイメージです。"

#~ msgid "Launching Iroha Daemon"
#~ msgstr "いろは（Iroha）デーモンを起動する"

#~ msgid ""
#~ "Now you are in the interactive "
#~ "shell of Iroha's container. To actually"
#~ " run Iroha, we need to launch "
#~ "Iroha daemon – ``irohad``."
#~ msgstr "現在あなたは、いろはのコンテナの対話型シェルにいます。 実際にいろはを動かすためには、いろはデーモン「irohad」を起動させます。"

#~ msgid ""
#~ "In the usual situation, you need "
#~ "to provide a config file, generate "
#~ "genesis block and keypair. However, as"
#~ " a part of this guide, we "
#~ "provide an example configuration for "
#~ "you. Please do not use these "
#~ "settings in a production. You can "
#~ "read more about configuration here."
#~ msgstr ""
#~ "通常は、まず設定ファイルを用意し、ジェネシスブロックと鍵ペアを生成する必要がありますが、本ガイドでは、設定例を示します。 "
#~ "これらの設定を本番環境では使用しないでください。 こちらで設定に関する詳細を読むことができます。"

#~ msgid ""
#~ "Congratulations! You have an Iroha node"
#~ " up and running! In the next "
#~ "section, we will test it by "
#~ "sending some transactions."
#~ msgstr "おめでとうございます！ いろはノードが起動しました！ 次のセクションでは、トランザクションを実際にいくつか送信してテストします。"

#~ msgid ""
#~ "You can get more information about "
#~ "``irohad`` and its launch options in "
#~ "this section"
#~ msgstr "このセクションでは、 `` irohad``と起動オプションに関する詳細情報を知ることができます。"

#~ msgid "Interacting with Iroha Network"
#~ msgstr "Irohaネットワークを操作してみる"

#~ msgid ""
#~ "You can interact with Iroha using "
#~ "various ways. You can use our "
#~ "client libraries to write code in "
#~ "various programming languages (e.g. Java, "
#~ "Python, Javascript, Swift) which communicates"
#~ " with Iroha. Alternatively, you can "
#~ "use ``iroha-cli`` – our command-"
#~ "line tool for interacting with Iroha."
#~ " As a part of this guide, let's"
#~ " get familiar with ``iroha-cli``"
#~ msgstr ""
#~ "さまざまな方法でIrohaとやりとりすることができます。 "
#~ "クライアントライブラリを使用することで、さまざまなプログラミング言語（Java、Python、Javascript、Swiftなど）でIrohaと通信するためのコードを記述できます。"
#~ " あるいは、コマンドラインツールである ``iroha-cli``を使うこともできます。 "
#~ "このガイドでは、「iroha-cli」に慣れ親しんでみましょう。"

#~ msgid ""
#~ "Despite that ``iroha-cli`` is arguably"
#~ " the simplest way to start working"
#~ " with Iroha, ``iroha-cli`` was "
#~ "engineered very fast and lacks tests,"
#~ " so user experience might not be "
#~ "the best. For example, the order "
#~ "of menu items can differ from that"
#~ " you see in this guide. In the"
#~ " future, we will deliver a better "
#~ "version and appreciate contributions."
#~ msgstr ""
#~ "「iroha-cli」がおそらくIrohaを操作する上で最も簡単な方法ですが、「iroha-"
#~ "cli」はとても速く動作するよう設計されているため、テストがまだ十分に行われていません。そのため、ユーザーエクスペリエンスはまだ最良ではないかもしれません。"
#~ " たとえば、メニュー項目の表示順序は、本ガイドに記載されている順序とは異なる場合があります。 "
#~ "今後とも、より良いバージョンを提供をしてゆくと共に、みなさまからの品質向上へのご貢献もご歓迎しております。"

#~ msgid ""
#~ "Open a new terminal (note that "
#~ "Iroha container and ``irohad`` should be"
#~ " up and running) and attach to "
#~ "an ``iroha`` docker container:"
#~ msgstr "新しいターミナルを開き（Irohaのコンテナと「irohad」が起動していることに確認してください）、「iroha」ドッカーコンテナに接続してください。以下に示します。"

#~ msgid ""
#~ "Now you are in the interactive "
#~ "shell of Iroha's container again. We "
#~ "need to launch ``iroha-cli`` and "
#~ "pass an account name of the "
#~ "desired user. In our example, the "
#~ "account ``admin`` is already created in"
#~ " a ``test`` domain. Let's use this"
#~ " account to work with Iroha."
#~ msgstr ""
#~ "これで再びIrohaのコンテナのインタラクティブシェルに入りました。 「iroha-"
#~ "cli」を起動させ、目的のユーザーのアカウント名を渡してください。 この例では、アカウント`` "
#~ "admin``はすでに`` "
#~ "test``ドメインに作成されていますので、このアカウントを使ってIrohaを操作してゆくことにしましょう。"

#~ msgid ""
#~ "Full account name has a ``@`` "
#~ "symbol between name and domain. Note "
#~ "that the keypair has the same "
#~ "name."
#~ msgstr "完全なアカウント名には、名前とドメインの間に `` @ ``シンボルがあります。 鍵ペアに同じ名前が用いられている点に注意してください。"

#~ msgid "Creating the First Transaction"
#~ msgstr "1番目のトランザクションを作成する"

#~ msgid ""
#~ "You can see the interface of "
#~ "``iroha-cli`` now. Let's create a new"
#~ " asset, add some asset to the "
#~ "admin account and transfer it to "
#~ "other account. To achieve this, please"
#~ " choose option ``1. New transaction "
#~ "(tx)`` by writing ``tx`` or ``1`` "
#~ "to a console."
#~ msgstr ""
#~ "それでは「iroha-cli」のインターフェースが見えているところで、 "
#~ "新規アセットを作成し、管理者のアカウントにアセットを追加して、そのアセットを他のアカウントに転送してみましょう。 コンソールから"
#~ " ``tx``か ``1``を記述してオプション ``1. New "
#~ "transaction (tx)``を選択してください。"

#~ msgid ""
#~ "Now you can see a list of "
#~ "available commands. Let's try creating a"
#~ " new asset. Select ``14. Create Asset"
#~ " (crt_ast)``. Now enter a name for"
#~ " your asset, for example ``coolcoin``. "
#~ "Next, enter a Domain ID. In our"
#~ " example we already have a domain "
#~ "``test``, so let's use it. Then we"
#~ " need to enter an asset precision "
#~ "– the amount of numbers in a "
#~ "fractional part. Let's set precision to"
#~ " ``2``."
#~ msgstr ""
#~ "これで使用可能なコマンドのリストが表示されます。 では新規アセットを作成してみましょう。 ``14. "
#~ "Create Asset (crt_ast)``を選択します。 "
#~ "次に、資産名を入力してください（例：coolcoin）。 次に、ドメインIDを入力します。 "
#~ "この例では、すでにドメイン `` test``を設定されていますので、それを使いましょう。 "
#~ "そして次に、資産の精度（小数部分の数値）を入力してください。 ここでは精度を ``2``に設定することにします。"

#~ msgid ""
#~ "Congratulations, you have created your "
#~ "first command and added it to a"
#~ " transaction! You can either send it"
#~ " to Iroha or add some more "
#~ "commands ``1. Add one more command "
#~ "to the transaction (add)``. Let's add"
#~ " more commands, so we can do "
#~ "everything in one shot. Type ``add``."
#~ msgstr ""
#~ "最初のコマンドを作成してトランザクションに追加しました！おめでとうございます！ Irohaに送信するか、``1. "
#~ "Add one more command to the "
#~ "transaction (add)``を選択して、さらにコマンドを追加することができます。 "
#~ "一通りの操作を確認するのも兼ねて、ここでもう１つコマンドを追加してみましょう。 ``add``と打ちます。"

#~ msgid ""
#~ "Now try adding some ``coolcoins`` to "
#~ "our account. Select ``16. Add Asset "
#~ "Quantity (add_ast_qty)``, enter Account ID "
#~ "– ``admin@test``, asset ID – "
#~ "``coolcoin#test``, integer part and precision."
#~ " For example, to add 200.50 "
#~ "``coolcoins``, we need to enter integer"
#~ " part as ``20050`` and precision as"
#~ " ``2``, so it becomes ``200.50``."
#~ msgstr ""
#~ "先ほど作成したアカウントにいくつかの「coolcoin」を追加してみてください。 ``16. Add "
#~ "Asset Quantity (add_ast_qty)``を選択し、アカウントID - "
#~ "`` admin@test``、アセットID - "
#~ "``coolcoin#test``、整数部分と精度を入力します。 "
#~ "たとえば、200.50の``coolcoins``を追加するには、整数部分を `` 20050``に、精度を "
#~ "`` 2``とすれば、``200.50``になります。"

#~ msgid "Full asset name has a ``#`` symbol between name and domain."
#~ msgstr "アセット名ではネームとドメイン名の間、「#」があります"

#~ msgid ""
#~ "Let's transfer 100.50 ``coolcoins`` from "
#~ "``admin@test`` to ``test@test`` by adding "
#~ "one more command and choosing ``5. "
#~ "Transfer Assets (tran_ast)``. Enter Source "
#~ "Account and Destination Account, in our"
#~ " case ``admin@test`` and ``test@test``, "
#~ "Asset ID (``coolcoin#test``), integer part "
#~ "and precision (``10050`` and ``2`` "
#~ "accordingly)."
#~ msgstr ""
#~ "100.50 coolcoinsをadmin@testからtest@testへ送金してみましょう。「5. "
#~ "Transfer "
#~ "Assets（tran_ast）」を選んで、送信元アカウントはadmin@testで、宛先はtest@testへ入力してください。アセットIDはcoolcoin#testにして、10050の数字及び精度2を入力してください。"

#~ msgid ""
#~ "Now we need to send our "
#~ "transaction to Iroha peer (``2. Send "
#~ "to Iroha peer (send)``). Enter peer "
#~ "address (in our case ``localhost``) and"
#~ " port (``50051``). Congratulations, your "
#~ "transaction is submitted and you can "
#~ "see your transaction hash. You can "
#~ "use it to check transaction's status."
#~ msgstr ""
#~ "次にこの取引をイロハ・ピアに送る必要があります（「2. Send to Iroha peer"
#~ " (send)」）。 ピアアドレス（本例では `` localhost``）とポート（ "
#~ "`` 50051``）を入力します。 "
#~ "おめでとうございます。トランザクションが送信され、そのトランザクションのハッシュ値が表示されます。 "
#~ "このハッシュ値はトランザクションのステータスを確認するために使用することができます。"

#~ msgid ""
#~ "Go back to a terminal where "
#~ "``irohad`` is running. You can see "
#~ "logs of your transaction."
#~ msgstr "irohadで実行されているターミナルに戻ると取引内容が含まれたログを見られます。"

#~ msgid "Congratulations! You have submitted your first transaction to Iroha."
#~ msgstr "これでイロハに初めてとなるトランザクションの送信が完了しました。おめでとうございます！"

#~ msgid "Creating the First Query"
#~ msgstr "初めてのクエリーを作成する"

#~ msgid ""
#~ "Now let's check if ``coolcoins`` were"
#~ " successfully transferred from ``admin@test`` "
#~ "to ``test@test``. Choose ``2. New query"
#~ " (qry)``. ``7. Get Account's Assets "
#~ "(get_acc_ast)`` can help you to check"
#~ " if ``test@test`` now has ``coolcoin``. "
#~ "Form a query in a similar way "
#~ "you did with commands you did with"
#~ " commands and ``1. Send to Iroha "
#~ "peer (send)``. Now you can see "
#~ "information about how many ``coolcoin`` "
#~ "does ``test@test`` have. It will look"
#~ " similar to this:"
#~ msgstr ""
#~ "さて、 `` coolcoins``が `` admin @ "
#~ "test``から `` test @ "
#~ "test``に正常に転送されたのかどうか確認しましょう。 `` 2. New query"
#~ " (qry)`を選んでください。 新しいクエリ（qry） ``。 `` 7. "
#~ "Get Account's Assets (get_acc_ast)``を選ぶと、`` "
#~ "test @ test``が `` "
#~ "coolcoin``を保有しているかどうかを確認することができます。先ほど``1. Send to "
#~ "Iroha peer (send)``で取引を行った際に利用したコマンドと同様の方法でクエリを作成してください。``"
#~ " test @ test``に``coolcoin``がいくらあるかについての情報を確認することができます。"
#~ " 以下のようになります。"

#~ msgid ""
#~ "Congratulations! You have submitted your "
#~ "first query to Iroha and got a "
#~ "response!"
#~ msgstr "最初のクエリをイロハに送信し、イロハから正常に回答を得られました！おめでとうございます！ "

#~ msgid ""
#~ "To get information about all available"
#~ " commands and queries please check "
#~ "our API section."
#~ msgstr "利用可能なすべてのコマンドとクエリに関する情報をは、APIセクションをご覧ください。"

#~ msgid "Being Badass"
#~ msgstr "悪意を持って、攻撃する"

#~ msgid ""
#~ "Let's try being badass and cheat "
#~ "Iroha. For example, let's transfer more"
#~ " ``coolcoins`` than ``admin@test`` has. Try"
#~ " to transfer 100000.00 ``coolcoins`` from"
#~ " ``admin@test`` to ``test@test``. Again, "
#~ "proceed to ``1. New transaction (tx)``,"
#~ " ``5. Transfer Assets (tran_ast)``, enter"
#~ " Source Account and Destination Account,"
#~ " in our case ``admin@test`` and "
#~ "``test@test``, Asset ID (``coolcoin#test``), "
#~ "integer part and precision (``10000000`` "
#~ "and ``2`` accordingly). Send a "
#~ "transaction to Iroha peer as you "
#~ "did before. Well, it says"
#~ msgstr ""
#~ "それでは少しイロハに意地悪をして、どのようになるか見てみましょう。 例えば、 `` admin "
#~ "@ test``が保有する ``coolcoin``よりも多くのコインを転送してみます。 "
#~ "100000.00の `` coolcoins``を `` admin @"
#~ " test``から `` test @ test``へ転送してみてください。 "
#~ "そしてもう一度、 ``1. New transaction (tx)``、 "
#~ "``5. Transfer Assets (tran_ast)``と順に選択し、 "
#~ "それぞれ送信元と受信元アカウント名に`` admin @ test``と `` "
#~ "test @ test``を入力し、Asset ID（ `` "
#~ "coolcoin#test``）、整数部分と精度（それぞれに応じて「10000000」と「2」）を入力します 。 "
#~ "前回と同じように、イロハ・ピアにトランザクションを送信します。 そうすると、とりあえずは以下のように表示されるでしょう。"

#~ msgid ""
#~ "`Your transaction was accepted for "
#~ "processing`. Does it mean that we "
#~ "had successfully cheated Iroha? Let's "
#~ "try to see transaction's status. Choose"
#~ " ``3. New transaction status request "
#~ "(st)`` and enter transaction's hash "
#~ "which you can get in the console"
#~ " after the previous command. Let's "
#~ "send it to Iroha. It replies with:"
#~ msgstr ""
#~ "送信された取引は受け入れられました。 イロハをうまく欺くことができたのでしょうか？ "
#~ "取引のステータスを確認してみましょう。 `` 3. New transaction "
#~ "status request "
#~ "(st)``を選択実行し、今選択したコマンドの実行後にコンソールに表示されるトランザクションハッシュを入力します。いろはに送って見ましょう。"
#~ " 次のように返答されます："

#~ msgid ""
#~ "Apparently no. Our transaction was not"
#~ " accepted because it did not pass "
#~ "stateful validation and ``coolcoins`` were "
#~ "not transferred. You can check the "
#~ "status of ``admin@test`` and ``test@test`` "
#~ "with queries to be sure (like we"
#~ " did earlier)."
#~ msgstr ""
#~ "どうやら正常に認証されなかったようです。ステートフルな検証は行われなかったため、送ろうとした「coolcoin」が転送されず、そのため先ほどの取引は受け入れられませんでした。"
#~ " 確認のため、（前と同じように）クエリを送って``admin@test``と "
#~ "``test@test``のそれぞれのアカウントの状態を確認することができます。"

#~ msgid "Deploying Iroha"
#~ msgstr "いろはを運用・導入する"

#~ msgid ""
#~ "Hyperledger Iroha can be deployed in "
#~ "different ways, depending on the "
#~ "perspective and the purpose. There can"
#~ " be either a single node deployed,"
#~ " or multiple nodes running in several"
#~ " containers on a local machine or "
#~ "spread across the network — so "
#~ "pick any case you need. This page"
#~ " describes different scenarios and is "
#~ "intended to act as a how-to "
#~ "guide for users, primarily trying out"
#~ " Iroha for the first time."
#~ msgstr ""
#~ "Hyperledger Irohaは、視点と目的に応じてさまざまな方法でシステムを導入することができます。 "
#~ "単一ノードでデプロイされている場合もあれば、複数のノードがローカルマシン上の複数のコンテナで実行される場合や、ネットワーク全体に分散している場合もあります。"
#~ " "
#~ "このページでは、さまざまな導入シナリオについて説明し、初めてイロハを試してユーザーの皆さんのためのハウツーガイドとして役立つように意図されています。"

#~ msgid "Running single instance"
#~ msgstr "１つのインスタンス上で実行する"

#~ msgid ""
#~ "Generally, people want to run Iroha "
#~ "locally in order to try out the"
#~ " API and explore the capabilities. "
#~ "This can be done in local or "
#~ "container environment (Docker). We will "
#~ "explore both possible cases, but in "
#~ "order to simplify peer components "
#~ "deployment, *it is advised to have "
#~ "Docker installed on your machine*."
#~ msgstr ""
#~ "一般的に、まずイロハをローカルで実行してAPIを試し、その機能を試したいと考えています。 "
#~ "これはローカルまたはコンテナ環境（Docker）で行うことができます。 "
#~ "両方のケースを試してみますが、ピアコンポーネントの運用を簡素化するために、*あなたのマシンにDockerをインストールすることをお勧めします*。"

#~ msgid "Local environment"
#~ msgstr "ローカル環境"

#~ msgid ""
#~ "By local environment, it is meant "
#~ "to have daemon process and Postgres "
#~ "deployed without any containers. This "
#~ "might be helpful in cases when "
#~ "messing up with Docker is not "
#~ "preferred — generally a quick "
#~ "exploration of the features."
#~ msgstr ""
#~ "ローカル環境では、デーモンプロセスとPostgresをコンテナなしで運用することを想定しています。 "
#~ "Dockerを使いこなすことが好まれない場合に役立ちますが、機能をざっくり試してみたいというときに便利な方法です。"

#~ msgid "Run postgres server"
#~ msgstr "postgresサーバーを起動させる"

#~ msgid ""
#~ "In order to run postgres server "
#~ "locally, you should check postgres "
#~ "`website <https://www.postgresql.org/docs/current/static"
#~ "/server-start.html>`__ and follow their "
#~ "description. Generally, postgres server runs"
#~ " automatically when the system starts, "
#~ "but this should be checked in the"
#~ " configuration of the system."
#~ msgstr ""
#~ "postgresサーバーをローカルで実行するには、postgres "
#~ "`ウェブサイト<https://www.postgresql.org/docs/current/static/server-"
#~ "start.html>` __に移動し、そのページの説明に従ってください。 "
#~ "一般に、postgresサーバーは、システムの起動時に自動的に実行されますが、この点についてはシステム設定で確認してください。"

#~ msgid "Run iroha daemon (irohad)"
#~ msgstr "いろはデーモン(irohad)を実行する\n"

#~ msgid ""
#~ "There is a list of preconditions "
#~ "which you should meet before proceeding:"
#~ msgstr "これから先に進む前に、以下の前提条件が満たされていなければなりません："

#~ msgid "Postgres server is up and running"
#~ msgstr "Postgresサーバーが起動され、実行されている"

#~ msgid "`irohad` Iroha daemon binary is built and accessible in your system"
#~ msgstr "`irohad` Iroha daemonのバイナリ形式が構築され、利用可能な状態にある"

#~ msgid "The genesis block and configuration files were created"
#~ msgstr "genesis blockを設定ファイルが生成されている"

#~ msgid "Config file uses valid postgres connection settings"
#~ msgstr "設定ファイルで有効なpostgres接続の設定がなされている"

#~ msgid "A keypair for the peer is generated"
#~ msgstr "ピアの鍵ペアが生成されている"

#~ msgid ""
#~ "This is the first time you run "
#~ "the Iroha on this peer and you "
#~ "want to create new chain"
#~ msgstr "これからこのピアのもとにイロハをはじめて実行し、新しいチェーンをこれから作成していく"

#~ msgid ""
#~ "Have you got something that is not"
#~ " the same as in the list of "
#~ "assumptions? Please, refer to the "
#~ "section below the document, titled as"
#~ " `Dealing with troubles`_."
#~ msgstr "上記の前提条件リストと一致していないものがありますか？ この文書の下のセクション、「問題に対処する」の項を参照してください。"

#~ msgid ""
#~ "In case of valid assumptions, the "
#~ "only thing that remains is to "
#~ "launch the daemon process with following"
#~ " parameters:"
#~ msgstr "全ての条件が整えば、あとは以下のパラメーターを用いてデーモンプロセスを起動させるだけです："

#~ msgid "Parameter"
#~ msgstr "パラメーター"

#~ msgid "Meaning"
#~ msgstr "意味"

#~ msgid "config"
#~ msgstr "config"

#~ msgid ""
#~ "configuration file, containing postgres "
#~ "connection and values to tune the "
#~ "system"
#~ msgstr "Postgresへの接続とシステムを調整するための値を含む設定ファイル"

#~ msgid "genesis_block"
#~ msgstr "genesis_block"

#~ msgid "initial block in the ledger"
#~ msgstr "台帳上の１つ目のブロック"

#~ msgid "keypair_name"
#~ msgstr "keypair_name"

#~ msgid ""
#~ "private and public key file names "
#~ "without file extension, used by peer "
#~ "to sign the blocks"
#~ msgstr "ファイル拡張子なしの秘密鍵・公開鍵ファイル名。ブロックに署名する際にピアによって使用されるもの。"

#~ msgid "An example of shell command, running Iroha daemon is"
#~ msgstr "いろはデーモンを実行する際のコマンド例は、"

#~ msgid ""
#~ "If you have stopped the daemon and"
#~ " want to use existing chain — "
#~ "you should not pass the genesis "
#~ "block parameter."
#~ msgstr "もし一旦デーモンを停止しさせ、既存のチェーンを使用したい場合は、ジェネシスブロックのパラメータを渡さないでください。"

#~ msgid "Docker"
#~ msgstr "Docker"

#~ msgid ""
#~ "In order to run Iroha peer as "
#~ "a single instance in Docker, you "
#~ "should pull the image for Iroha "
#~ "first:"
#~ msgstr "Dockerを用いながら１つのインスタンス上でいろはノードを実行させたい場合は、まずIrohaのイメージをプルしてください："

#~ msgid ""
#~ "Use *latest* tag for latest stable "
#~ "release, and *develop* for latest "
#~ "development version"
#~ msgstr "最新の安定版は*latest*タグを、最新の開発版は*develop*してください"

#~ msgid ""
#~ "Then, you have to create an "
#~ "enviroment for the image to run "
#~ "without problems:"
#~ msgstr "次に、正常にイメージを実行するための環境づくりをする必要があります。"

#~ msgid "Create docker network"
#~ msgstr "dockerネットワークを構築する"

#~ msgid ""
#~ "Containers for Postgres and Iroha should"
#~ " run in the same virtual network, "
#~ "in order to be available to each"
#~ " other. Create a network, by typing"
#~ " following command (you can use any"
#~ " name for the network, but in "
#~ "the example, we use *iroha-network* "
#~ "name):"
#~ msgstr ""
#~ "PostgresとIrohaのコンテナは、それぞれ相互に利用できるように、同じ仮想ネットワーク上で実行する必要があります。 "
#~ "次のコマンドを入力してネットワークを作成します（ネットワークには任意の名前を使用できますが、例では* iroha-"
#~ "network * nameを使用しています）。"

#~ msgid "Run Postgresql in a container"
#~ msgstr "コンテナ内でPostgresqlを実行させる"

#~ msgid ""
#~ "Similarly, run postgres server, attaching "
#~ "it to the network you have created"
#~ " before, and exposing ports for "
#~ "communication:"
#~ msgstr "同様に、postgresサーバーを実行して、これまでに作成したネットワークに接続し、通信用にポートを公開します。"

#~ msgid "Create volume for block storage"
#~ msgstr "ブロックの記録・保存用のボリュームを作成する"

#~ msgid ""
#~ "Before we run iroha daemon in the"
#~ " container, we should create persistent "
#~ "volume to store files, storing blocks"
#~ " for the chain. It is done via"
#~ " the following command:"
#~ msgstr ""
#~ "コンテナ内でirohaデーモンを実行する前に、ファイルを格納する永続ボリュームを作成し、チェーンのブロックを格納する必要があります。 "
#~ "これらは次のコマンドで行います。"

#~ msgid "Running iroha daemon in docker container"
#~ msgstr "Dockerコンテナでいろはデーモンを実行する"

#~ msgid ""
#~ "There is a list of assumptions "
#~ "which you should review before "
#~ "proceeding:"
#~ msgstr "下記の条件が必須です："

#~ msgid "Postgres server is running on the same docker network"
#~ msgstr "PostgreSQLのサーバーが同じdockerネットワークで実行している"

#~ msgid "There is a folder, containing config file and keypair for a single node"
#~ msgstr "各サーバーにconfigファイル及びキーペアが持っているフォルダがある"

#~ msgid "If they are met, you can move forward with the following command:"
#~ msgstr "上記の条件が叶えたら、下記のコマンドを実行してください"

#~ msgid "Running multiple instances (peer network)"
#~ msgstr "ピアのネットワークを起動する"

#~ msgid ""
#~ "In order to set up a peer "
#~ "network, one should follow routines, "
#~ "described in this section. In this "
#~ "version, we support manual deployment "
#~ "and automated by Ansible Playbook. "
#~ "Choose an option, that meets your "
#~ "security criteria and other needs."
#~ msgstr ""
#~ "ピアネットワークを設定するには、このセクションで説明するルーチンを実行してください。 "
#~ "このバージョンでは、手動での運用設定が可能で、またAnsible Playbookによって自動化されています。 "
#~ "セキュリティ基準やその他の要件を満たすオプションを選択してください。"

#~ msgid "Manually"
#~ msgstr "手動で行う方法"

#~ msgid ""
#~ "By manual deployment, we mean that "
#~ "Iroha peer network is set up "
#~ "without automated assistance. It is "
#~ "similar to the process of running "
#~ "a single local instance, although the"
#~ " difference is the genesis block "
#~ "includes more than a single peer. "
#~ "In order to form a block, which"
#~ " includes more than a single peer,"
#~ " or requires customization for your "
#~ "needs, please take a look at "
#~ "`Dealing with troubles`_ section."
#~ msgstr ""
#~ "手動での実行では、自動化された支援なしにイロハ・ピア・ネットワークがセットアップされます。 "
#~ "単一のローカルインスタンスを実行するプロセスと似ていますが、違いはジェネシスブロックに複数のピアが含まれていることです。複数のピアを含むブロックを作成する場合、あるいは必要に応じてカスタマイズする必要がある場合は、「問題に対処する」の項を参照してください。"

#~ msgid "Automated"
#~ msgstr "自動で行う方法"

#~ msgid ""
#~ "Anyone can reuse existing Ansible "
#~ "Playbook in order to create a "
#~ "network of peers running Iroha. "
#~ "Currently, this is a solution for "
#~ "development and testing, in other words,"
#~ " a proof of concept, and cannot "
#~ "be used in production environment, due"
#~ " to some security flaws. For "
#~ "production network, a manual composing "
#~ "of genesis block is required."
#~ msgstr ""
#~ "既にいろはを運用している複数のピアでネットワークを構築するために、どなたでも既存のAnsible "
#~ "Playbookを再利用することができます。 現在、開発やテストを行う、つまり、Proof of "
#~ "Conceptを行う際の方法になっています。セキュリティ上に欠陥があるため、実際の運用環境ではまだ使用できません。 "
#~ "実際の運用時でのネットワークでは、ジェネシスブロックを手動で作成するしてください。"

#~ msgid "One ore more <virtual> machines with a Linux distributive installed."
#~ msgstr "Linuxディストリビューションがインストールされている1つ以上の仮想マシン。"

#~ msgid "SSH access to those machines"
#~ msgstr "それらのマシンへのSSHによる接続"

#~ msgid "Ansible installed on a local machine"
#~ msgstr "Ansibleがインストールされたローカルマシン"

#~ msgid "Step-by-step guide"
#~ msgstr "ステップ・バイ・ステップガイド"

#~ msgid "Create peers.list file in $IROHA_HOME/deploy/ansible/data"
#~ msgstr "$IROHA_HOME/deploy/ansible/dataの指定パスにpeers.listというファイルを作成する"

#~ msgid ""
#~ "Write all peers IP addresses followed"
#~ " by the internal port 10001 (e.g "
#~ "31.192.120.36:10001)"
#~ msgstr "すべてのピアのIPアドレスを記述し、それらの末尾に内部通信用ポート番号10001を書きます（例：31.192.120.36:10001）"

#~ msgid "Open $IROHA_HOME/deploy/ansible/hosts file"
#~ msgstr "ターミナルで$IROHA_HOME/deploy/ansible/hosts ファイルを開く"

#~ msgid "Write all IP addresses in [hosts] group"
#~ msgstr "[hosts]グループにすべてのIPアドレスを書き込む"

#~ msgid "Open terminal"
#~ msgstr "ターミナルを開く"

#~ msgid ""
#~ "Disable host key checking, because it"
#~ " can cause troubles due to "
#~ "interactive prompt"
#~ msgstr "対話型プロンプトによる問題を引き起こす可能性があるため、ホストキーチェックを無効にする"

#~ msgid "Go to ansible folder"
#~ msgstr "ansibleフォルダに移動する"

#~ msgid "Run playbook, providing your private key and hosts file"
#~ msgstr "プレイブックの実行、秘密鍵とホストファイルを提供する"

#~ msgid "Wait until playbook finishes and then Iroha network is ready and up."
#~ msgstr "プレイブックが終了すれば、イロハネットワークの準備完了です。"

#~ msgid "Checking Iroha peer status"
#~ msgstr "ピアのステータスを確認する"

#~ msgid "SSH into any of your machines"
#~ msgstr "いずれかのマシンにSSH接続する"

#~ msgid "Check Iroha container logs:"
#~ msgstr "いろはコンテナのログを確認する"

#~ msgid "Dealing with troubles"
#~ msgstr "問題を解決する"

#~ msgid "—\"Please, help me, because I am…\""
#~ msgstr "\"こういう場合はどうすれば対処できますか....。教えてください。\""

#~ msgid "Not having Iroha daemon binary"
#~ msgstr "irohadのバイナリーがない"

#~ msgid ""
#~ "You can build Iroha daemon binary "
#~ "from sources, following API section from"
#~ " the `website <https://hyperledger.github.io/iroha-"
#~ "api/#build>`__"
#~ msgstr ""
#~ "以下のウェブサイト<https://hyperledger.github.io/iroha-"
#~ "api/#build>`__にあるAPIセクションにしたがって、ソースコードからイロハデーモンのバイナリをビルドすることができます。"

#~ msgid "Not having config file"
#~ msgstr "configファイルがない"

#~ msgid ""
#~ "Check how to create a configuration "
#~ "file by following this `link "
#~ "<https://hyperledger.github.io/iroha-api/#prepare-"
#~ "configuration-file>`__"
#~ msgstr ""
#~ "このリンク<https://hyperledger.github.io/iroha-api/#prepare-"
#~ "configuration-file>`__ にしたがって、設定ファイルの作成方法を確認してください。"

#~ msgid "Not having genesis block"
#~ msgstr "ジェネシス・ブロックがない場合"

#~ msgid ""
#~ "Create genesis block by generating it"
#~ " via `iroha-cli` or manually, as "
#~ "it is described `here "
#~ "<https://hyperledger.github.io/iroha-api/#create-"
#~ "genesis-block>`__"
#~ msgstr ""
#~ "ジェネシスブロックを生成する場合は、`iroha-cli`を介して生成してください。手動で生成する場合は、`here "
#~ "<https://hyperledger.github.io/iroha-api/#create-"
#~ "genesis-block>`__で示されている手順にしたがって生成してください。"

#~ msgid "Not having a keypair for a peer"
#~ msgstr "ピアの鍵ペアがない場合"

#~ msgid ""
#~ "In order to create a keypair for"
#~ " an account or a peer, use "
#~ "iroha-cli binary by passing the name"
#~ " of the peer with `--new_account` "
#~ "option."
#~ msgstr ""
#~ "アカウントまたはピアの鍵ペアを作成するには、iroha-cliバイナリを使用して、 "
#~ "`--new_account`オプションでピアの名前を渡して行います。"

#~ msgid "Guides and how-tos"
#~ msgstr "ガイドと実行方法"

#~ msgid ""
#~ "Here we will take a look more "
#~ "closely at how to use Iroha. In"
#~ " essence, this section is a "
#~ "collection of how-tos for different "
#~ "scenarios: - how to install Iroha "
#~ "- what is required to build client"
#~ " libraries and how to use them "
#~ "(for example https://developers.google.com/protocol-"
#~ "buffers/docs/javatutorial) - how to use "
#~ "CLI - how to deploy a network "
#~ "of Iroha peers, etc."
#~ msgstr ""
#~ "ここでは、イロハの使い方をさらに詳しく見ていきます。 "
#~ "このセクションではさまざまなシナリオにおいて利用できる方法を集めて紹介しています。例えば、Irohaのインストール方法、クライアントライブラリを構築するために必要なものとそれらの使用方法（例えば：https://developers.google.com"
#~ "/protocol-buffers/docs/javatutorial）や、CLIの使い方、イロハピアなどのネットワークの展開方法"

#~ msgid "Client libraries"
#~ msgstr "クライアントライブラリ"

#~ msgid "C++ library"
#~ msgstr "C++ライブラリ"

#~ msgid "Where to get"
#~ msgstr "ライブラリを取得する"

#~ msgid "How to use/import"
#~ msgstr "使用・インポート方法"

#~ msgid "Example code"
#~ msgstr "コード例"

#~ msgid "Troubleshooting"
#~ msgstr "うまくいかないときの解決方法"

#~ msgid "Troubleshoting"
#~ msgstr "うまくいかないときの解決方法"

#~ msgid "Maintenance"
#~ msgstr "メインテナンス"

#~ msgid ""
#~ "Hardware requirements, deployment process in"
#~ " details, aspects related to security, "
#~ "configuration files — all of the "
#~ "listed is explained in this separate "
#~ "section, helpful for DevOps engineers or"
#~ " those who are digging deeper in "
#~ "the system capabilities."
#~ msgstr "本項では、ハードウェア要件、デプロイメントプロセスの詳細、セキュリティ関連項目、設定ファイルに関してすべて説明します。これらの説明は、開発・運用担当者、あるいはシステムの細部まで掘り下げてみてみたい人に役立ちます。"

#~ msgid "Ansible"
#~ msgstr "Ansible"

#~ msgid "Use Case Scenarios"
#~ msgstr "ユースケースシナリオ"

#~ msgid ""
#~ "We list a number of use cases "
#~ "and specific advantages that Hyperledger "
#~ "Iroha can introduce to these "
#~ "applications. We hope that the "
#~ "applications and use cases will inspire"
#~ " developers and creators to further "
#~ "innovation with Hyperledger Iroha."
#~ msgstr ""
#~ "Hyperledger Irohaで運用・導入できる多くのユースケース例と具体的な利点を挙げています。 "
#~ "Hyperledger "
#~ "Irohaを使用したこれらのアプリケーションやユースケース例が、開発者やクリエイターによってさらに革新させられることを願っています。"

#~ msgid "Certificates in Education, Healthcare"
#~ msgstr "教育やヘルスケア分野における証書"

#~ msgid ""
#~ "Hyperledger Iroha incorporates into the "
#~ "system multiple certifying authorities such"
#~ " as universities, schools, and medical "
#~ "institutions. Flexible permission model used"
#~ " in Hyperledger Iroha allows building "
#~ "certifying identities, and grant certificates."
#~ " The storage of explicit and implicit"
#~ " information in users' account allows "
#~ "building various reputation and identity "
#~ "systems."
#~ msgstr ""
#~ "ハイパーレジャーいろは（Hyperledger "
#~ "Iroha）は、大学、学校、医療機関などさまざまな認証を必要とする機関のシステムへ組み込むことができます。 "
#~ "Hyperledger "
#~ "Irohaで用いられる柔軟な権限モデルによって、アイデンティティ認証や証書作成、証明書の付与が可能になります。 "
#~ "ユーザーアカウントに明示的および暗黙的な情報を格納することにより、さまざまな評判・信用およびIDシステムを構築することができます。"

#~ msgid ""
#~ "By using Hyperledger Iroha each "
#~ "education or medical certificate can be"
#~ " verified that it was issued by "
#~ "certain certifying authorities. Immutability "
#~ "and clear validation rules provide "
#~ "transparency to health and education "
#~ "significantly reducing the usage of fake"
#~ " certificates."
#~ msgstr ""
#~ "Hyperledger "
#~ "Irohaを使用することにより、各教育機関または医療証明書が、特定の認証機関によって発行されたということを確認することができます。 "
#~ "データの不変性と明確な検証規則によって、偽の証明書の使用を大幅に減らし、健康と教育分野へ透明性を提供します"

#~ msgid "Example"
#~ msgstr "例"

#~ msgid ""
#~ "Imagine a medical institution registered "
#~ "as a ``hospital`` domain in Hyperledger"
#~ " Iroha. This domain has certified and"
#~ " registered workers each having some "
#~ "role, e.g. ``physician``, ``therapist``, "
#~ "``nurse``. Each patient of the hospital"
#~ " has an account with full medical "
#~ "history. Each medical record, like blood"
#~ " test results, is securely and "
#~ "privately stored in the account of "
#~ "the patient as JSON key/values. Rules"
#~ " in ``hospital`` domain are defined "
#~ "such that only certified medical workers"
#~ " and the user can access the "
#~ "personal information. The medical data "
#~ "returned by a query is verified "
#~ "that it comes from a trusted "
#~ "source."
#~ msgstr ""
#~ "例えば、Hyperledger Iroha上に「病院」ドメインとして登録された医療機関を想像してみてください。 "
#~ "このドメインには、認定され登録された従業員がいます。医師、療法士、看護師など、それぞれがそれぞれの役割を持っています。 "
#~ "病院の各患者はそれぞれのアカウントを保有しており、それらに過去のすべての病歴が記載されています。各医療記録は、 "
#~ "血液検査結果のように、JSON key/valuesとして各患者の口座に安全かつ機密的に保管されます。 "
#~ "「病院」ドメインのルールは、認定された医療従事者とユーザーだけが個人情報にアクセスできるように定義されています。 "
#~ "クエリによって返された医療データは、信頼できるソースから取得されたものであるのかが確認されます。"

#~ msgid ""
#~ "Hospital is tied to a specific "
#~ "location, following legal rules of that"
#~ " location, like storing personal data "
#~ "of citizens only in specific "
#~ "regions(`privacy rules`_). A multi-domain "
#~ "approach in Hyperledger Iroha allows "
#~ "sharing information across multiple countries"
#~ " not violating legal rules. For "
#~ "example, if the user ``makoto@hospital`` "
#~ "decides to share personal case history"
#~ " with a medical institution in "
#~ "another country, the user can use "
#~ "``grant`` command with permission "
#~ "``can_get_my_acc_detail``."
#~ msgstr ""
#~ "病院は、例えば特定の地域内でにのみ個人情報を保存するといったように、その場所における個人情報保護に関する法的規則に従って、特定の場所に結ばれます（「プライバシー規則」_）。"
#~ " Hyperledger "
#~ "Irohaのマルチドメインアプローチでは、法的ルールに違反を犯さずに複数の国々間での情報共有を可能にします。 例えば、 "
#~ "\"makoto @ "
#~ "hospital\"というユーザが他の国の医療機関と個人の病歴を共有することを決定した場合、ユーザは `` "
#~ "can_get_my_acc_detail``で許可した上で `` "
#~ "grant``コマンドを使用して行うことができます。"

#~ msgid ""
#~ "Similar to a medical institution, a "
#~ "registered university in Hyperledger Iroha "
#~ "has permissions to push information to"
#~ " the graduated students. A diploma or"
#~ " certificate is essentially Proof-of-"
#~ "Graduation with a signature of "
#~ "recognized University. This approach helps "
#~ "to ease hiring process, with an "
#~ "employer making a query to Hyperledger"
#~ " Iroha to get the acquired skills "
#~ "and competence of the potential "
#~ "employee."
#~ msgstr ""
#~ "医療機関でのケースと同様に、Hyperledger "
#~ "Irohaに登録された大学機関には、卒業生に情報を送信・公開する権限を持つことができます。 "
#~ "卒業証書または証明書は、いわば認定された大学の署名付きの卒業証明です。 "
#~ "こうした方法を利用すると、採用プロセスを簡素化するのにも役立ち、例えば雇用主は採用候補者がこれまで獲得したスキルや能力に関する情報を得るためにHyperledger"
#~ " Irohaに問い合わせを行います。"

#~ msgid "Cross-Border Asset Transfers"
#~ msgstr "国際間の資産移転（授受）"

#~ msgid ""
#~ "Hyperledger Iroha provides fast and "
#~ "clear trade and settlement rules using"
#~ " multi-signature accounts and atomic "
#~ "exchange. Asset management is easy as"
#~ " in centralized systems while providing "
#~ "necessary security guarantees. By simplifying"
#~ " the rules and commands required to"
#~ " create and transfer assets, we lower"
#~ " the barrier to entry, while at "
#~ "the same time maintaining high-security"
#~ " guarantees."
#~ msgstr ""
#~ "Hyperledger "
#~ "Irohaは、マルチサインアカウントとアトミックエクスチェンジ機能を用いて、迅速かつ明確な取引環境、および決済規則を提供します。 "
#~ "資産管理においては、中央集中的に管理されたシステムのように簡単で、必要なセキュリティ保証を提供します。 "
#~ "資産の作成や移転に必要なルールとコマンドを簡素化することで、システム内への侵入障壁を低く抑え、同時に高いセキュリティ水準を保証、維持します。"

#~ msgid ""
#~ "For example [#f1]_, a user might "
#~ "want to transfer the ownership of "
#~ "a car. User ``haruto`` has registered"
#~ " owner-asset relationship with a car"
#~ " of ``sora`` brand with parameters: "
#~ "``{\"id\": \"34322069732074686520616E73776572\", "
#~ "\"color\": \"red\", \"size\": \"small\"}``. "
#~ "This ownership is fixed in an "
#~ "underlying database of the system with"
#~ " copies at each validating peer. To"
#~ " perform the transfer operation user "
#~ "``haruto`` creates an offer, i.e. a "
#~ "multi-signature transaction with two "
#~ "commands: ``transfer`` to user ``haru`` "
#~ "the car identifier and ``transfer`` some"
#~ " amount of ``usd`` tokens from "
#~ "``haru`` to ``haruto``. Upon receiving "
#~ "the offer ``haru`` accepts it by "
#~ "signing the multi-signature transaction, "
#~ "in this case, transaction atomically "
#~ "commits to the system."
#~ msgstr ""
#~ "たとえば[＃f1] "
#~ "_のように、あるユーザーは車の所有権を譲渡したいという場合があるかもしれません。ユーザーの``haruto``は``sora``というブランド名の車（資産）に対する所有権が登録されています。関連するパラメーターはそれぞれ、"
#~ " ``{\"id\": \"34322069732074686520616E73776572\", "
#~ "\"color\": \"red\", \"size\": \"small\"}``です。 "
#~ "この所有権は、システムの基盤となるデータベースに固定的に記録されており、各々の検証ピアにその写しが記録されています。 "
#~ "資産の移転を行うために、ユーザー``haruto``は、別のユーザー``haru``宛てにオファーを行います。つまり``haru``宛てに車の識別子を「転送」するのと、``"
#~ " haru``から `` haruto``へ `` "
#~ "usd``のトークンを「転送」するという2つのコマンドが含まれた複数署名トランザクションを生成します。``haru``はマルチ署名トランザクションに署名することで``haruto``からのオファーを受け取ります。この場合、このトランザクションはシステム内でコミットされます（アトミックエクスチェンジ機能）。"

#~ msgid ""
#~ "Hypeledger Iroha has no built-in "
#~ "token, but it supports different assets"
#~ " from various creators. This approach "
#~ "allows building a decentralized exchange "
#~ "market. For example, the system can "
#~ "have central banks from different "
#~ "countries to issue assets."
#~ msgstr ""
#~ "Hypeledger "
#~ "Iroha自体にトークンは組み込まれていませんが、さまざまな資産とそれらを保有するクリエイターのタイプを扱うことができます。 "
#~ "こうしたアプローチによって、分散型の交換市場を構築することが可能になります。 "
#~ "例えば、このシステム上で異なる国における中央銀行がそれぞれの資産を発行するといったことができます。"

#~ msgid "Currently not implemented"
#~ msgstr "現段階では実装されていません"

#~ msgid "Financial Applications"
#~ msgstr "金融業務におけるアプリケーション"

#~ msgid ""
#~ "Hyperleger Iroha can be very useful "
#~ "in the auditing process. Each "
#~ "information is validated by business "
#~ "rules and is constantly maintained by"
#~ " distinct network participants. Access "
#~ "control rules along with some encryption"
#~ " maintain desired level of privacy. "
#~ "Access control rules can be defined "
#~ "at different levels: user-level, "
#~ "domain-level or system-level. At the"
#~ " user-level privacy rules for a "
#~ "specific individual are defined. If "
#~ "access rules are determined at domain"
#~ " or system level, they are affecting"
#~ " all users in the domain. In "
#~ "Hyperledger Iroha we provide convenient "
#~ "role-based access control rules, where "
#~ "each role has specific permissions."
#~ msgstr ""
#~ "Hyperleger Irohaは、監査業務で非常に役立ちます。 "
#~ "各情報はそれぞれのビジネスルールによって検証され、異なるネットワーク参加者によって常時管理されます。 "
#~ "いくつかの暗号化機能と共に、アクセス制御に関するルールによって所望のプライバシーが維持されます。 "
#~ "アクセス制御ルールは、ユーザーレベル、ドメインレベルまたはシステムレベルといった異なるレベルで定義することができます。 "
#~ "ユーザーレベルでは、特定個人向けのプライバシールールが定義されています。 "
#~ "ドメインまたはシステムレベルでのアクセスルールが定義されると、ドメイン内のすべてのユーザーにそれらが適用されます。 "
#~ "Hyperledger "
#~ "Irohaでは、各役割ごとに特定の権限が付与されるといった役割ベースの便利なアクセス制御ルールが提供されています。"

#~ msgid ""
#~ "Transactions can be traced with a "
#~ "local database. Using Iroha-API auditor"
#~ " can query and perform analytics on"
#~ " the data, execute specific audit "
#~ "software. Hyperledger Iroha supports different"
#~ " scenarios for deploying analytics "
#~ "software:  on a local computer, or "
#~ "execute code on specific middleware. "
#~ "This approach allows analyzing Big Data"
#~ " application with Hadoop, Apache, and "
#~ "others. Hypeledger Iroha serves as a "
#~ "guarantor of data integrity and privacy"
#~ " (due to the query permissions "
#~ "restriction)."
#~ msgstr ""
#~ "トランザクションは、ローカルデータベースを使用して追跡できます。 Iroha-API "
#~ "Auditorを使用すると、データに対してクエリを実行し、分析を実行し、特定の監査ソフトウェアの機能を行うことができます。 "
#~ "Hyperledger "
#~ "Iroha（いろは）は、分析ソフトウェアを展開する上でさまざまなシナリオをサポートしています。ローカルコンピュータ上での実行や、特定のミドルウェアでコードを実行することもできます。"
#~ " こうしたアプローチにより、HadoopやApacheなどのビッグデータアプリケーション分析を行うことができます。 "
#~ "Hypeledger Irohaは、データの完全性と機密性を保証する役割を果たします（クエリ権限の制限による）。"

#~ msgid ""
#~ "For example, auditing can be helpful "
#~ "in financial applications. An auditor "
#~ "account has a role of the "
#~ "``auditor`` with permissions to access "
#~ "the information of users in the "
#~ "domain without bothering the user. To"
#~ " reduce the probability of account "
#~ "hijacking and prevent the auditor from"
#~ " sending malicious queries, the auditor "
#~ "is typically defined as a multi-"
#~ "signature account, meaning that auditor "
#~ "can make queries only having signatures"
#~ " from multiple separate identities. The "
#~ "auditor can make queries not only "
#~ "to fetch account data and balance "
#~ "but also all transactions of a "
#~ "user, e.g. all transfers of user "
#~ "``haruto`` in domain ``konoha``. To "
#~ "efficiently analyze data of million "
#~ "users each Iroha node can work in"
#~ " tandem with analytics software."
#~ msgstr ""
#~ "たとえば、監査は金融アプリケーションにおいて役立つかもしれません。 "
#~ "監査役アカウントは、ユーザーを悩ますことなく、ドメイン内のユーザー関連情報にアクセスする権限を有する「監査役」の役割を担います。 "
#~ "アカウントハイジャックの確率を減らし、監査人が悪意のあるクエリを送信するのを防ぐため、監査人は通常、複数署名アカウントとして定義されます。つまり、監査人は複数の異なるIDからの署名を持つクエリのみを作成することができます。"
#~ " 監査人は、口座データおよび残高情報を取得するだけでなく、ユーザーの全取引情報も取得できます（例えば、 ドメイン "
#~ "\"konoha\"内のユーザー \"haruto\"が行ったすべての移転取引といった具合）。 "
#~ "イロハの各ノードは、分析ソフトウェアと連携して100万ユーザーのデータを効率的に分析することができます。"

#~ msgid ""
#~ "Multi-signature transactions are a "
#~ "powerful tool of Hyperledger Iroha that"
#~ " can disrupt tax system. Each "
#~ "transaction in a certain domain can "
#~ "be as a multi-signature transaction, "
#~ "where one signature comes from the "
#~ "user (for example asset transfer) and"
#~ " the second signature comes from "
#~ "special taxing nodes. Taxing nodes will"
#~ " have special validation rules written "
#~ "using Iroha-API, e.g. each purchase "
#~ "in the certified stores must pay "
#~ "taxes. In other words, Iroha a "
#~ "valid purchase transaction must contain "
#~ "two commands: money transfer(purchase) to "
#~ "the store and money transfer(tax "
#~ "payment) to the government."
#~ msgstr ""
#~ "複数署名取引は、Hyperledger Irohaの強力なツールであり、既存の税制を混乱させる可能性があります。 "
#~ "特定のドメイン内の各トランザクションは、ユーザーからの署名（例えば、資産の譲渡の際）と課税権限を有する特殊なノード（課税ノード）からの第2署名を含んだマルチ署名トランザクションとして扱うことができます。"
#~ " 課税ノードには、Iroha-"
#~ "APIを使用して書かれた特別な検証ルールが規定されています。例えば、商品売上の際に加盟店は税金を支払わなければならないようにするといった事案です。"
#~ " つまり、有効とみなされる購入取引には、店舗への送金（商品購入）と政府への送金（納税）の2つのコマンドが含まれている必要があります。"

#~ msgid "Identity Management"
#~ msgstr "アイデンティティマネジメント"

#~ msgid ""
#~ "Hyperledger Iroha has an intrinsic "
#~ "support for identity management. Each "
#~ "user in the system has a uniquely"
#~ " identified account with personal "
#~ "information, and each transaction is "
#~ "signed and associated with a certain "
#~ "user. This makes Hyperledger Iroha "
#~ "perfect for various application with KYC"
#~ " (Know Your Customer) features."
#~ msgstr ""
#~ "Hyperledger Irohaには、ID管理のための本質的なサポートがあります。 "
#~ "システム内の各ユーザーは、個人情報が関連づけられ、かつ一意に識別されたアカウントを保有し、各取引はその都度署名され、特定のユーザーに関連付けられます。"
#~ " こうすることで、Hyperledger "
#~ "IrohaはKYC（本人確認）機能を持つさまざまなアプリケーションに最適なソリューションを提供します。"

#~ msgid ""
#~ "For example, insurance companies can "
#~ "benefit from querying the information of"
#~ " user’s transaction without worrying about"
#~ " the information truthfulness. Users can"
#~ " also benefit from storing personal "
#~ "information on a blockchain since "
#~ "authenticated information will reduce the "
#~ "time of claims processing. Imagine a "
#~ "situation where a user wants to "
#~ "make a hard money loan. Currently, "
#~ "pre-qualification is a tedious process"
#~ " of gathering information about income, "
#~ "debts and information verification. Each "
#~ "user in Hyperledger Iroha has an "
#~ "account with verified personal information,"
#~ " such as owning assets, job "
#~ "positions, and debts. User income and"
#~ " debts can be traced using query "
#~ "``GetAccountTransactions``, owning assets using "
#~ "query ``GetAccountAssets`` and job positions"
#~ " using ``GetAccountDetail``. Each query "
#~ "returns verified result reducing the "
#~ "processing time of hard money loan "
#~ "will take only a few seconds. To"
#~ " incentivize users to share personal "
#~ "information, various companies can come "
#~ "up with business processes. For example,"
#~ " insurance companies can create bonus "
#~ "discounts for users making fitness "
#~ "activities. Fitness applications can push "
#~ "private Proof-of-Activity to the "
#~ "system, and the user can decide "
#~ "later to share information with "
#~ "insurance companies using ``GrantPermission`` "
#~ "with permission ``can_get_my_acc_detail``."
#~ msgstr ""
#~ "例えば、保険会社におけるユースケースでは、取得情報の真実性を心配することなく、ユーザーの取引情報を照会するといった便利なことが可能になります。一方ユーザーは、認証された個人情報をブロックチェーンに登録しておくことで、保険請求処理に要する時間を短縮されるといった便益を享受することができます。"
#~ "\n"
#~ "ユーザーがローンを組みたいといった状況を想像してみてください。現在のローン事前審査は、収入や借入状況の収集およびそれらの情報検証に多大な時間がかけられています。"
#~ " Hyperledger "
#~ "Irohaの各ユーザーは、保有資産、職位、債務状況などの認証済み個人情報が関連づけられたアカウントを保有しています。ユーザーの所得や借入状況と言いた情報は、"
#~ " `` GetAccountTransactions`のクエリーを使用して、保有資産は `` "
#~ "GetAccountAssets``のクエリーで、ユーザーの職位に関すること情報は`` "
#~ "GetAccountDetail``を使用して追跡・管理することができます。各クエリは検証済みの情報を返すため、ローン審査に要する処理時間が劇的に短縮されます。個人情報を共有するようユーザーにインセンティブを与えるために、さまざまな企業がそれぞれのビジネスプロセスを考え出すことができます。例えば、保険会社はフィットネスを行っているユーザーに対してボーナス割引を適用することができます。フィットネスアプリケーションは、個人の活動証明をシステムにプッシュすることができます。ユーザーは事後的に、"
#~ " `` can_get_my_acc_detail``で情報共有許可を与え、 `` "
#~ "GrantPermission``で保険会社と情報を共有することができます。"

#~ msgid "Supply Chain"
#~ msgstr "サプライチェーン"

#~ msgid ""
#~ "Governance of a decentralized system and"
#~ " representing legal rules as a "
#~ "system's code is an essential "
#~ "combination of any supply chain system."
#~ " Certification system used in Hyperledger"
#~ " Iroha allows tokenization of physical "
#~ "items and embedding them into the "
#~ "system. Each item comes with the "
#~ "information about “what, when, where and"
#~ " why”."
#~ msgstr ""
#~ "分散システムのガバナンスと法規制をシステムコードとして規定することは、あらゆるサプライチェーンシステムにおいて不可欠な組み合わせです。"
#~ " Hyperledger "
#~ "Irohaで使用される認証システムでは、物理的なアイテムのトークン化とそれらのシステムへの埋め込みが可能です。 "
#~ "各項目には「何を、いつ、どこで、なぜ」といった関連情報が付けられています。"

#~ msgid ""
#~ "Permission systems and restricted set of"
#~ " secure core commands narrows the "
#~ "attack vector and provides effortlessly "
#~ "a basic level of privacy. Each "
#~ "transaction is traceable within a system"
#~ " with a hash value, by the "
#~ "credentials or certificates of the "
#~ "creator."
#~ msgstr ""
#~ "許可システムと安全かつその数が制限された主要なコマンド群は、攻撃ベクトルを狭め、基本的なプライバシーを提供します。 "
#~ "各トランザクションはハッシュ値を持ち、作成者の証明書または証明書によってシステム内で追跡できます。"

#~ msgid ""
#~ "Food supply chain is a shared "
#~ "system with multiple different actors, "
#~ "such as farmers, storehouses, grocery "
#~ "stores, and customers. The goal is "
#~ "to deliver food from a farmer's "
#~ "field to the table of a customer."
#~ " The product goes through many "
#~ "stages, with each stage recorded in "
#~ "shared space. A customer scans a "
#~ "code of the product via a mobile"
#~ " device, in which an Iroha query "
#~ "is encoded. Iroha query provides a "
#~ "full history with all stages, "
#~ "information about the product and the"
#~ " farmer."
#~ msgstr ""
#~ "食品分野におけるサプライチェーンは、農家、食品倉庫、食料品店、顧客など、複数の異なる人たちが共有するシステムです。 "
#~ "その最終的な目標は、農家の畑から顧客のテーブルに食品を配達することです。 "
#~ "製品は多くの段階を経て、各段階において共有空間に記録されます。 "
#~ "顧客は、モバイルデバイスを介してイロハクエリが埋め込まれた製品コードを読み取ります。 "
#~ "コードに含まれるイロハのクエリ情報によって、全段階、製品情報そして農家に関する情報を含む全履歴が提供されます。"

#~ msgid ""
#~ "For example, ``gangreen`` is a "
#~ "registered farmer ``tomato`` asset creator,"
#~ " he serves as a guarantor tokenizing"
#~ " physical items, i.e. associating each "
#~ "tomato with an Iroha ``tomato`` item."
#~ " Asset creation and distribution processes"
#~ " are totally transparent for network "
#~ "participants. Iroha ``tomato`` goes on a"
#~ " journey through a multitude of "
#~ "vendors to finally come to user "
#~ "``chad``."
#~ msgstr ""
#~ "例えば、「gangreen」は登録農家のひとつで、「トマト」という資産の生産者であり、イロハシステム内での「トマト」という項目情報と実際のトマトを関連付ける、言い換えれば、物理的な品物をトークン化する保証人です。"
#~ " 資産の新規作成と配布に関わるプロセスは、ネットワーク参加者にとって完全な透明性が実現されます。こうして、 "
#~ "イロハ上の「トマト」は多数のベンダーを通る旅に出て、ついに一人のユーザー「チャド」に届けられます。"

#~ msgid ""
#~ "We simplified asset creation to just "
#~ "a single command ``CreateAsset`` without "
#~ "the need to create complex smart "
#~ "contracts. One the major advantages of"
#~ " Hyperledger Iroha is in its ease,"
#~ " that allows developers to focus on"
#~ " the provided value of their "
#~ "applications."
#~ msgstr ""
#~ "いろはでは、複雑なスマートコントラクトを作成せずに、新たなアセットの作成を「CreateAsset」という単一のコマンドによって集約し、単純化しました。"
#~ " Hyperledger "
#~ "Irohaの主な利点の1つは、開発者がアプリケーションを提供することで生まれる価値に集中できるようになることです。"

#~ msgid "Related Research"
#~ msgstr "関連する研究"

#~ msgid ""
#~ "(The idea was to show current "
#~ "pioneers of blockchain applications and "
#~ "their works.)"
#~ msgstr "（ブロックチェーンアプリケーションのパイオニア達と彼らの成果を示すことが目的でした）。"

#~ msgid "Hyperledger Iroha documentation"
#~ msgstr "Hyperledger Irohaドキュメンテーション"

#~ msgid "Last Reviewed"
#~ msgstr "最新修正"

#~ msgid "2018-03-06"
#~ msgstr ""
#~ "\n"
#~ " 2018-03-06"

#~ msgid ""
#~ "Welcome! Hyperledger Iroha is a simple"
#~ " blockchain platform you can use to"
#~ " make trusted, secure, and fast "
#~ "applications by bringing the power of"
#~ " permission-based blockchain with Byzantine"
#~ " fault-tolerant consensus. It's free, "
#~ "open-source, and works on Linux "
#~ "and Mac OS, with a variety of "
#~ "mobile and desktop libraries."
#~ msgstr ""
#~ "ようこそ！ Hyperledger "
#~ "Iroha（いろは）は、ビザンチンフォールトトレラントなコンセンサスに適合するパーミッションベースのブロックチェーンを実現することで、信頼性が高く、安全で、高速なアプリケーションを作成するためのシンプルな構造に設計されたブロックチェーンプラットフォームです。"
#~ " 無料でオープンソースで、LinuxやMac "
#~ "OS上で動作し、さまざまなモバイル用とデスクトップ用ライブラリが利用できます。"

#~ msgid ""
#~ "You can download the source code "
#~ "of Hyperledger Iroha and latest releases"
#~ " from `GitHub page "
#~ "<https://github.com/hyperledger/iroha>`_."
#~ msgstr ""
#~ "Hyperledger Irohaのソースコードと最新のリリースは、`GitHub page "
#~ "<https://github.com/hyperledger/iroha>`_からダウンロードできます。"

#~ msgid ""
#~ "This documentation will guide you "
#~ "through the installation, deployment, and "
#~ "launch of Iroha network, and explain "
#~ "to you how to write an application"
#~ " for it. We will also see which"
#~ " use case scenarios are feasible now,"
#~ " and are going to be implemented "
#~ "in the future."
#~ msgstr ""
#~ "このドキュメンテーションでは、イロハネットワークのインストール、導入、および起動、アプリケーションの作成方法が説明されています。 "
#~ "また、現在どのユースケースシナリオが実現可能であるのかを確認し、また今後どのようなものが実装予定なのかについても確認します。"

#~ msgid ""
#~ "As Hyperledger Iroha is an open-"
#~ "source project, we will also cover "
#~ "contribution part and explain you a "
#~ "working process."
#~ msgstr ""
#~ "Hyperledger "
#~ "Irohaはオープンソースプロジェクトであるため、プロジェクトへの寄付に関することや、作業プロセスについても説明します。"

#~ msgid ""
#~ "There is a separate website for "
#~ "all external API documentation, which is"
#~ " `Iroha API <https://hyperledger.github.io/iroha-"
#~ "api>`_. We are in the process of"
#~ " migration, so that in future only"
#~ " RTD is maintained and updated."
#~ msgstr ""
#~ "外部APIドキュメントのため別個のウェブサイト`Iroha API "
#~ "<https://hyperledger.github.io/iroha-api>` _があります。 "
#~ "現在、このいろはプロジェクトのドキュメンテーションは移行段階にあり、将来的にはRTD（Read the "
#~ "Docs）だけが維持・更新されるようになっています。"

#~ msgid "Overview of Iroha"
#~ msgstr "Irohaの概要"

#~ msgid "What are the key features of Iroha?"
#~ msgstr "Irohaの主な特長は何ですか？"

#~ msgid "Where Iroha can be used?"
#~ msgstr "どのような場合に「いろは」は使えますか？"

#~ msgid "How is it different from Bitcoin or Ethereum?"
#~ msgstr "BitcoinやEthereumとはどのような点が違うのですか？"

#~ msgid ""
#~ "How is it different from the rest"
#~ " of Hyperledger frameworks or other "
#~ "permissioned blockchains?"
#~ msgstr "その他のHyperledgerフレームワークや他のパーミッション・ブロックチェーンとはどのように違いますか？"

#~ msgid "Is it fast?"
#~ msgstr "高速ですか？"

#~ msgid "How to create applications around Iroha?"
#~ msgstr "どのようなアプリケーションを「いろは」と関連して構築できますか？"

#~ msgid ""
#~ "A command changes the state, called "
#~ "World State View, by performing an "
#~ "action over an entity (asset, account)"
#~ " in the system. Any command should"
#~ " be included in a transaction to "
#~ "perform an action."
#~ msgstr ""
#~ "コマンドは、システム内のエンティティ（アセット、アカウント）に対する特定のアクションを実行することにより、システムの状態（World "
#~ "State Viewと呼ばれる）を変更させます。 "
#~ "アクションを実行するには、コマンドをトランザクションに含める必要があります。"

#~ msgid "Purpose"
#~ msgstr "目的"

#~ msgid ""
#~ "The purpose of add asset quantity "
#~ "command is to increase the quantity "
#~ "of an asset on account of "
#~ "transaction creator. Use case scenario "
#~ "is to increase the number of a "
#~ "mutable asset in the system, which "
#~ "can act as a claim on a "
#~ "commodity (e.g. money, gold, etc.)"
#~ msgstr ""
#~ "資産量を追加するコマンド（add asset "
#~ "quantity）の目的は、取引作成者のアカウント内の資産量を増やすことです。 "
#~ "ユースケースのシナリオでは、システム内の変更可能な資産の数を増やすことであり、それらは商品（例えば、貨幣や金など）に対する権利として機能します。"

#~ msgid "Schema"
#~ msgstr "スキーム"

#~ msgid "Structure"
#~ msgstr "構造"

#~ msgid "Field"
#~ msgstr "フィールド"

#~ msgid "Description"
#~ msgstr "説明"

#~ msgid "Constraint"
#~ msgstr "制約"

#~ msgid "Account ID"
#~ msgstr "アカウントID"

#~ msgid "account id in which to add asset"
#~ msgstr "資産を追加するアカウントID"

#~ msgid "<account_name>@<domain_id>"
#~ msgstr "<account_name>@<domain_id>"

#~ msgid "alex@morgan"
#~ msgstr "alex@morgan"

#~ msgid "Asset ID"
#~ msgstr "資産ID"

#~ msgid "id of the asset"
#~ msgstr "資産のID"

#~ msgid "<asset_name>#<domain_id>"
#~ msgstr "<asset_name>#<domain_id>"

#~ msgid "usd#morgan"
#~ msgstr "usd#morgan"

#~ msgid "Amount"
#~ msgstr "量"

#~ msgid "positive amount of the asset to add"
#~ msgstr "追加すべき資産量（正数）"

#~ msgid "> 0"
#~ msgstr ">0"

#~ msgid "200.02"
#~ msgstr "200.02"

#~ msgid "Asset and account should exist"
#~ msgstr "資産とアカウントがなければなりません"

#~ msgid "Added quantity precision should be equal to asset precision"
#~ msgstr "追加された数量の精度は、資産精度と同じである必要があります"

#~ msgid ""
#~ "Creator of a transaction should have "
#~ "a role which has permissions for "
#~ "issuing assets"
#~ msgstr "トランザクションの作成者は、資産を発行する権限を有している必要があります"

#~ msgid "Creator of a transaction adds account quantity to his/her account only"
#~ msgstr "取引の作成者はアカウントの数量をアカウントにのみ追加します"

#~ msgid ""
#~ "The purpose of add peer command is"
#~ " to write into ledger the fact "
#~ "of peer addition into the peer "
#~ "network. After a transaction with "
#~ "AddPeer has been committed, consensus "
#~ "and synchronization components will start "
#~ "using it."
#~ msgstr ""
#~ "add peerコマンドの目的は、ピアネットワークに向けてピアが追加された事実を台帳に書き込むことです。 "
#~ "AddPeerが実行されたトランザクションがコミットされた後、コンセンサスおよび同期コンポーネントがそれらの事実を適用し始めます。"

#~ msgid "Address"
#~ msgstr "アドレス"

#~ msgid "resolvable address in network (IPv4, IPv6, domain name, etc.)"
#~ msgstr "ネットワーク内の解決可能なアドレス（IPv4、IPv6、ドメイン名など）"

#~ msgid "should be resolvable"
#~ msgstr "解決可能なはずです"

#~ msgid "192.168.1.1:50541"
#~ msgstr ""
#~ "\n"
#~ "192.168.1.1:50541"

#~ msgid "Peer key"
#~ msgstr "ピアが保有する鍵"

#~ msgid ""
#~ "peer public key, which is used in"
#~ " consensus algorithm to sign-off "
#~ "vote, commit, reject messages"
#~ msgstr "ピアの公開鍵（投票時のサインオフ、コミット、メッセージの拒否といった合意形成アルゴリズムで使用されます）"

#~ msgid "ed25519 public key"
#~ msgstr "ed25519 公開鍵"

#~ msgid "292a8714694095edce6be799398ed5d6244cd7be37eb813106b217d850d261f2"
#~ msgstr "292a8714694095edce6be799398ed5d6244cd7be37eb813106b217d850d261f2"

#~ msgid "Creator of the transaction has a role which has CanAddPeer permission"
#~ msgstr "トランザクションの作成者にはCanAddPeerの権限を有する役割が与えられています"

#~ msgid "Such network address has not been already added"
#~ msgstr "そのようなネットワークアドレスはまだ追加されていません"

#~ msgid ""
#~ "The purpose of add signatory command "
#~ "is to add an identifier to the "
#~ "account. Such identifier is a public "
#~ "key of another device or a public"
#~ " key of another user."
#~ msgstr "署名追加のためのコマンドの目的は、アカウントに識別子を与えることです。 それら識別子は、他の端末の公開鍵またはユーザの公開鍵が用いられます。"

#~ msgid "Account to which to add signatory"
#~ msgstr "新たな署名者を追加するアカウント"

#~ msgid "makoto@soramitsu"
#~ msgstr "makoto@soramitsu"

#~ msgid "Public key"
#~ msgstr "公開鍵"

#~ msgid "Signatory to add to account"
#~ msgstr "アカウントに追加する署名者"

#~ msgid "359f925e4eeecfdd6aa1abc0b79a6a121a5dd63bb612b603247ea4f8ad160156"
#~ msgstr "359f925e4eeecfdd6aa1abc0b79a6a121a5dd63bb612b603247ea4f8ad160156"

#~ msgid "Two cases:"
#~ msgstr "２つの事例："

#~ msgid ""
#~ "Case 1. Transaction creator wants to "
#~ "add a signatory to his or her "
#~ "account, having permission CanAddSignatory"
#~ msgstr "ケース1：CanAddSignatoryの権限を有する取引作成者が、署名を自分のアカウントに追加したいと考えています。"

#~ msgid "Case 2. CanAddSignatory was granted to transaction creator"
#~ msgstr "ケース2. CanAddSignatoryがトランザクション作成者に付与されました"

#~ msgid ""
#~ "The purpose of append role command "
#~ "is to promote an account to some"
#~ " created role in the system, where"
#~ " a role is a set of permissions"
#~ " account has to perform an action "
#~ "(command or query)."
#~ msgstr "AppendRole（役割の追加）コマンドの目的は、システム内で既に存在する役割をあるアカウントが担うことができるようにすることです。この役割（Role）とは、アカウントがシステム内での特定のアクション（コマンド又はクエリ）を実行するために必要な権限です。"

#~ msgid "id or account to append role to"
#~ msgstr "役割を追加するIDまたはアカウント"

#~ msgid "already existent"
#~ msgstr "既に存在する"

#~ msgid "Role name"
#~ msgstr "Role name (役割名)"

#~ msgid "name of already created role"
#~ msgstr "システム内ですでに規定された役割名"

#~ msgid "MoneyCreator"
#~ msgstr "貨幣の発行者"

#~ msgid "The role should exist in the system"
#~ msgstr "役割はシステムに存在しているはずです"

#~ msgid ""
#~ "Transaction creator should have permissions"
#~ " to append role (CanAppendRole)"
#~ msgstr "取引の作成者は役割を追加する権限が必要です（CanAppendRole）"

#~ msgid ""
#~ "Account, which appends role, has set "
#~ "of permissions in his roles that "
#~ "is a superset of appended role (in"
#~ " other words no-one can append "
#~ "role that is more powerful than "
#~ "what transaction creator is)"
#~ msgstr "役割を追加するアカウントは、追加された役割のスーパーセットである自分の役割に権限のセットを持っています（つまり、どのアカンウト保有者もトランザクション作成者より上位の役割を追加することはできません）"

#~ msgid ""
#~ "The purpose of create account command"
#~ " is to make entity in the "
#~ "system, capable of sending transactions "
#~ "or queries, storing signatories, personal "
#~ "data and identifiers."
#~ msgstr "CreateAccountコマンドの目的は、トランザクションやクエリの送信、署名者、個人情報および識別子を格納することができるエンティティをシステム内に作成することです。"

#~ msgid "Account name"
#~ msgstr "Account name（アカウント名）"

#~ msgid "domain-unique name for account"
#~ msgstr "ドメイン内で一意のアカウント名"

#~ msgid "`[a-z_0-9]{1,32}`"
#~ msgstr "`[a-z_0-9]{1,32}`"

#~ msgid "morgan_stanley"
#~ msgstr "morgan_stanley"

#~ msgid "Domain ID"
#~ msgstr "ドメインID"

#~ msgid "target domain to make relation with"
#~ msgstr "関係するターゲットドメイン"

#~ msgid "should be created before the account"
#~ msgstr "アカウントの前に作成する必要があります"

#~ msgid "america"
#~ msgstr "america"

#~ msgid "Main pubkey"
#~ msgstr "公開鍵"

#~ msgid "first public key to add to the account"
#~ msgstr "アカウントに追加する最初の公開鍵"

#~ msgid "407e57f50ca48969b08ba948171bb2435e035d82cec417e18e4a38f5fb113f83"
#~ msgstr "407e57f50ca48969b08ba948171bb2435e035d82cec417e18e4a38f5fb113f83"

#~ msgid "Transaction creator has permission to create an account"
#~ msgstr "取引作成者にはアカウントを作成する権限があります"

#~ msgid "Domain, passed as domain_id, has already been created in the system"
#~ msgstr "domain_idとして渡されたドメインは、すでにシステム内で作成されています"

#~ msgid ""
#~ "Such public key has not been added"
#~ " before as first public key of "
#~ "account or added to a multi-"
#~ "signature account"
#~ msgstr "そのような公開鍵は、アカウントの最初の公開鍵として追加されていないか、またはマルチ署名アカウントに追加されていません"

#~ msgid ""
#~ "The purpose of сreate asset command "
#~ "is to create a new type of "
#~ "asset, unique in a domain. An "
#~ "asset is a countable representation of"
#~ " a commodity."
#~ msgstr "create assetコマンドの目的は、ドメイン内で一意の新規アセットを作成することです。 資産とは、商品の可算表現です。"

#~ msgid "Asset name"
#~ msgstr "Asset name (資産名)"

#~ msgid "domain-unique name for asset"
#~ msgstr "ドメイン内で一意のアセット名"

#~ msgid "soracoin"
#~ msgstr "soracoin"

#~ msgid "RFC1035 [#f1]_, RFC1123 [#f2]_"
#~ msgstr "RFC1035 [#f1]_, RFC1123 [#f2]_"

#~ msgid "japan"
#~ msgstr "japan"

#~ msgid "Precision"
#~ msgstr "Precision (精度)"

#~ msgid "number of digits after comma/dot"
#~ msgstr "コンマ/ドットに後につづく桁数"

#~ msgid "0 <= precision <= uint32 max"
#~ msgstr "0 <= 精度 <= 32 (最大単位) "

#~ msgid "2"
#~ msgstr "2"

#~ msgid "Transaction creator has permission to create assets"
#~ msgstr "トランザクション作成者にアセットを作成する権限があります"

#~ msgid "Asset name is unique in domain"
#~ msgstr "アセット名はドメイン内で一意です"

#~ msgid ""
#~ "The purpose of create domain command "
#~ "is to make new domain in Iroha "
#~ "network, which is a group of "
#~ "accounts."
#~ msgstr "CreateDomainコマンドの目的は、イロハネットワークに新しいドメインを作成することで、ドメインは複数のアカウントで構成されるひとつのグループです。"

#~ msgid "ID for created domain"
#~ msgstr "作成されたドメインのID"

#~ msgid "unique, RFC1035 [#f1]_, RFC1123 [#f2]_"
#~ msgstr "一意に区別される、RFC1035 [#f1]_, RFC1123 [#f2]_"

#~ msgid "japan05"
#~ msgstr "japan05"

#~ msgid "Default role"
#~ msgstr "デフォルトでの役割"

#~ msgid "role for any created user in the domain"
#~ msgstr "ドメイン内で作成されたユーザーの役割"

#~ msgid "one of the existing roles"
#~ msgstr "既にシステム内に存在する役割"

#~ msgid "User"
#~ msgstr "User"

#~ msgid "Domain ID is unique"
#~ msgstr "ドメインIDが一意"

#~ msgid ""
#~ "Account, who sends this command in "
#~ "transaction, has role with permission to"
#~ " create domain"
#~ msgstr "トランザクションでこのコマンドを送信するアカウントは、ドメインの作成権限を有する役割を持っていること"

#~ msgid ""
#~ "Role, which will be assigned to "
#~ "created user by default, exists in "
#~ "the system"
#~ msgstr "既に作成されていたユーザーに割り当てられる役割が、システム内に存在すること"

#~ msgid ""
#~ "The purpose of create role command "
#~ "is to create a new role in "
#~ "the system from the set of "
#~ "permissions. Combining different permissions "
#~ "into roles, maintainers of Iroha peer"
#~ " network can create customized security "
#~ "model."
#~ msgstr ""
#~ "CreateRoleコマンドの目的は、一連の権限の中から新しい役割をシステム内に追加することです。 "
#~ "イロハのピアネットワークの管理・運営担当者は、異なる権限を役割に組み合わせることで、カスタマイズされたセキュリティモデルを構築することができます。"

#~ msgid "name of role to create"
#~ msgstr "作成する役割の名称"

#~ msgid "Permissions"
#~ msgstr "Permissions"

#~ msgid "array of already existent permissions"
#~ msgstr "既存の権限の配列"

#~ msgid ""
#~ "set of passed permissions is fully "
#~ "included into set of existing "
#~ "permissions"
#~ msgstr "渡された一連のアクセス許可は、既存のアクセス許可に全て含まれていること"

#~ msgid "{can_receive, can_transfer}"
#~ msgstr "{can_receive, can_transfer}"

#~ msgid ""
#~ "Set of passed permissions is fully "
#~ "included into set of existing "
#~ "permissions"
#~ msgstr "渡された一連のアクセス許可は、既存のアクセス許可に全て含まれていること"

#~ msgid "Set of the permissions is not empty"
#~ msgstr "ひとつ以上の権限が設定されていること"

#~ msgid ""
#~ "The purpose of detach role command "
#~ "is to detach a role from the "
#~ "set of roles of an account. By "
#~ "executing this command it is possible"
#~ " to decrease the number of possible"
#~ " actions in the system for the "
#~ "user."
#~ msgstr ""
#~ "DetachRoleコマンドの目的は、アカウントに付与された役割から特定の役割を切り離すことです。 "
#~ "このコマンドを実行することにより、ユーザのシステムで実行可能なアクションの数を減らすことができます。"

#~ msgid "ID of account where role will be deleted"
#~ msgstr "役割が削除されるアカウントのID"

#~ msgid "a detached role name"
#~ msgstr "削除する役割の名称"

#~ msgid "existing role"
#~ msgstr "既存の役割であること"

#~ msgid "The role exists in the system"
#~ msgstr "削除される役割がシステムに存在する"

#~ msgid "The account has such role"
#~ msgstr "アカウントが削除される役割を持っている"

#~ msgid ""
#~ "The purpose of grant permission command"
#~ " is to give another account rights"
#~ " to perform actions on the account"
#~ " of transaction sender (give someone "
#~ "right to do something with my "
#~ "account)."
#~ msgstr "GrantPermissionコマンドの目的は、取引の送信者のアカウントに対して特定のアクションを実行する権限を別のアカウントに与えることです（自分のアカウントに対して何かを行う権限を他者に与える）。"

#~ msgid "id of account whom rights are granted"
#~ msgstr "権限が新しく付与されるアカウントのID"

#~ msgid "Permission name"
#~ msgstr "Permission name（権限の名称）"

#~ msgid "name of granted permission"
#~ msgstr "付与された権限の名称"

#~ msgid "permission is defined"
#~ msgstr "許可が拒否される"

#~ msgid "CanTransferAssets"
#~ msgstr "CanTransferAssets"

#~ msgid "Account exists"
#~ msgstr "アカウントが存在する"

#~ msgid "Transaction creator is allowed to grant this permission"
#~ msgstr "トランザクションの作成者がその許可を与えることができる"

#~ msgid "Remove signatory"
#~ msgstr "署名者を削除する"

#~ msgid ""
#~ "Purpose of remove signatory command is"
#~ " to remove a public key, associated"
#~ " with an identity, from an account"
#~ msgstr "RemoveSignatoryコマンドの目的は、特定のIDと関連付けられた公開鍵をそのアカウントから削除することです"

#~ msgid "Signatory to delete"
#~ msgstr "削除する署名者"

#~ msgid ""
#~ "When signatory is deleted, we should "
#~ "check if invariant of **size(signatories) "
#~ ">= quorum** holds"
#~ msgstr ""
#~ "署名者の削除が実行された後に、** size（signatories）> = quorum "
#~ "**の不変式が成立するかどうかを調べる必要があります"

#~ msgid "Signatory should have been previously added to the account"
#~ msgstr "署名者が削除される以前にアカウントに追加されていた必要があります"

#~ msgid ""
#~ "Case 1. When transaction creator wants"
#~ " to remove signatory from their "
#~ "account and he or she has "
#~ "permission CanRemoveSignatory"
#~ msgstr "ケース1：トランザクションの作成者が署名者をアカウントから削除したい場合、CanRemoveSignatoryの実行権限を得ていること"

#~ msgid "Case 2. CanRemoveSignatory was granted to transaction creator"
#~ msgstr "ケース2. CanRemoveSignatoryがトランザクション作成者に付与されていたこと"

#~ msgid ""
#~ "The purpose of revoke permission command"
#~ " is to revoke or dismiss given "
#~ "granted permission from another account "
#~ "in the network."
#~ msgstr "RevokePermissionコマンドの目的は、与えられていた権限をネットワーク内の別のアカウントから取り消すことです。"

#~ msgid "permission was granted"
#~ msgstr "実行権限が与えられていたこと"

#~ msgid ""
#~ "Transaction creator should have previously "
#~ "granted this permission to a target "
#~ "account"
#~ msgstr "トランザクションの作成者は、以前にこの権限をターゲットアカウントに付与している必要があります"

#~ msgid ""
#~ "Purpose of set account detail command"
#~ " is to set key-value information "
#~ "for a given account"
#~ msgstr "SetAccountDetailコマンドの目的は、特定のアカウントのキーバリュー情報を設定することです"

#~ msgid "id of account whom key-value information was set"
#~ msgstr "Key-Value情報が設定されたアカウントのID"

#~ msgid "Key"
#~ msgstr "Key"

#~ msgid "key of information being set"
#~ msgstr "設定されるキーに関する情報"

#~ msgid "`[A-Za-z0-9_]{1,64}`"
#~ msgstr "`[A-Za-z0-9_]{1,64}`"

#~ msgid "Name"
#~ msgstr "Name"

#~ msgid "Value"
#~ msgstr "Value"

#~ msgid "value of corresponding key"
#~ msgstr "対応するキーの値"

#~ msgid "≤ 4096"
#~ msgstr "≤ 4096"

#~ msgid "Makoto"
#~ msgstr "Makoto"

#~ msgid ""
#~ "Case 1. When transaction creator wants"
#~ " to set account detail to his/her "
#~ "account and he or she has "
#~ "permission CanSetAccountInfo"
#~ msgstr "ケース1.取引の作成者が口座の詳細情報を設定したい場合に、その作成者がCanSetAccountInfoの実行権限を得ている"

#~ msgid "Case 2. CanSetAccountInfo was granted to transaction creator"
#~ msgstr "ケース2. CanSetAccountInfoがトランザクション作成者に付与された場合"

#~ msgid ""
#~ "The purpose of set account quorum "
#~ "command is to set the number of"
#~ " signatories required to confirm the "
#~ "identity of a user, who creates "
#~ "the transaction. Use case scenario is"
#~ " to set the number of different "
#~ "users, utilizing single account, to sign"
#~ " off the transaction."
#~ msgstr ""
#~ "SetAccountQuorumコマンドの目的は、トランザクションを作成するユーザーの身元を確認するために必要な署名者の定足数を設定することです。"
#~ " ユース・ケース・シナリオにおいては、単一アカウントで異なるユーザー数を設定し、トランザクションをサインオフすることです。"

#~ msgid "ID of account to set quorum"
#~ msgstr "定足数を設定するアカウントのID"

#~ msgid "Quorum"
#~ msgstr "Quorum"

#~ msgid ""
#~ "number of signatories needed to be "
#~ "included with a transaction from this"
#~ " account"
#~ msgstr "この口座からの取引に含まれて含まれなければならない署名者の数（定足数）"

#~ msgid "0 < quorum ≤ public-key set up to account ≤ 128"
#~ msgstr "0 < quorum ≤ public-key set up to account ≤ 128"

#~ msgid "5"
#~ msgstr "5"

#~ msgid ""
#~ "When quorum is set, it is checked"
#~ " if invariant of **size(signatories) >= "
#~ "quorum** holds."
#~ msgstr "定足数が設定されると、**size(signatories) >= quorum**の不変式が成立するかどうかがチェックされます。"

#~ msgid ""
#~ "Case 1. When transaction creator wants"
#~ " to set quorum for his/her account"
#~ " and he or she has permission "
#~ "CanRemoveSignatory"
#~ msgstr "ケース1.トランザクション作成者がアカウントの定足数を設定し、かつそのユーザーがCanRemoveSignatory権限を持っている場合"

#~ msgid ""
#~ "The purpose of subtract asset quantity"
#~ " command is the opposite of "
#~ "AddAssetQuantity commands — to decrease "
#~ "the number of assets on account of"
#~ " transaction creator."
#~ msgstr "SubtractAssetQuantityコマンドの目的は、取引の作成者のアカウント内の資産量を減らすためです。AddAssetQuantityコマンドの逆の操作になります。"

#~ msgid "account id from which to subtract asset"
#~ msgstr "資産を引き出すアカウントID"

#~ msgid "positive amount of the asset to subtract"
#~ msgstr "差し引く資産量（正数）"

#~ msgid "200"
#~ msgstr "200"

#~ msgid ""
#~ "Creator of the transaction should have"
#~ " a role which has permissions for "
#~ "subtraction of assets"
#~ msgstr "トランザクションの作成者は、資産を引き出す権限を持つ役割を持つ必要があります"

#~ msgid ""
#~ "Creator of transaction subtracts account "
#~ "quantity in his/her account only"
#~ msgstr "取引の作成者は、アカウント内の存在する値だけを減算します"

#~ msgid ""
#~ "The purpose of transfer asset command"
#~ " is to share assets within the "
#~ "account in peer network: in the "
#~ "way that source account transfers assets"
#~ " to the target account."
#~ msgstr "TransferAssetコマンドの目的は、ピアネットワーク内のアカウント間で資産を共有することです。移転元アカウントが資産を移転先ターゲットアカウントに転送する方法です。"

#~ msgid "Source account ID"
#~ msgstr "Source account ID (移転元口座)"

#~ msgid "ID of account to withdraw asset from"
#~ msgstr "資産を引き出すアカウントのID"

#~ msgid "Destination account ID"
#~ msgstr "Destination account ID (移転先口座)"

#~ msgid "ID of account to send asset at"
#~ msgstr "アセットを送信するアカウントのID"

#~ msgid "alex@california"
#~ msgstr "alex@california"

#~ msgid "ID of asset to transfer"
#~ msgstr "移転する資産のID"

#~ msgid "usd#usa"
#~ msgstr "usd#usa"

#~ msgid "Message to attach to transfer"
#~ msgstr "転送する際に添付するメッセージ"

#~ msgid "Max length is 64"
#~ msgstr "最大64文字まで"

#~ msgid "here's my money take it"
#~ msgstr "here's my money take it"

#~ msgid "amount of the asset to transfer"
#~ msgstr "移転する資産の量（金額など）"

#~ msgid "0 < amount < max_uint256"
#~ msgstr "0 < amount < max_uint256"

#~ msgid "200.20"
#~ msgstr "200.20"

#~ msgid "Source account has this asset in its AccountHasAsset relation [#f1]_"
#~ msgstr "移転元アカウントのAccountHasAssetに当該アセットがあること"

#~ msgid ""
#~ "An amount is a positive number and"
#~ " asset precision is consistent with "
#~ "the asset definition"
#~ msgstr "移転する量（金額など）が正数で、精度が資産定義項目と一致すること"

#~ msgid "Source account has enough amount of asset to transfer and is not zero"
#~ msgstr "ソースアカウントに転送する資産が十分にあり、ゼロではないこと"

#~ msgid ""
#~ "Source account can transfer money, and"
#~ " destination account can receive money "
#~ "(their roles have these permissions)"
#~ msgstr "送信元アカウントがお金を転送することができ、宛先アカウントもお金を受け取ることができる（それぞれにこれらの権限が付与されていること）"

#~ msgid "https://www.ietf.org/rfc/rfc1035.txt"
#~ msgstr ""
#~ "\n"
#~ "https://www.ietf.org/rfc/rfc1035.txt"

#~ msgid "https://www.ietf.org/rfc/rfc1123.txt"
#~ msgstr ""
#~ "\n"
#~ " https://www.ietf.org/rfc/rfc1123.txt"

#~ msgid "Contents are missing for now."
#~ msgstr "今後コンテンツが足されていきます。"

#~ msgid ""
#~ "In API section we will take a "
#~ "look at building blocks of an "
#~ "application interacting with Iroha. We "
#~ "will overview commands and queries that"
#~ " the system has, and the set of"
#~ " client libraries encompassing transport "
#~ "and application layer logic."
#~ msgstr ""
#~ "APIセクションでは、実際にいろはでの動作を見ながら、いろはを構成する要素について見ていきます。 "
#~ "システムが持つコマンドやクエリの種類、およびトランスポート層とアプリケーション層にわたるクライアントライブラリを概観します。"

#~ msgid ""
#~ "A query is a request related to"
#~ " certain part of World State View "
#~ "— the latest state of blockchain. "
#~ "Query cannot modify the contents of "
#~ "the chain and a response is "
#~ "returned to any client immediately after"
#~ " receiving peer has processed a "
#~ "query."
#~ msgstr ""
#~ "クエリとは、World State "
#~ "Viewの特定の部分（ブロックチェーンの直近の状態）についての情報を問い合わせすることです。 "
#~ "クエリ自体はブロックチェーンの内容を変更することはできません。クエリを受信したノードがクエリを処理し、その直後にクライアントに対して応答が返されます。"

#~ msgid "The validation for all queries includes:"
#~ msgstr "全クエリに対する検証には次のものが含まれます。"

#~ msgid ""
#~ "timestamp — shouldn't be from the "
#~ "past (24 hours prior to the peer"
#~ " time) or from the future (range "
#~ "of 5 minutes added to the peer "
#~ "time)"
#~ msgstr "タイムスタンプ - 過去（ピア・タイムの24時間前）または将来（ピア・タイムの5分先の範囲）であってはなりません。"

#~ msgid ""
#~ "signature of query creator — used "
#~ "for checking the identity of query "
#~ "creator"
#~ msgstr "クエリー生成者の署名 - クエリー作成者の身元確認のために使用されます"

#~ msgid ""
#~ "query counter — checked to be "
#~ "incremented with every subsequent query "
#~ "from query creator"
#~ msgstr "クエリカウンタ - クエリ作成者から送られる後続のクエリごとに増分されていき、その度にこの値がチェックされます"

#~ msgid ""
#~ "roles — depending on the query "
#~ "creator's role: the range of state "
#~ "available to query can relate to "
#~ "to the same account, account in "
#~ "the domain, to the whole chain, or"
#~ " not allowed at all"
#~ msgstr ""
#~ "役割 - "
#~ "クエリ作成者の役割に応じて、クエリで問い合わせできる情報の範囲は、同じアカウント、ドメイン内のアカウント、ブロックチェーン全体に関係する、あるいは全く許可されないように設定することが可能です"

#~ msgid "Get Account"
#~ msgstr "Get Account"

#~ msgid "Purpose of get account query is to get the state of an account."
#~ msgstr "GetAccountクエリの目的は、アカウントの状態を取得することです。"

#~ msgid "Request Schema"
#~ msgstr "リクエスト・スキーマ"

#~ msgid "Request Structure"
#~ msgstr "Request（内部構造）"

#~ msgid "account id to request its state"
#~ msgstr "状態を問い合わせるアカウントのID"

#~ msgid "Response Schema"
#~ msgstr "Response（図表）"

#~ msgid "Response Structure"
#~ msgstr "Response（内部構造）"

#~ msgid "account id"
#~ msgstr "アカウントID"

#~ msgid "domain where the account was created"
#~ msgstr "アカウントが作成されたドメイン"

#~ msgid "morgan"
#~ msgstr "morgan"

#~ msgid "number of signatories needed to sign the transaction to make it valid"
#~ msgstr "トランザクションを有効なものにするために必要な署名者数"

#~ msgid "0 < quorum ≤ 128"
#~ msgstr "0 < quorum ≤ 128"

#~ msgid "JSON data"
#~ msgstr "JSON data"

#~ msgid "key-value account information"
#~ msgstr "Key-Valueアカウント情報"

#~ msgid "JSON"
#~ msgstr "JSON"

#~ msgid "{ genesis: {name: alex} }"
#~ msgstr "{ genesis: {name: alex} }"

#~ msgid "Get Signatories"
#~ msgstr "Get Signatories"

#~ msgid ""
#~ "Purpose of get signatories query is "
#~ "to get signatories, which act as "
#~ "an identity of the account."
#~ msgstr "GetSignatoriesクエリの目的は、署名者を取得することです。署名者は、アカウントのIDとして機能します。"

#~ msgid "account id to request signatories"
#~ msgstr "署名者を要求するアカウントのID"

#~ msgid "Keys"
#~ msgstr "Keys"

#~ msgid "an array of public keys"
#~ msgstr "公開鍵の配列"

#~ msgid "`ed25519 <https://ed25519.cr.yp.to>`_"
#~ msgstr "`ed25519 <https://ed25519.cr.yp.to>`_"

#~ msgid "Get Transactions"
#~ msgstr "Get Transactions"

#~ msgid ""
#~ "GetTransactions is used for retrieving "
#~ "information about transactions, based on "
#~ "their hashes."
#~ msgstr "GetTransactionsは、ハッシュ情報をもとに特定の取引の関連情報を取得するために使用されます。"

#~ msgid "Transactions hashes"
#~ msgstr "トランザクションハッシュ"

#~ msgid "an array of hashes"
#~ msgstr "ハッシュの配列"

#~ msgid "array with 32 byte hashes"
#~ msgstr "32バイト長のハッシュの配列"

#~ msgid "{hash1, hash2…}"
#~ msgstr "{hash1, hash2…}"

#~ msgid "Transactions"
#~ msgstr "Transactions"

#~ msgid "an array of transactions"
#~ msgstr "トランザクションの配列"

#~ msgid "Committed transactions"
#~ msgstr "コミットされたトランザクション"

#~ msgid "{tx1, tx2…}"
#~ msgstr "{tx1, tx2…}"

#~ msgid "Get Account Transactions"
#~ msgstr "Get Account Transactions"

#~ msgid ""
#~ "In a case when a list of "
#~ "transactions per account is needed, "
#~ "`GetAccountTransactions` query can be formed."
#~ msgstr "アカウントごとのトランザクションのリストが必要な場合、 `GetAccountTransactions`クエリを作成することができます。"

#~ msgid "account id to request transactions from"
#~ msgstr "トランザクション情報をリクエストするアカウントID"

#~ msgid "an array of transactions for given account"
#~ msgstr "指定されたアカウントに関連するトランザクションの配列"

#~ msgid "Get Account Asset Transactions"
#~ msgstr "Get Account Asset Transactions"

#~ msgid ""
#~ "`GetAccountAssetTransactions` query returns all "
#~ "transactions associated with given account "
#~ "and asset."
#~ msgstr "`GetAccountAssetTransactions`クエリは、特定のアカウントと資産に関連付けられた全取引に関する情報を返します。"

#~ msgid "asset id in order to filter transactions containing this asset"
#~ msgstr "このアセットに関連するトランザクションをフィルタするために指定するアセットID"

#~ msgid "jpy#japan"
#~ msgstr "jpy#japan"

#~ msgid "an array of transactions for given account and asset"
#~ msgstr "特定のアカウントと資産に関連するトランザクションの配列"

#~ msgid "Get Account Assets"
#~ msgstr "Get Account Assets"

#~ msgid ""
#~ "To get the state of an asset "
#~ "in an account (a balance), "
#~ "`GetAccountAssets` query can be used."
#~ msgstr "アカウント内の資産の状態（残高）を取得するには、 `GetAccountAssets`クエリを使用できます。"

#~ msgid "account id to request balance from"
#~ msgstr "残高情報を請求するアカウントID"

#~ msgid "asset id to know its balance"
#~ msgstr "残高が知りたい資産のID"

#~ msgid "identifier of asset used for checking the balance"
#~ msgstr "残高確認に使用される資産の識別子"

#~ msgid "account which has this balance"
#~ msgstr "残高を持つアカウント"

#~ msgid "Balance"
#~ msgstr "Balance"

#~ msgid "balance of the asset"
#~ msgstr "資産残高"

#~ msgid "Not less than 0"
#~ msgstr "0以上"

#~ msgid "Get Asset Info"
#~ msgstr "Get Asset Info"

#~ msgid ""
#~ "In order to know precision for "
#~ "given asset, and other related info "
#~ "in the future, such as a "
#~ "description of the asset, etc. user "
#~ "can send `GetAssetInfo` query."
#~ msgstr ""
#~ "特定のアセットの精度やその他の将来における関連情報（資産の説明など）を知るために、ユーザーは "
#~ "`GetAssetInfo`クエリを送信できます。"

#~ msgid "asset id to know related information"
#~ msgstr "関連情報を知るための資産ID"

#~ msgid "jpy"
#~ msgstr "jpy"

#~ msgid "domain related to this asset"
#~ msgstr "このアセットに関連するドメイン"

#~ msgid "number of digits after comma"
#~ msgstr "コンマの後の桁数"

#~ msgid "0 < precision < 256"
#~ msgstr "0 < precision < 256"

#~ msgid "Get Roles"
#~ msgstr "Get Roles"

#~ msgid ""
#~ "To get existing roles in the "
#~ "system, a user can send `GetRoles` "
#~ "query to Iroha network."
#~ msgstr ""
#~ "システム内の存在するさまざまな役割に関する情報を得るためには、ユーザは、Irohaネットワークに "
#~ "`GetRoles`クエリを送ることができます。"

#~ msgid "Roles"
#~ msgstr "Roles"

#~ msgid "array of created roles in the network"
#~ msgstr "ネットワーク内に作成された役割の配列"

#~ msgid "set of roles in the system"
#~ msgstr "システム内で規定されている役割（ロール）"

#~ msgid "{MoneyCreator, User, Admin, …}"
#~ msgstr "{MoneyCreator, User, Admin, …}"

#~ msgid "Get Role Permissions"
#~ msgstr "Get Role Permissions"

#~ msgid ""
#~ "To get available permissions per role"
#~ " in the system, a user can send"
#~ " `GetRolePermissions` query to Iroha "
#~ "network."
#~ msgstr ""
#~ "システム内の役割ごとに利用可能になっている権限を得るために、ユーザーはIrohaネットワークに "
#~ "`GetRolePermissions`クエリを送ることができます。"

#~ msgid "Role ID"
#~ msgstr "Role ID"

#~ msgid "role to get permissions for"
#~ msgstr "権限を付与する役割"

#~ msgid "existing role in the system"
#~ msgstr "システム内で既に規定されている役割"

#~ msgid "array of permissions related to the role"
#~ msgstr "役割に関連した権限 (配列)"

#~ msgid "string of permissions related to the role"
#~ msgstr "ロールに関連するアクセス権 (文字列)"

#~ msgid "{can_add_asset_qty, …}"
#~ msgstr "{can_add_asset_qty, …}"

#~ msgid "Account"
#~ msgstr "Account (アカウント、口座)"

#~ msgid ""
#~ "An Iroha entity that is able to"
#~ " perform specified set of actions. "
#~ "Each account belongs to one of "
#~ "existing `domains <#domain>`__."
#~ msgstr ""
#~ "指定された一連のアクションを実行できるIrohaエンティティ。 各アカウントは既存の `ドメイン<#domain>`"
#~ " __のいずれかに属します。"

#~ msgid ""
#~ "An account has some number of "
#~ "`roles <#role>`__ (can be none) — "
#~ "which is a collection of permissions."
#~ " Only `grantable permissions <#grantable-"
#~ "permission>`__ are assigned to an "
#~ "account directly."
#~ msgstr ""
#~ "アカウントにはいくつかの `role <#role>` "
#~ "__（noneにすることができます）があります。これは権限の集合です。 `付与可能なアクセス権<＃grantable-"
#~ "permission>` __だけがアカウントに直接割り当てられます。"

#~ msgid "Ametsuchi"
#~ msgstr "Ametsuchi"

#~ msgid ""
#~ "Iroha storage component, which stores "
#~ "blocks and a state generated from "
#~ "blocks, called `World State View "
#~ "<#world-state-view>`__. There is no "
#~ "way for the `client <#client>`__ to "
#~ "directly interact with Ametsuchi."
#~ msgstr ""
#~ "Irohaのストレージコンポーネント。取引ブロックと、ブロックから生成された状態を保存します。これは、「World State"
#~ " View <＃world-state-view>」と呼ばれます。 "
#~ "`クライアント<#client>` __がAmetsuchiと直接対話する方法はありません。"

#~ msgid "Asset"
#~ msgstr "Asset（資産、アセット）"

#~ msgid ""
#~ "Any countable commodity or value. Each"
#~ " asset is related to one of "
#~ "existing `domains <#domain>`__. For example,"
#~ " an asset can represent any kind "
#~ "of such units - currency unit, a"
#~ " bar of gold, real estate unit, "
#~ "etc."
#~ msgstr ""
#~ "数えられる商品や価値。各アセットは、システム内の既存の `ドメイン<#domain>` __に関連づけられています。"
#~ " たとえば、資産（アセット）は通貨単位、金の延べ棒、不動産など、さまざまな種類の単位を表すことができます。"

#~ msgid "Block"
#~ msgstr "Block (ブロック)"

#~ msgid ""
#~ "Transaction data is permanently recorded "
#~ "in files called blocks. Blocks are "
#~ "organized into a linear sequence over"
#~ " time (also known as the block "
#~ "chain) [#f1]_."
#~ msgstr ""
#~ "トランザクションデータはブロックと呼ばれるファイルに永続的に記録されます。 "
#~ "ブロックは、時間の経過とともに連続的・線形的に[＃f1] _に編成されてゆきます。ブロックチェーンとも呼ばれます。"

#~ msgid ""
#~ "Blocks are signed with the cryptographic"
#~ " signatures of Iroha `peers <#peer>`__, "
#~ "voting for this block during `consensus"
#~ " <#consensus>`__. Signable content is "
#~ "called payload, so the structure of "
#~ "a block looks like this:"
#~ msgstr ""
#~ "ブロックは、Iroha `peers <#peer>` __における暗号署名で署名され、 "
#~ "`consensus <＃conssensus>` __中にいろはノード（ピア）がこのブロックに投票します。 "
#~ "署名可能なコンテンツはペイロードと呼ばれるため、ブロックの構造は次のようになります。"

#~ msgid "*Outside payload*"
#~ msgstr "*Outside payload*"

#~ msgid "hash — SHA3-512 hash of block protobuf payload"
#~ msgstr "ハッシュ— SHA3-512 hash of block protobuf payload"

#~ msgid ""
#~ "signatures — signatures of peers, which"
#~ " voted for the block during consensus"
#~ " round"
#~ msgstr "デジタル署名 - ピアが作成した署名、合意形成ラウンドでブロックへの投票に使用される"

#~ msgid "*Inside payload*"
#~ msgstr "*Inside payload*"

#~ msgid "height — a number of blocks in the chain up to the block"
#~ msgstr "高さ - ブロックチェーン内における当該ブロックまでのブロック数"

#~ msgid "timestamp — Unix time (in milliseconds) of block forming by a peer"
#~ msgstr "タイムスタンプ - ブロック生成時ピアによって刻まれるUNIX時間（ミリ秒単位）"

#~ msgid ""
#~ "body — transactions, which successfully "
#~ "passed validation and consensus step"
#~ msgstr "ブロックの本体 - 検証作業と合意形成を無事通過した取引群"

#~ msgid "transactions quantity"
#~ msgstr "取引数"

#~ msgid "previous hash of a block"
#~ msgstr "ひとつ前のブロックのハッシュ値"

#~ msgid "Block Creator"
#~ msgstr "Block Creator"

#~ msgid ""
#~ "System component that forms a block "
#~ "from a set of transactions that "
#~ "have been passed `stateless <#stateless-"
#~ "validation>`__ and `stateful <#stateful-"
#~ "validation>`__ validation for further "
#~ "propagation to `consensus <#consensus>`__."
#~ msgstr ""
#~ "`stateless <#stateless-validation>`__検証と`stateful "
#~ "<#stateful-"
#~ "validation>`__検証が完了した一連のトランザクションからなるブロックを作成するシステムコンポーネントで、作成されたブロックはその後`コンセンサス<#consensus>`"
#~ " __へ伝播されます。"

#~ msgid "Client"
#~ msgstr "Client"

#~ msgid "Any application that uses Iroha is treated as a client."
#~ msgstr "イロハを使用するアプリケーションはすべてクライアントとして扱われます。"

#~ msgid ""
#~ "A distinctive feature of Iroha is "
#~ "that all clients are using simple "
#~ "client-server abstractions when they "
#~ "interact with a peer network: they "
#~ "don't use any abstractions which are "
#~ "specific for blockchain-related systems. "
#~ "For example, in Bitcoin clients have "
#~ "to validate blocks, or in Fabric "
#~ "they need to poll several peers to"
#~ " make sure that a transaction was "
#~ "written in a block, whereas in "
#~ "Iroha a client interacts with any "
#~ "peer similarly to a single server."
#~ msgstr ""
#~ "Irohaの特徴は、クライアントがピアネットワークと通信する際に単純なクライアント/サーバー型における抽象化を使用していることです。ブロックチェーン関連システムに特有の抽象化を使用していません。"
#~ " "
#~ "たとえばBitcoinシステムでは、クライアントもブロックを検証する必要がありますし、ハイパーレジャーFabricでは複数のピアがポーリングしてトランザクションがブロックに取り込められたのか確認する必要がありますが、Irohaではクライアントは単一のサーバーとの通信時と同様にいずれかのIrohaピアと相互通信します。"

#~ msgid "Command"
#~ msgstr "コマンド"

#~ msgid ""
#~ "A command is an intention to "
#~ "change the `state <#world-state-"
#~ "view>`__. For example, in order to "
#~ "create a new `role <#role>`__ in "
#~ "Iroha you have to issue `Create "
#~ "role <../api/commands.html#create-role>`__ command."
#~ msgstr ""
#~ "コマンドは`state <＃world-state-view>` "
#~ "__を変更する意図を示します。 たとえば、Irohaで新しい `role <#role>` "
#~ "__を作成するには、 `Create role <../ api / "
#~ "commands.html＃create-role>` __コマンドを送信する必要があります。"

#~ msgid "Consensus"
#~ msgstr "コンセンサス (合意)"

#~ msgid ""
#~ "A consensus algorithm is a process "
#~ "in computer science used to achieve "
#~ "agreement on a single data value "
#~ "among distributed processes or systems. "
#~ "Consensus algorithms are designed to "
#~ "achieve reliability in a network "
#~ "involving multiple unreliable nodes. Solving"
#~ " that issue -- known as the "
#~ "consensus problem -- is important in "
#~ "distributed computing and multi-agent "
#~ "systems."
#~ msgstr ""
#~ "計算機科学の分野におけるコンセンサスアルゴリズムとは、分散プロセスやシステム内で特定の単一データ値に対する合意形成に使用されるプロセスを意味します。"
#~ " コンセンサスアルゴリズムは、複数かつ信頼できないノードを含むネットワークにおいて信頼性を達成するように設計されています。 "
#~ "「合意形成問題」として知られているこの問題を解決することは、分散コンピューティングとマルチエージェントシステムにおいて重要なことです。"

#~ msgid "*Consensus, as an algorithm*"
#~ msgstr "*アルゴリズムとしてのコンセンサス * "

#~ msgid ""
#~ "An algorithm to achieve agreement on "
#~ "a block among peers in the "
#~ "network. By having it in the "
#~ "system, reliability is increased."
#~ msgstr "ネットワーク内のピア間でブロックへの合意を達成するためのアルゴリズム。 これをシステムに組み込むことにより、信頼性が向上します。"

#~ msgid "*Consensus, as a component*"
#~ msgstr "*システム構成部分としてのコンセンサス*"

#~ msgid ""
#~ "Preserves consistent state among the "
#~ "`peers <#peer>`__ within a peer network."
#~ " Iroha uses own consensus algorithm "
#~ "called Yet Another Consensus (aka YAC)."
#~ " Distinctive features of this algorithm "
#~ "are its scalability, performance, and "
#~ "`Byzantine fault tolerance "
#~ "<https://en.wikipedia.org/wiki/Byzantine_fault_tolerance>`_. If"
#~ " there are missing blocks, they will"
#~ " be downloaded from another peer via"
#~ " `Synchronizer <#synchronizer>`__. Committed "
#~ "blocks are stored in `Ametsuchi "
#~ "<#ametsuchi>`__ block storage."
#~ msgstr ""
#~ "ピアネットワーク内の `peer <#peer>` __の間で一貫した状態 "
#~ "(state)を維持します。 IrohaはYet Another "
#~ "Consensus（YAC）という独自のコンセンサスアルゴリズムを使用しています。 "
#~ "このアルゴリズムの特徴は、スケーラビリティ（拡張性）、パフォーマンス（処理能力）、および `Byzantine "
#~ "fault tolerance "
#~ "<https://en.wikipedia.org/wiki/Byzantine_fault_tolerance>` _です。"
#~ " もし欠落しているブロックがあった場合、それらは `Synchronizer <#synchronizer>`"
#~ " __経由で別のピアからダウンロードされます。 コミットされたブロックは `Ametsuchi "
#~ "<#ametsuchi>`ブロックストレージに格納されます。"

#~ msgid "Domain"
#~ msgstr "ドメイン"

#~ msgid ""
#~ "A named abstraction for grouping "
#~ "`accounts <#account>`__ and `assets "
#~ "<#asset>`__."
#~ msgstr "`accounts <#account>` __と `assets <#asset>` __をグループ化するために、名称を与え抽象化したもの。"

#~ msgid "Ordering Gate"
#~ msgstr "Ordering Gate (検証作業の要求経路)"

#~ msgid ""
#~ "Internal Iroha component that passes "
#~ "`transactions <#transaction>`__ from `Peer "
#~ "Communication Service <#peer-communication-"
#~ "service>`__ to `Ordering Service "
#~ "<#ordering-service>`__. Ordering Gate eventually"
#~ " recieves `proposals <#proposal>`__ from "
#~ "Ordering Service and sends them to "
#~ "`Simulator <#simulator>`__ for `stateful "
#~ "validation <#stateful-validation>`__."
#~ msgstr ""
#~ "`Peer Communication Service <＃peer-"
#~ "communication-service>` __から `Ordering Service"
#~ " <＃ordering-service>`へ`トランザクション<#transaction>` "
#~ "__を渡すIrohaの内部コンポーネント。 Ordering Gateは、最終的にOrdering "
#~ "Serviceから `proposals <#proposal>` __を受け取り、それらに対して``"
#~ " Stateful validation <＃stateful-validation> "
#~ "`__を行うために` Simulator <#simulator> `__に送ります。"

#~ msgid "Ordering Service"
#~ msgstr "Ordering Service"

#~ msgid ""
#~ "Internal Iroha component that combines "
#~ "several `transactions <#transaction>`__ that "
#~ "have been passed `stateless validation "
#~ "<#stateless-validation>`__ into a `proposal "
#~ "<#proposal>`__. Proposal creation could be "
#~ "triggered by one of the following "
#~ "events:"
#~ msgstr ""
#~ "`stateless validation <＃stateless-validation>` "
#~ "__を通過したものとして渡された`トランザクション<#transaction>` __ を`proposal "
#~ "<#proposal>` __として組み合わせる作業を担うIrohaの内部コンポーネントです。 "
#~ "プロポーザルの作成は、次のいずれかのイベントによって引き起こされます。"

#~ msgid "Time limit dedicated to transactions collection has expired."
#~ msgstr "取引収集のための時間が制限を超えた場合。"

#~ msgid ""
#~ "Ordering service has received the "
#~ "maximum amount of transactions allowed "
#~ "for a single proposal."
#~ msgstr "オーダーリングサービスが、1つのプロポーザルに許可された最大取引量を受け取った場合。"

#~ msgid ""
#~ "Both parameters (timeout and maximum "
#~ "size of proposal) are configurable "
#~ "(check `environment-specific parameters "
#~ "<../guides/configuration.html#environment-specific-"
#~ "parameters>`_ page)."
#~ msgstr ""
#~ "両方のパラメータ（タイムアウトとプロポーザルに付与する最大サイズ）は設定可能です（ "
#~ "`環境パラメータ<../guides/configuration.html＃環境固有パラメータ>` "
#~ "_のページをご確認ください）。"

#~ msgid ""
#~ "A common precondition for both triggers"
#~ " is that at least one transaction "
#~ "should reach ordering service. Otherwise, "
#~ "no proposal will be formed."
#~ msgstr ""
#~ "両方のトリガーに共通する前提条件は、少なくとも1つのトランザクションがオーダリングサービスに到達しているということです。 "
#~ "それ以外の場合、プロポーザルは作成されません。"

#~ msgid "Peer"
#~ msgstr "ピア（ネットワークノード）"

#~ msgid ""
#~ "A node that is a part of "
#~ "Iroha network. It participates in "
#~ "`consensus <#consensus>`_ process."
#~ msgstr "Irohaネットワークを構成するノード。 ピアは `コンセンサス<#consensus>` _形成プロセスに参加しています。"

#~ msgid "Peer Communication Service"
#~ msgstr "ピア間通信サービス (PCS)"

#~ msgid ""
#~ "Internal component of Iroha - an "
#~ "intermediary that transmits `transaction "
#~ "<#transaction>`__ from `Torii <#torii>`__ to"
#~ " `Ordering Gate <#ordering-gate>`__. The"
#~ " main goal of PCS is to hide"
#~ " the complexity of interaction with "
#~ "consensus implementation."
#~ msgstr ""
#~ "イロハの内部構成要素の１つ - 鳥居<#torii> __から送られてくる "
#~ "`transaction <#transaction>` __を`Ordering Gate "
#~ "<＃ordering-gate>`へ送信します。 "
#~ "PCSの主な目的は、コンセンサスの実装とそれ以外における相互通信の複雑さを隠すことです。"

#~ msgid "Permission"
#~ msgstr "権限 (Permission)"

#~ msgid ""
#~ "A named rule that gives the "
#~ "privilege to perform a command. "
#~ "Permission **cannot** be granted to an"
#~ " `account <#account>`__ directly, instead, "
#~ "an account has roles, which are "
#~ "the collection of permissions."
#~ msgstr ""
#~ "コマンドの実行権限を与えるルールで、それぞれに名称が付けられています。 Permission **は "
#~ "`account <#account>` "
#~ "__に直接付与することはできません。代わりに、アカウントには権限の集合体であるロール、役割が与えられています。"

#~ msgid "Grantable Permission"
#~ msgstr "付与可能な権限"

#~ msgid ""
#~ "Only grantable permission is given to"
#~ " an `account <#account>`__ directly. An "
#~ "account that holds grantable permission "
#~ "is allowed to perform some particular"
#~ " action on behalf of another account."
#~ " For example, if the account "
#~ "a@domain1 gives the account b@domain2 a"
#~ " permission that it can transfer "
#~ "assets — then  b@domain2 can transfer"
#~ " assets of a@domain1 to anyone."
#~ msgstr ""
#~ "与えられた権限だけが`account <#account>` __に与えられます。 "
#~ "付与することのできる権限を持つアカウントは、別のアカウントに代わって特定のアクションを実行できます。 "
#~ "たとえばa@domain1というアカウントがb@domain2というアカウントに対して、アセットを転送できるようにする権限をb@domain2に与えると、b@domain2はa@domain1のアセットを誰にでも転送することができます。"

#~ msgid "Proposal"
#~ msgstr "プロポーザル（新規ブロックの提案）"

#~ msgid ""
#~ "A set of `transactions <#transaction>`__ "
#~ "that have passed only `stateless "
#~ "validation <#stateless-validation>`__."
#~ msgstr ""
#~ "`stateless validation <＃stateless-validation>` "
#~ "__だけを通過した一連の `transactions <#transaction>` __"

#~ msgid "Verified Proposal"
#~ msgstr "検証済みのプロポーザル"

#~ msgid ""
#~ "A set of transactions that have "
#~ "been passed `stateless <#stateless-"
#~ "validation>`__ and `stateful <#stateful-"
#~ "validation>`__ validation, but were not "
#~ "committed yet."
#~ msgstr ""
#~ " `stateless <#stateless-validation>`__と`stateful "
#~ "<#stateful-validation>`__を通過したが、まだコミットされていない取引セット。"

#~ msgid "Role"
#~ msgstr "役割 (Role)"

#~ msgid "A named abstraction that holds a set of `permissions <#permission>`__."
#~ msgstr "`permissions <#permission>` __(複数可) がグループ化され、役割として抽象化されたもの。"

#~ msgid "Simulator"
#~ msgstr "シミュレーター (Simulator)"

#~ msgid "See `Verified Proposal Creator <#verified-proposal-creator>`__."
#~ msgstr "`Verified Proposal Creator <#verified-proposal-creator>`__を参照してください。"

#~ msgid ""
#~ "A request to Iroha that does "
#~ "**not** change the `state <#world-"
#~ "state-view>`__. By performing a query, "
#~ "a client can get request data from"
#~ " the state, for example a balance "
#~ "of his account, a history of "
#~ "transactions, etc."
#~ msgstr ""
#~ "イロハへのリクエストは、 `state <#world-state-"
#~ "view>`__を変更しません。 "
#~ "情報の照会を実行することにより、クライアントは状態に関する照会したい情報（例えば、彼の口座の残高、取引履歴など）を得ることができます。"

#~ msgid "Synchronizer"
#~ msgstr "シンクロナイザー"

#~ msgid ""
#~ "Is a part of `consensus <#consensus>`__."
#~ " Adds missing blocks to `peers' "
#~ "<#peer>`__ chains (downloads them from "
#~ "other peers)."
#~ msgstr ""
#~ "`consensus <#consensus>`__の一部です。 不足しているブロックを `peers'"
#~ " <#peer>`__に追加します。（他のピアからダウンロードします）"

#~ msgid "Torii"
#~ msgstr "Torii（鳥居）"

#~ msgid ""
#~ "⛩. Entry point for `clients "
#~ "<#client>`__. Uses gRPC as a transport."
#~ " In order to interact with Iroha "
#~ "anyone can use gRPC endpoints, described"
#~ " in `Commands <../api/commands.html>`__ and "
#~ "`Queries <../api/queries.html>`__ sections, or "
#~ "use `client libraries <../guides/libraries.html>`__."
#~ msgstr ""
#~ "⛩ `clients <#client>` __のエントリポイント。 "
#~ "gRPCをトランスポート層で使用します。 Irohaと通信するには、 `Commands <../"
#~ " api / commands.html>` __と `Queries "
#~ "<../ api / queries.html>` "
#~ "__の項で記述されているgRPCエンドポイントを使用するか、クライアントライブラリ <../ guides "
#~ "/ libraries.html> `__を使用してください。"

#~ msgid ""
#~ "An ordered set of `commands "
#~ "<#command>`__, which is applied to the"
#~ " ledger atomically. Any nonvalid command"
#~ " within a transaction leads to "
#~ "rejection of the whole transaction "
#~ "during the validation process."
#~ msgstr ""
#~ "台帳に原子的（atomically）に適用される順序付けられた `commands <#command>` "
#~ "__です。 トランザクション内に無効なコマンドが含まれていると、検証処理中にトランザクション全体が拒否されます。"

#~ msgid "Validator"
#~ msgstr "検証作業（Validator）"

#~ msgid "There are two kinds of validation - stateless and stateful."
#~ msgstr "検証にはステートレスとステートフルの2種類があります。"

#~ msgid "Stateless Validation"
#~ msgstr "ステートレス検証 (Sateless Validation)"

#~ msgid ""
#~ "Performed in `Torii <#torii>`__. Checks "
#~ "if an object is well-formed, "
#~ "including the signatures."
#~ msgstr "`Torii <#torii>` __で実行されます。 電子署名を含むオブジェクトが正しく構成されているか否かチェックします。"

#~ msgid "Stateful Validation"
#~ msgstr "ステートフル検証 (Sateful Validation)"

#~ msgid ""
#~ "Performed in `Verified Proposal Creator "
#~ "<#verified-proposal-creator>`__. Validates "
#~ "against `World State View <#world-"
#~ "state-view>`__."
#~ msgstr ""
#~ "`Verified Proposal Creator<#verified-proposal-"
#~ "creator>` __で実行されます。 `World State View "
#~ "<＃world-state-view>` __に対して検証が行われます。"

#~ msgid "Verified Proposal Creator"
#~ msgstr "Verified Proposal Creator"

#~ msgid ""
#~ "Internal Iroha component that performs "
#~ "`stateful validation <#stateful-validation>`_ "
#~ "of `transactions <#transaction>`__ contained "
#~ "in received `proposal <#proposal>`__. On "
#~ "the basis of transactions that have "
#~ "been passed stateful validation **verified "
#~ "proposal** will be created and passed"
#~ " to `Block Creator <#block-creator>`__. "
#~ "All the transactions that have not "
#~ "passed stateful validation will be "
#~ "dropped and not included in a "
#~ "verified proposal."
#~ msgstr ""
#~ "受信された`proposal <#proposal>` "
#~ "__に格納されている`トランザクション<#transaction>` __に対してステートフル検証<#stateful-"
#~ "validation> `_を実行するIrohaの内部コンポーネントです。 "
#~ "ステートフル検証を通過したトランザクションをもとに、検証済みプロポーザル（ブロックの提案）**が作成され、 `Block "
#~ "Creator <＃block-creator>` __に渡されます。 "
#~ "ステートフル検証をパスしなかったトランザクションはすべて破棄され、それらはプロポーザルには含まれません。"

#~ msgid "World State View"
#~ msgstr "World State View"

#~ msgid ""
#~ "WSV reflects the current state of "
#~ "the system, can be considered as a"
#~ " snapshot. For example, WSV holds "
#~ "information about an amount of `assets"
#~ " <#asset>`__ that an `account <#account>`__"
#~ " has at the moment but does not"
#~ " contain any info history of "
#~ "`transaction <#transaction>`__ flow."
#~ msgstr ""
#~ "WSVは現在のシステム状態を反映したスナップショットと捉えることができます。 たとえば、WSVには現在account "
#~ "<#account> __が持っている`assets <#asset>` "
#~ "__の量に関する情報が保持されていますが、`transaction <#transaction>` __ "
#~ "フローに関する履歴情報は記録されていません。"

#~ msgid "https://en.bitcoin.it/wiki/Block"
#~ msgstr "https://en.bitcoin.it/wiki/Block"

#~ msgid ""
#~ "Docs are constantly updated and this "
#~ "section is going to be improved. "
#~ "Check glossary page while contents are"
#~ " elaborated."
#~ msgstr "ドキュメントは常に更新され、このセクションも今後改善される予定です。 内容が編集されている間は用語集ページを確認してください。"

#~ msgid "Client Libraries"
#~ msgstr "クライアント・ライブラリ"

#~ msgid ""
#~ "Contents are missing for now. Please "
#~ "check deploy/ansible folder and README.md "
#~ "file in it."
#~ msgstr "現在コンテンツが一部欠落しています。 deploy/ansibleフォルダとその中のREADME.mdファイルをご確認ください。"

#~ msgid "2018-03-30"
#~ msgstr "2018-03-30"

#~ msgid "Simple deployment and maintenance"
#~ msgstr "簡単な導入とメインテナンス"

#~ msgid "Variety of libraries for developers"
#~ msgstr "開発者向けのさまざまなライブラリ"

#~ msgid "Role-based access control"
#~ msgstr "役割に基づいたアクセス制限"

#~ msgid "Modular design, driven by command–query separation principle"
#~ msgstr "コマンドとクエリの分離によって行われるモジュール型設計"

#~ msgid "Assets and identity management"
#~ msgstr "資産とアイデンティティ管理"

#~ msgid "In our quality model, we focus on and continuously improve:"
#~ msgstr "品質モデルで私たちは以下の点に重点を置いています："

#~ msgid "Reliability (fault tolerance, recoverability)"
#~ msgstr "信頼性（耐障害性、回復性）"

#~ msgid ""
#~ "Performance Efficiency (in particular time-"
#~ "behavior and resource utilization)"
#~ msgstr "パフォーマンス効率（とりわけ時間挙動とリソースの使用効率）"

#~ msgid ""
#~ "Usability (learnability, user error "
#~ "protection, appropriateness recognisability)"
#~ msgstr "ユーザビリティ（学習可能性、ユーザー・エラー保護、妥当性の評価可能性）"

#~ msgid "Where can Iroha be used?"
#~ msgstr "Irohaはどこで使えますか？"

#~ msgid ""
#~ "Hyperledger Iroha is a general purpose"
#~ " permissioned blockchain system that can"
#~ " be used to manage digital assets,"
#~ " identity, and serialized data. This "
#~ "can be useful for applications such "
#~ "as interbank settlement, central bank "
#~ "digital currencies, payment systems, national"
#~ " IDs, and logistics, among others."
#~ msgstr ""
#~ "Hyperledger "
#~ "Irohaは、デジタルアセット、ID、およびシリアル化されたデータを管理する際に汎用的に使用できるパーミッション型ブロックチェーンシステムです。"
#~ " 銀行間決済、中央銀行のデジタル通貨、決済システム、国内ID、および物流分野などのアプリケーションとして役立ちます。"

#~ msgid ""
#~ "For a detailed description please check"
#~ " our `Use Case Scenarios section "
#~ "<http://iroha.readthedocs.io/en/latest/use_cases/>`_."
#~ msgstr ""
#~ "詳細は、ユースケースシナリオ<http://iroha.readthedocs.io/en/latest/use_cases/> "
#~ "`_を参照してください。"

#~ msgid ""
#~ "Bitcoin and Ethereum are designed to "
#~ "be permissionless ledgers where anyone "
#~ "can join and access all the data."
#~ " They also have native cryptocurrencies "
#~ "that are required to interact with "
#~ "the systems."
#~ msgstr ""
#~ "BitcoinとEthereumは、誰もが参加しすべてのデータにアクセスできる、パーミッションレス型レジャーになるように設計されています。"
#~ " また、システムと相互作用するために独自の暗号化通貨もあります。"

#~ msgid ""
#~ "In Iroha, there is no native "
#~ "cryptocurrency. Instead, to meet the "
#~ "needs of enterprises, system interaction "
#~ "is permissioned, meaning that only "
#~ "people with requisite access can "
#~ "interact with the system. Additionally, "
#~ "queries are also permissioned, such that"
#~ " access to all the data can be"
#~ " controlled."
#~ msgstr ""
#~ "イロハには固有の暗号通貨はありません。 "
#~ "その代わりに、企業のニーズを満たすためシステム内での通信が許可に基づいて行われうるようになっています。つまり、アクセス権を持つユーザーだけがシステムとやり取りできます。"
#~ " さらに、すべてのデータへのアクセスを制御できるように、クエリ（情報照会）も許可に基づい行われるようにされています。"

#~ msgid ""
#~ "One major difference from Ethereum, in"
#~ " particular, is that Hyperledger Iroha "
#~ "allows users to perform common "
#~ "functions, such as creating and "
#~ "transferring digital assets, by using "
#~ "prebuilt commands that are in the "
#~ "system. This negates the need to "
#~ "write cumbersome and hard to test "
#~ "smart contracts, enabling developers to "
#~ "complete simple tasks faster and with"
#~ " less risk."
#~ msgstr ""
#~ "特にEthereumとの主な違いの1つは、Hyperledger "
#~ "Irohaではシステムに組み込まれたコマンドを用いて、デジタルアセットの作成や転送といった共通機能を実行できることです。 "
#~ "これにより、スマートコントラクトの記述やテストといった面倒で難しい作業の必要がなくなり、開発者は単純なタスクをより迅速かつ低リスクで行うことができます。"

#~ msgid ""
#~ "Iroha has a novel, Byzantine fault "
#~ "tolerant consensus algorithm (called YAC "
#~ "[#f1]_) that is high-performance and "
#~ "allows for finality of transactions with"
#~ " low latency. Other frameworks either "
#~ "focus more on probabilistic consensus "
#~ "algorithms, such as Nakamoto Consensus, "
#~ "or sacrifice Byzantine fault tolerance."
#~ msgstr ""
#~ "イロハには、高性能で待ち時間が少なくかつ取引ファイナリティを可能にする、ビザンチンフォールトトレラント・コンセンサスアルゴリズム（YAC"
#~ " [＃f1] _）が採用されています。 "
#~ "その他のフレームワークは、ナカモト合意のようなの確率的合意形成に重点を置くものや、ビザンチンフォールトトレランスの特性が犠牲にされていたりします。"

#~ msgid ""
#~ "Also, Iroha's built-in commands are "
#~ "a major benefit compared to other "
#~ "platforms, since it is very simple "
#~ "to do common tasks such as create"
#~ " digital assets, register accounts, and "
#~ "transfer assets between accounts. Moreover,"
#~ " it narrows the attack vector, "
#~ "improving overall security of the "
#~ "system, as there are less things "
#~ "to fail."
#~ msgstr ""
#~ "またIrohaの組み込みコマンドでは、デジタル資産の作成、アカウント登録、アカウント間の資産移転といった共通タスクを実行するのが非常に簡単であるため、他のプラットフォームと比較しても大きな利点です。"
#~ " さらに、攻撃のベクトルを狭め、システムの全体的なセキュリティ水準を向上させます。これはシステム機能が停止しうる箇所が少ないためです。"

#~ msgid ""
#~ "Finally, Iroha is the only ledger "
#~ "that has a robust permission system, "
#~ "allowing permissions to be set for "
#~ "all commands, queries, and joining of"
#~ " the network."
#~ msgstr "最後に、Irohaは強力な権限システムを持つ唯一の分散型台帳であり、すべてのコマンド、クエリ、およびネットワークへの参加に対する権限を設定できます。"

#~ msgid "Yet Another Consensus"
#~ msgstr "Yet Another Consensus"

#~ msgid ""
#~ "As per the latest review date of"
#~ " these docs, according to `Huawei "
#~ "Caliper <https://github.com/hyperledger/caliper>`_ testing"
#~ " tool, Iroha is capable of processing"
#~ " 45 transactions per second. Theoretically,"
#~ " this is not even close to the"
#~ " limit of the system, and we "
#~ "will continue constant optimizations in "
#~ "order to improve stability and "
#~ "performance."
#~ msgstr ""
#~ "これらのドキュメントの最新レビュー日付によると、Huawei Caliper "
#~ "<https://github.com/hyperledger/caliper> "
#~ "_テストツールによると、Irohaは1秒あたり45トランザクションを処理することができますが、この値は理論的なシステムの限界には到底至ってはいません。安定性とパフォーマンスの向上にむけて、これからもシステムの最適化に継続して取り組んでまいります。"

#~ msgid ""
#~ "In order to bring the power of "
#~ "blockchain into your application, you "
#~ "should think first of how it is"
#~ " going to interface with Iroha peers."
#~ " A good start is to check `Core"
#~ " Concepts section "
#~ "<http://iroha.readthedocs.io/en/latest/core_concepts/>`_, "
#~ "explaining what exactly is a transaction"
#~ " and query, and how users of "
#~ "your application are supposed to "
#~ "interact with it."
#~ msgstr ""
#~ "みなさまのアプリケーションにブロックチェーンの力をもたらすためには、はじめにそのアプリケーションがIrohaピアとどのように連携するのかを考えなければなりません。そのためにまずはじめにトランザクションとクエリが正確に何であるかや、アプリケーションのユーザーがIrohaとどのようにやりとりするのかを説明している項`重要な概念<http://iroha.readthedocs.io/en/latest/core_concepts/>`"
#~ " _がございますので、そちらを参照してみてください。"

#~ msgid ""
#~ "We also have several client libraries"
#~ " which provide tools for developers "
#~ "to form building blocks, such as "
#~ "signatures, commands, send messages to "
#~ "Iroha peers and check the status."
#~ msgstr "また、システム開発者が電子署名やコマンドといったIrohaの構成要素を作成するためのツールを提供しているクライアントライブラリもいくつか用意されています。"

#~ msgid "Android Library"
#~ msgstr "Androidライブラリ"

#~ msgid ""
#~ "The library, in essence, is a set"
#~ " of Java interfaces and binary "
#~ "libraries compiled for different "
#~ "architectures. Supported architectures are "
#~ "*arm, x86, x86_64*."
#~ msgstr ""
#~ "本質的には、ライブラリとはそれぞれのアーキテクチャ用にコンパイルされたJavaインターフェイスとバイナリライブラリ群です。 "
#~ "サポートされているアーキテクチャは*arm、x86、x86_64*です。"

#~ msgid "There are two ways to get Iroha library for Android:"
#~ msgstr "Android用のIrohaライブラリを入手するには2つの方法があります："

#~ msgid ""
#~ "Grab via Gradle (see details in "
#~ "the section `Importing the Library from"
#~ " jcenter`_)"
#~ msgstr "Gradle経由で入手してください（詳細は``jcenter`からライブラリをインポートする ``で確認してください）"

#~ msgid "Compile the library on your own."
#~ msgstr "ライブラリをコンパイルしてください。"

#~ msgid "Both options are described in the following sections."
#~ msgstr "両方のオプションについては、次項で説明します。"

#~ msgid "Manual Build"
#~ msgstr "手動での構築方法"

#~ msgid "The guide was tested on systems running Ubuntu 16.04 and macOS."
#~ msgstr "このガイドは、Ubuntu 16.04とmacOS上で実行しているシステムでテスト済みです。"

#~ msgid "Android NDK"
#~ msgstr "Android NDK"

#~ msgid ""
#~ "Please `download "
#~ "<https://developer.android.com/ndk/downloads/index.html>`__ and"
#~ " unpack NDK to any suitable folder."
#~ msgstr ""
#~ "`<https://developer.android.com/ndk/downloads/index.html>` "
#~ "__をダウンロードし、適切なフォルダにNDKを展開してください。"

#~ msgid "Automake, Bison, Cmake"
#~ msgstr "Automake, Bison, Cmake"

#~ msgid ""
#~ "Please refer to the page `Installing "
#~ "Dependencies <dependencies.html>`__ to get "
#~ "installation recipes for the tools."
#~ msgstr "ツールのインストール方法は、 `ディペンデンシーをインストールする<dependencies.html>` __を参照してください。"

#~ msgid "Building the Library"
#~ msgstr "ライブラリをビルドする"

#~ msgid ""
#~ "All you need now is to download"
#~ " `build script "
#~ "<https://github.com/hyperledger/iroha/blob/develop/shared_model/packages/android"
#~ "/android-build.sh>`__ ``android-build.sh`` to "
#~ "any empty folder and launch it "
#~ "there."
#~ msgstr ""
#~ "`build script "
#~ "<https://github.com/hyperledger/iroha/blob/develop/shared_model/packages/android"
#~ "/android-build.sh>` __ `` android-"
#~ "build.sh``をダウンロードするだけで完了します。 空のフォルダに移動して起動します。"

#~ msgid "Launch parameters are listed in the table below."
#~ msgstr "起動時のパラメータは以下の表の通りです。"

#~ msgid "Position"
#~ msgstr "Position"

#~ msgid "Required"
#~ msgstr "必須"

#~ msgid "Parameter Name"
#~ msgstr "パラメーター名"

#~ msgid "Possible Values"
#~ msgstr "可能な値"

#~ msgid "1"
#~ msgstr "1"

#~ msgid "Yes"
#~ msgstr "はい"

#~ msgid "**Platform Name**"
#~ msgstr "**プラットフォーム名**"

#~ msgid "Name of the target platform for binary part of the library."
#~ msgstr "ライブラリのバイナリ部分のターゲットプラットフォーム名。"

#~ msgid "``arm64-v8a``, ``armeabi-v7a``, ``armeabi``, ``x86``, ``x86_64``"
#~ msgstr "``arm64-v8a``, ``armeabi-v7a``, ``armeabi``, ``x86``, ``x86_64``"

#~ msgid "**Android API Level**"
#~ msgstr "**Android API Level**"

#~ msgid ""
#~ "API level supported by your NDK. "
#~ "See the link under the table for"
#~ " details."
#~ msgstr "NDKでサポートされているAPIレベル。 詳細は表の下のリンクを参照してください。"

#~ msgid "``27`` for android-ndk-r16b"
#~ msgstr "android-ndk-r16bでは``27``"

#~ msgid "3"
#~ msgstr "3"

#~ msgid "**Android NDK Path**"
#~ msgstr "**Android NDK Path**"

#~ msgid ""
#~ "Full path to unpacked NDK. Please "
#~ "ensure that path does not contain "
#~ "spaces."
#~ msgstr "展開済みNDKへのフルパス名。 パスにスペースがないことを確認してください。"

#~ msgid "``/home/user/lib/android-ndk-r16b``"
#~ msgstr "``/home/user/lib/android-ndk-r16b``"

#~ msgid "4"
#~ msgstr "4"

#~ msgid "**Java Package Name**"
#~ msgstr "**Java Package Name**"

#~ msgid ""
#~ "Package name that will be used for"
#~ " Java interfaces generation. Note that "
#~ "the binary also depends on chosen "
#~ "package name."
#~ msgstr "Javaインタフェースの生成に使用されるパッケージ名。 バイナリも選択したパッケージ名に依存することに注意してください。"

#~ msgid "``jp.co.soramitsu.iroha.android``"
#~ msgstr "``jp.co.soramitsu.iroha.android``"

#~ msgid "No"
#~ msgstr "いいえ"

#~ msgid "**Build Type**"
#~ msgstr "**Build Type**"

#~ msgid ""
#~ "Defines build mode of binary part "
#~ "of the library. ``Release`` is the "
#~ "default option."
#~ msgstr "ライブラリのバイナリ部分のビルドタイプを定義します。 `` Release``がデフォルトオプションです。"

#~ msgid "``Debug`` or ``Release``"
#~ msgstr "``Debug``又は``Release``"

#~ msgid ""
#~ "`Android API levels "
#~ "<https://developer.android.com/guide/topics/manifest/uses-"
#~ "sdk-element.html#ApiLevels>`__"
#~ msgstr ""
#~ "`Android API levels "
#~ "<https://developer.android.com/guide/topics/manifest/uses-"
#~ "sdk-element.html#ApiLevels>`__"

#~ msgid ""
#~ "Please use the same root part of"
#~ " Java package name for library build"
#~ " as you use for your Android "
#~ "project. For example, your project is"
#~ " located in a package called "
#~ "``com.mycompany.androidapp``, so please consider "
#~ "to build the library in a package,"
#~ " which name starts with "
#~ "``com.mycompany.androidapp`` (e.g. "
#~ "``com.mycompany.androidapp.iroha``)."
#~ msgstr ""
#~ "あなたがAndroidプロジェクトに使用する時のように、ライブラリ作成時にはJavaパッケージ名の同じルート部分を使用してください。 "
#~ "例えば、あなたのプロジェクトは `` "
#~ "com.mycompany.androidapp``というパッケージに入っていますので、 できるだけ`` "
#~ "com.mycompany.androidapp``で始まるライブラリをパッケージに作成するようにしてください（ 例 "
#~ "``com .mycompany.androidapp.iroha``）。"

#~ msgid "A couple of launch commands examples:"
#~ msgstr "起動コマンドの例："

#~ msgid ""
#~ "Build artefacts will be collected in "
#~ "``lib`` directory near the script "
#~ "``android-build.sh``. There will be two "
#~ "files - an archive ``bindings.zip`` and"
#~ " ``libirohajava.so``."
#~ msgstr ""
#~ "ビルドの際に作成される成果物（Build artifacts）`` android-"
#~ "build.sh``スクリプトの近くの ``lib``ディレクトリに集められていきます。`` "
#~ "bindings.zip``と`` libirohajava.so``の2つのアーカイブファイルが格納されます。"

#~ msgid "How to Use/Import"
#~ msgstr "使用・インポート方法"

#~ msgid "Importing the Library from jcenter"
#~ msgstr "jcenterからライブラリをインポートする"

#~ msgid ""
#~ "The easiest way to use Irohalib "
#~ "for Android is to import the "
#~ "library dependency from `jcenter "
#~ "<https://bintray.com/bulatmukhutdinov/maven/iroha-android-"
#~ "bindings>`__."
#~ msgstr ""
#~ "Android用Irohalibを使用する最も簡単な方法は、 `jcenter "
#~ "<https://bintray.com/bulatmukhutdinov/maven/iroha-android-"
#~ "bindings>` __からライブラリディペンデンシーをインポートすることです。"

#~ msgid "All you need to do is a simple set of four steps:"
#~ msgstr "4つのステップで簡単に行えます。"

#~ msgid "Add to your ``build.gradle`` file the following line:"
#~ msgstr "``build.gradle``ファイルに以下に示す行を追加してください。"

#~ msgid ""
#~ "Copy the latest version of ``*.proto``"
#~ " files from ``develop`` branch of "
#~ "Iroha `repository "
#~ "<https://github.com/hyperledger/iroha/tree/develop/schema>`__ "
#~ "into ``app/src/main/proto/`` folder inside "
#~ "your project in Android Studio."
#~ msgstr ""
#~ "Iroha`repository "
#~ "<https://github.com/hyperledger/iroha/tree/develop/schema>`__ の"
#~ " ``develop``ブランチにある最新版の``*.proto``ファイルを、\n"
#~ "Android Studioのプロジェクト内の`` app/src/main/proto/ ``フォルダへコピーしてください。"

#~ msgid "The resulting directory structure should look like as follows:"
#~ msgstr "コピー後のディレクトリ構造は次のようになっているはずです。"

#~ msgid ""
#~ "Create additional directories "
#~ "``app/src/main/proto/google/protobuf/`` and place "
#~ "there a file called ``empty.proto`` with"
#~ " the following contents:"
#~ msgstr ""
#~ "ディレクトリ``app/src/main/proto/google/protobuf/``を追加作成し、以下に示す内容のファイル``empty.proto``"
#~ " をそこに格納してください。"

#~ msgid ""
#~ "Add ``protobuf`` and ``grpc`` dependecies "
#~ "and protobuf configuration block into "
#~ "your ``build.gradle`` file."
#~ msgstr ""
#~ "``build.gradle``ファイルに "
#~ "``protobuf``、``grpc``ディペンデンシー、protobuf設定ブロックを追加してください。"

#~ msgid "How to Use Manually Built Library"
#~ msgstr "手動で作成されたライブラリの使用方法"

#~ msgid ""
#~ "Create directory structure inside your "
#~ "Android project according to the package"
#~ " name of build library. Put there "
#~ "all the ``.java`` files from "
#~ "``bindings.zip`` archive. For example, the "
#~ "path could be "
#~ "``app/src/main/java/com/mycompany/iroha`` if you "
#~ "built the library with ``com.mycompany.iroha``"
#~ " package name."
#~ msgstr ""
#~ "ビルドされたライブラリのパッケージ名に従って、Androidプロジェクト内にディレクトリ構造を作成してください。そして、`` "
#~ "bindings.zip``アーカイブにあるすべての`` .java``ファイルをそこへ移動してください。 "
#~ "たとえば、`` com.mycompany.iroha``というパッケージ名でライブラリを作成した場合のパスは "
#~ "``app/src/main/java/com/mycompany/iroha``になります。"

#~ msgid ""
#~ "Create directory ``app/src/main/jniLibs/<platform>`` "
#~ "where ``<platform>`` is the name of "
#~ "target platform (e.g. ``arm64-v8a``). Put "
#~ "there ``libirohajava.so``. Repeat this step"
#~ " for all required platforms (in this"
#~ " case you need to build the "
#~ "library for each platform)."
#~ msgstr ""
#~ " ``app/src/main/jniLibs/<platform>``というディレクトリを作成します。ここの`` "
#~ "<platform>``にはターゲットプラットフォーム名を指定します（例えば `` "
#~ "arm64-v8a``）。その中に``libirohajava.so``を入れてください。 "
#~ "すべてのプラットフォームでこの手順を繰り返します（その場合はプラットフォームごとにライブラリを作成する必要があります）。"

#~ msgid ""
#~ "Repeat steps 2-4 from the previous "
#~ "section `Importing the Library from "
#~ "jcenter`_."
#~ msgstr "前述の `jcenterからライブラリをインポートする` _の2〜4の手順を繰り返します。"

#~ msgid ""
#~ "Explore ``bindings`` branch of `iroha-"
#~ "android <https://github.com/hyperledger/iroha-"
#~ "android/tree/bindings>`__ repository to get "
#~ "source code and view sample application."
#~ msgstr ""
#~ "iroha-android <https://github.com/hyperledger/iroha-"
#~ "android/tree/bindings> "
#~ "`__リポジトリの``bindings``ブランチを中身を確認して、ソースコードを入手し、サンプルアプリケーションを見てください。"

#~ msgid "Java Library"
#~ msgstr "Javaライブラリ"

#~ msgid "Java 6"
#~ msgstr "Java 6"

#~ msgid "Gradle"
#~ msgstr "Gradle"

#~ msgid "Build Process"
#~ msgstr "ビルドプロセス"

#~ msgid "Clone Iroha repository"
#~ msgstr "Iroha repositoryをクローンする"

#~ msgid ""
#~ "For the latest version checkout a "
#~ "``develop`` branch by adding ``-b "
#~ "develop`` parameter."
#~ msgstr "最新バージョンは、パラメーターに``-b develop``を追加して ``develop``ブランチを確認してください。"

#~ msgid ""
#~ "Now we need to build our Java "
#~ "native library. Run "
#~ "``example/java/build_library.sh``, which will take"
#~ " care of it."
#~ msgstr "それでは次に、Javaのネイティブライブラリを作成する必要があります。``example/java/build_library.sh``スクリプトを実行してください。自動的に行ってくれます。"

#~ msgid ""
#~ "``build_library.sh`` script creates a ``dist``"
#~ " folder with files, needed in :ref"
#~ ":`java-how-to-use` section."
#~ msgstr ""
#~ "``build_library.sh``スクリプトはセクション:ref:`java-how-to-"
#~ "use` section.で必要になったファイルとともに``dist``フォルダを作成します。"

#~ msgid "How to Use"
#~ msgstr "使用方法"

#~ msgid "There are two ways of adding the Java library to your project:"
#~ msgstr "Javaライブラリをプロジェクトに追加するには、2つの方法があります。"

#~ msgid "Import Java bindings through Maven Central"
#~ msgstr "Maven Centralを使用してJavaバインディングをインポートする"

#~ msgid "Compile Java bindings manually"
#~ msgstr "手動でJavaバインディングをコンパイルする"

#~ msgid "Import Java Bindings from Maven Central"
#~ msgstr "Maven Centralを使用してJavaバインディングをインポートする"

#~ msgid ""
#~ "First of all, you need to copy "
#~ "``example/java/dist/libirohajava.jnilib`` to the "
#~ "root folder of your project."
#~ msgstr ""
#~ "まず "
#~ "``example/java/dist/libirohajava.jnilib``をプロジェクトのルートフォルダにコピーする必要があります。"

#~ msgid ""
#~ "If you use **Gradle**, add the "
#~ "following line to your ``build.gradle`` "
#~ "file:"
#~ msgstr "**Gradle**を使用する場合、 ``build.gradle``ファイルに次の行を追加してください。"

#~ msgid "build.gradle"
#~ msgstr "build.gradle"

#~ msgid "pom.xml"
#~ msgstr "pom.xml"

#~ msgid ""
#~ "Set the latest version number from "
#~ "our `Maven repository "
#~ "<https://mvnrepository.com/artifact/jp.co.soramitsu/iroha>`_"
#~ msgstr ""
#~ "`Mavenリポジトリ<https://mvnrepository.com/artifact/jp.co.soramitsu/iroha>`"
#~ " _から最新のバージョン番号を設定してください。"

#~ msgid "Compiling Java Bindings Manually"
#~ msgstr "手動でJavaバインディングをコンパイルする"

#~ msgid ""
#~ "Java bindings were compiled with "
#~ "``example/java/build_library.sh`` in `Build Process`"
#~ " section. You need to copy "
#~ "``example/java/dist/libirohajava.jnilib`` to the "
#~ "root folder of your project:"
#~ msgstr ""
#~ "Javaバインディングは `Build Process`セクションの`` "
#~ "example/java/build_library.sh``でコンパイルされています。 あなたのプロジェクトのルートフォルダに"
#~ " ``example/java/dist/libirohajava.jnilib``をコピーしてください。"

#~ msgid ""
#~ "If you use **Gradle**, you need to"
#~ " copy ``example/java/dist/iroha_lib.jar`` to the"
#~ " ``libs`` folder of your project"
#~ msgstr ""
#~ "**Gradle**を使用する場合は、 ``example/java/dist/iroha_lib.jar``をプロジェクトの"
#~ " ``libs``フォルダにコピーする必要があります。"

#~ msgid "Then please add the following to your ``build.gradle`` file:"
#~ msgstr "そして、`` build.gradle``ファイルに以下に示す内容を追加してください。"

#~ msgid "After it please add this to your ``pom.xml``:"
#~ msgstr "それが完了してから、`` pom.xml``に以下の内容を追加してください。"

#~ msgid ""
#~ "Explore ``example/java/TransactionExample.java`` file "
#~ "to get an idea of how to "
#~ "work with a library."
#~ msgstr "``example/java/TransactionExample.java``ファイルの内容を見て、ライブラリの使い方を理解してください。"

#~ msgid ""
#~ "To run this example, you need an"
#~ " Iroha node up and running. Please"
#~ " check out :ref:`getting-started` if "
#~ "you want to learn how to start "
#~ "it."
#~ msgstr ""
#~ "ここでの例を実行するには、イロハノードが１つ稼働していなければいけません。 起動方法を知りたい場合は、:ref"
#~ ":`getting-started`を参照してください。"

#~ msgid "Running the Example"
#~ msgstr "例を実行してみる"

#~ msgid "To start the example, you need to build the example:"
#~ msgstr "例を開始する前に、まず構築する必要があります。"

#~ msgid "Now, to run this example please write:"
#~ msgstr "この例を実行するには、以下のように行ってください。"

#~ msgid "Node.js Library"
#~ msgstr "Node.js ライブラリ"

#~ msgid ""
#~ "Please note that Node.js library is "
#~ "under heavy testing now and problems "
#~ "`might` occur. Don't hesitate to report"
#~ " them to us."
#~ msgstr ""
#~ "Node.jsライブラリは現在重点的にテスト中であり、問題が発生する可能性があることに注意してください。 "
#~ "その場合は我々にすぐに報告してください。"

#~ msgid ""
#~ "There are two main ways of "
#~ "obtaining the Node.js library. If you"
#~ " are a happy macOS or Linux "
#~ "user, you can install it `through "
#~ "NPM <#installing-through-npm>`_. If your"
#~ " system is not yet supported or "
#~ "you want to try the latest "
#~ "version, you can `build this library "
#~ "manually <#building-manually>`_."
#~ msgstr ""
#~ "Node.jsライブラリを取得する方法は主に2つあります。 もし幸いにもあなたがmacOSまたはLinuxユーザーであれば、"
#~ " `NPM <＃installation-through-npm>` "
#~ "_を通してインストールできます。 "
#~ "使用しているシステムがまだサポートされていない場合または最新バージョンを試したい場合は、このライブラリを手動でビルドして行うことができます。"

#~ msgid "Node.js (>=7) (you can try using lower versions though)."
#~ msgstr "Node.js (>=7) (より低いバージョンでも可能ですが...。）"

#~ msgid "Installing Through NPM"
#~ msgstr "NPMを使ってインストールする"

#~ msgid ""
#~ "If you are a happy macOS or "
#~ "Linux user, you can install the "
#~ "library from `NPM repository "
#~ "<https://www.npmjs.com/package/iroha-lib>`_ using "
#~ "NPM"
#~ msgstr ""
#~ "幸いにもmacOSまたはLinuxユーザーであれば、NPMを使用して<NPMリポジトリ<https://www.npmjs.com/package"
#~ "/iroha-lib> `_からライブラリをインストールできます"

#~ msgid "Now you can import it in your project"
#~ msgstr "これでプロジェクトにインポートできます"

#~ msgid "Building Manually"
#~ msgstr "手動で構築する"

#~ msgid ""
#~ "You need this section if you want"
#~ " to build iroha-lib manually for "
#~ "example if your architecture/OS is not"
#~ " supported yet."
#~ msgstr "ご使用のアーキテクチャ/ OSがまだサポートされていない場合など、iroha-libを手動で構築する場合はこのセクションを参照してください。"

#~ msgid "CMake (>=3.8.2)"
#~ msgstr "CMake (>=3.8.2)"

#~ msgid "Protobuf (>=3.5.1)"
#~ msgstr "Protobuf (>=3.5.1)"

#~ msgid "Boost (>=1.65.1)"
#~ msgstr "Boost (>=1.65.1)"

#~ msgid "macOS users can install dependencies with following commands:"
#~ msgstr "macOSユーザーは次のコマンドで実行環境を構築できます："

#~ msgid ""
#~ "If you have SWIG already installed, "
#~ "you **MUST** install patched 3.0.12 "
#~ "version instead using `this patch <https"
#~ "://patch-"
#~ "diff.githubusercontent.com/raw/swig/swig/pull/968.patch>`_. The"
#~ " current version of SWIG doesn't "
#~ "support Node.js versions higher than 6."
#~ " Also you can just delete the "
#~ "global installed SWIG and iroha will "
#~ "pull and build it automatically."
#~ msgstr ""
#~ "SWIGがインストール済みの場合は、**このパッチ<https://patch-"
#~ "diff.githubusercontent.com/raw/swig/swig/pull/968.patch>を使用してパッチ版3.0.12をインストールしてください**"
#~ " _。 "
#~ "現在のSWIGはNode.jsのバージョン6以上をサポートしていません。代わりに、インストールされているグローバルなSWIGを削除するだけで、irohaはそれを自動的にプル＆ビルドします。"

#~ msgid "Go to the NPM package directory and start the build process"
#~ msgstr "NPMパッケージディレクトリに移動し、ビルドプロセスを開始します。"

#~ msgid "That's all. You can use the library now."
#~ msgstr "これで全て完了です。 すぐにライブラリを使用できます。"

#~ msgid ""
#~ "Explore ``example/node/index.js`` file to get"
#~ " an idea of how to work with"
#~ " a library."
#~ msgstr "``example/node/index.js``ファイルをもとに、ライブラリの扱い方を見ていきましょう。"

#~ msgid ""
#~ "To start the example, you need to"
#~ " install all its dependencies (basically"
#~ " ``iroha-lib``)"
#~ msgstr "まずはじめに、すべてのディペンデンシー（依存オブジェクト）をインストールする必要があります（基本的に`` iroha-lib``です）"

#~ msgid ""
#~ "if you have built the library "
#~ "manually, please change import paths to"
#~ " ``path-to-iroha/shared_model/packages/javascript`` "
#~ "in index.js"
#~ msgstr ""
#~ "ライブラリを手作業でビルドした場合は、index.jsのインポートパスを ``path-to-"
#~ "iroha/shared_model/packages/javascript``に変更してください。"

#~ msgid ""
#~ "There are two ways to get Iroha"
#~ " library for Python: via pip and "
#~ "manual compilation from source code. The"
#~ " installation via pip do the same "
#~ "steps as manual compilation so for "
#~ "both of them you need to install"
#~ " all of the prerequisites."
#~ msgstr ""
#~ "Python用Irohaライブラリの入手には、pipとソースコードからの手動コンパイルを経由する2つの方法があります。 "
#~ "pipを使ったインストールは、手動コンパイルと同じ手順を実行します。そのため、いずれかの場合においても前提条件をすべてインストールする必要があります。"

#~ msgid "CMake, git, g++, boost, swig, protobuf, python"
#~ msgstr "CMake, git, g++, boost, swig, protobuf, python"

#~ msgid "Install Iroha Python Libraries"
#~ msgstr "IrohaのPythonライブラリをインストールする"

#~ msgid "Via PIP"
#~ msgstr "PIPを使って行う"

#~ msgid "For the latest version"
#~ msgstr "最新バージョンは"

#~ msgid "Source code"
#~ msgstr "ソースコード"

#~ msgid ""
#~ "For the latest version checkout to "
#~ "develop branch by adding *-b develop*"
#~ " parameter."
#~ msgstr "最新のバージョンは、パラメータに* -b develop *を追加してdevelopブランチを確認してください。"

#~ msgid ""
#~ "After this you can find Iroha "
#~ "python library in "
#~ "**iroha/build/shared_model/bindings** folder, where "
#~ "you have previously cloned repository."
#~ msgstr ""
#~ "その後、以前リポジトリをクローンしていたフォルダにあるIroha pythonライブラリが** "
#~ "iroha/build/shared_model/bindings**フォルダ内にあることがわかります。"

#~ msgid "Compile Protobuf Modules of Iroha from Schema Files"
#~ msgstr "Schema FilesからIrohaのProtobufモジュールをコンパイルする"

#~ msgid ""
#~ "Iroha communicates with users through "
#~ "protobuf messages. In order to send "
#~ "transactions and queries to Iroha node"
#~ " you need to get python module "
#~ "for generating protobuf messages. First "
#~ "of all you need to clone schema"
#~ " folder of Iroha repository. If you"
#~ " have already cloned Iroha repository "
#~ "in the previous step, just use "
#~ "schema folder from there."
#~ msgstr ""
#~ "イロハはprotobufメッセージを通じてユーザーと通信をとります。 "
#~ "イロハノードにトランザクションやクエリを送信するには、protobufメッセージを生成するためのpythonモジュールを入手しておく必要があります。"
#~ " それにはまず、Irohaリポジトリのschemaフォルダをクローンする必要があります。 "
#~ "先ほど紹介した手順でIrohaリポジトリを既にクローンしている場合は、そこからschemaフォルダを使用してください。"

#~ msgid "protobuf, pip"
#~ msgstr "protobuf, pip"

#~ msgid "Building Protobuf Files"
#~ msgstr "Protobufファイルを作成する"

#~ msgid ""
#~ "Protobuf files can be found in "
#~ "**iroha-schema** folder ('\\*_pb2\\*.py' files)"
#~ msgstr "Protobufファイルは**iroha-schema**フォルダ（'\\*_ pb2\\*.py'ファイル）にあります。"

#~ msgid "In order to specify Iroha libraries location:"
#~ msgstr "いろはライブラリの場所を指定するには："

#~ msgid "Import Iroha and all of the protobuf modules that you need:"
#~ msgstr "Irohaと、その他必要なprotobufモジュールをすべてインポートします。"

#~ msgid ""
#~ "Work with byte arrays is different "
#~ "in Python 2 and Python 3. Due "
#~ "to this fact, the work with hashes"
#~ " and blobs is different in the "
#~ "examples. Given examples work fine with"
#~ " both versions of Python."
#~ msgstr ""
#~ "バイト配列の操作は、Python 2とPython "
#~ "3では異なっています。このため、ハッシュとブロブへの作業はこの例では異なっています。例は両方のPythonバージョンで正常に動作します。"

#~ msgid "Import Iroha and schema classes, generated from Iroha protobuf:"
#~ msgstr "Iroha protobufから生成されたIrohaとschemaのクラスをインポートする："

#~ msgid "Get Iroha objects:"
#~ msgstr "Iroha オブジェクトを取得する"

#~ msgid "Read public and private keys:"
#~ msgstr "公開鍵と秘密鍵をreadする："

#~ msgid "Print transaction status with synchronous simple call:"
#~ msgstr "同期シンプルコールを用いてトランザクションステータス (status)を表示 (print)する"

#~ msgid "Or streaming call:"
#~ msgstr "あるいはstreaming callで："

#~ msgid "Send transactions to Iroha:"
#~ msgstr "Irohaにトランザクションを送信する"

#~ msgid "Send query to Iroha and receive a responce:"
#~ msgstr "イロハにクエリを送り、返信を受け取る："

#~ msgid "Create domain and asset:"
#~ msgstr "ドメイン及びアセットの発行"

#~ msgid "Create asset quantity:"
#~ msgstr "アセット量の増加"

#~ msgid "Create account:"
#~ msgstr "アカウントの作成"

#~ msgid "Send asset:"
#~ msgstr "アセットの送信"

#~ msgid "Get asset info:"
#~ msgstr "アセットの関連情報の取得"

#~ msgid "Get account asset:"
#~ msgstr "アカウントの残高を取得する"

#~ msgid "Building Iroha"
#~ msgstr "Irohaを構築する"

#~ msgid ""
#~ "In this guide we will learn how"
#~ " to install all dependencies, required "
#~ "to build Iroha and how to build"
#~ " it."
#~ msgstr "このガイドでは、Irohaを構築するために必要なすべてのディペンデンシーのインストール方法と構築方法について学びます。"

#~ msgid "Preparing the Environment"
#~ msgstr "環境を整える"

#~ msgid ""
#~ "In order to successfully build Iroha,"
#~ " we need to configure the "
#~ "environment. There are several ways to"
#~ " do it and we will describe all"
#~ " of them."
#~ msgstr "イロハを正常に構築するためには、適切な環境設定が必要があります。 それにはいくつかの方法がありますので、以下で説明していきます。"

#~ msgid ""
#~ "Currently, we support Unix-like systems"
#~ " (we are basically targeting popular "
#~ "Linux distros and macOS). If you "
#~ "happen to have Windows or you "
#~ "don't want to spend time installing "
#~ "all dependencies you might want to "
#~ "consider using Docker environment. Also, "
#~ "Windows users might consider using `WSL"
#~ " <https://en.wikipedia.org/wiki/Windows_Subsystem_for_Linux>`_"
#~ msgstr ""
#~ "現在、Unix系システムがサポートされています（本プロジェクトは基本的にLinuxディストリビューションとmacOSをターゲットにしています）。"
#~ " "
#~ "Windowsをご使用の場合や、すべてのディペンデンシーのインストールに時間を費やしたくない場合は、Docker環境のご使用を検討してください。"
#~ " また、Windowsユーザーの方は `WSL "
#~ "<https://en.wikipedia.org/wiki/Windows_Subsystem_for_Linux>` "
#~ "_が参考になるかもしれません。"

#~ msgid ""
#~ "Having troubles? Check FAQ section or"
#~ " communicate to us directly, in case"
#~ " you were stuck on something. We "
#~ "don't expect this to happen, but "
#~ "some issues with an environment are "
#~ "possible."
#~ msgstr ""
#~ "トラブルが起きましたか？ もし何か問題に直面したときは、FAQセクションを確認してみるか、直接私たちに報告してください。 "
#~ "そのようなことが起こるとは考えられにくいですが、システム環境関連で問題が発生する可能性も排除はできません。"

#~ msgid ""
#~ "You don't need Docker to run "
#~ "Iroha, it is just one of the "
#~ "possible choices."
#~ msgstr "Irohaを実行するのにDockerが必ず必要になるということはなく、選択肢の一つに過ぎません。"

#~ msgid ""
#~ "First of all, you need to install"
#~ " ``docker`` and ``docker-compose``. You "
#~ "can read how to install it on "
#~ "a `Docker's website <https://www.docker.com"
#~ "/community-edition/>`_"
#~ msgstr ""
#~ "まず、 ``docker``と ``docker-compose``をインストールする必要があります。"
#~ " `Dockerのウェブサイト<https://www.docker.com/community-edition/>`"
#~ " _でインストール方法を読むことができます。"

#~ msgid "Please, use the latest available docker daemon and docker-compose."
#~ msgstr "必ず最新のdocker daemonとdocker composeを使用してください。"

#~ msgid ""
#~ "Then you should clone the `Iroha "
#~ "repository <https://github.com/hyperledger/iroha>`_ to "
#~ "the directory of your choice."
#~ msgstr ""
#~ "次に、`Irohaリポジトリ<https://github.com/hyperledger/iroha>` "
#~ "_をあなたが選択したディレクトリに複製する必要があります。"

#~ msgid ""
#~ "After it, you need to run the "
#~ "development environment. Run the ``scripts"
#~ "/run-iroha-dev.sh`` script:"
#~ msgstr "そして次に開発環境を起動する必要があります。 ``scripts/run-iroha-dev.sh``スクリプトを以下の通り実行してください。"

#~ msgid ""
#~ "Please make sure that Docker is "
#~ "running before executing the script. "
#~ "macOS users could find a Docker "
#~ "icon in system tray, Linux user "
#~ "could use ``systemctl start docker``"
#~ msgstr ""
#~ "スクリプトを実行する前にDockerが実行されていることを確認してください。 "
#~ "macOSユーザはシステムトレイにDockerアイコンを表示されますし、Linuxユーザは `` systemctl"
#~ " start docker``が使えるでしょう。"

#~ msgid "After you execute this script, following things happen:"
#~ msgstr "このスクリプトを実行すると、以下のことが起こります。"

#~ msgid ""
#~ "1. The script checks if you don't"
#~ " have containers with Iroha already "
#~ "running. Successful completion finishes with"
#~ " the new container shell. 2. The "
#~ "script will download ``iroha-docker-"
#~ "develop`` and ``postgres`` images. ``iroha-"
#~ "docker-develop`` image contains all "
#~ "development dependencies and is based on"
#~ " top of ``ubuntu:16.04``. ``postgres`` "
#~ "image is required for starting and "
#~ "running Iroha. 3. Two containers are "
#~ "created and launched. 4. The user "
#~ "is attached to the interactive "
#~ "environment for development and testing "
#~ "with ``iroha`` folder mounted from the"
#~ " host machine. Iroha folder is "
#~ "mounted to ``/opt/iroha`` in Docker "
#~ "container."
#~ msgstr ""
#~ "1. "
#~ "実行したスクリプトは、Irohaが既に動作しているコンテナがないかどうかをチェックします。これが正常に行われると、新しいコンテナがシェルに出ます。2"
#~ ".スクリプトは、「iroha-docker-develop」と「postgres"
#~ "」のイメージをダウンロードします。``iroha-docker-"
#~ "develop``イメージにはすべてのdevelopment dependenciesが含まれており、`` "
#~ "Ubuntu:16.04``に基づいています。 Irohaの起動ならびに実行には "
#~ "``postgres``イメージが必要です。\n"
#~ "3. 2つのコンテナが作成され、起動されます。\n"
#~ "4.ユーザは、ホストマシンからマウントされた "
#~ "\"iroha\"フォルダを使用して、開発とテストのために対話型環境に接続されます。 IrohaフォルダはDockerコンテナの"
#~ " ``/opt/iroha``にマウントされています。"

#~ msgid ""
#~ "Now your are ready to build Iroha!"
#~ " Please go to `Building Iroha` "
#~ "section."
#~ msgstr "これであなたもイロハを構築する準備ができました！ セクション「Irohaを構築する」に進んでください。"

#~ msgid "Linux"
#~ msgstr "Linux"

#~ msgid "Boost"
#~ msgstr "Boost"

#~ msgid ""
#~ "Iroha requires Boost of at least "
#~ "1.65 version. To install Boost libraries"
#~ " (``libboost-all-dev``), use `current "
#~ "release <http://www.boost.org/users/download/>`_ from "
#~ "Boost webpage. The only dependencies are"
#~ " system and filesystem, so use "
#~ "``./bootstrap.sh --with-libraries=system,filesystem`` "
#~ "when you are building the project."
#~ msgstr ""
#~ "Irohaには少なくとも1.65バージョンのBoostが必要です。 Boostライブラリ "
#~ "(``libboost-all-dev``)をインストールは、Boostのウェブページ `current"
#~ " release <http://www.boost.org/users/download/>` "
#~ "_を使用してください。 唯一のディペンデンシーはシステムとファイルシステムなので、プロジェクトをビルドするときに "
#~ "``./bootstrap.sh --with-"
#~ "libraries=system,filesystem```を使用してください。"

#~ msgid "Other Dependencies"
#~ msgstr "その他のディペンデンシー"

#~ msgid "To build Iroha, you need following packages:"
#~ msgstr "Irohaの構築には、以下のパッケージが必要です："

#~ msgid ""
#~ "``build-essential`` ``automake`` ``libtool`` "
#~ "``libssl-dev`` ``zlib1g-dev`` ``libc6-dbg`` "
#~ "``golang`` ``git`` ``tar`` ``gzip`` ``ca-"
#~ "certificates`` ``wget`` ``curl`` ``file`` "
#~ "``unzip`` ``python`` ``cmake``"
#~ msgstr ""
#~ "``build-essential`` ``automake`` ``libtool`` "
#~ "``libssl-dev`` ``zlib1g-dev`` ``libc6-dbg`` "
#~ "``golang`` ``git`` ``tar`` ``gzip`` ``ca-"
#~ "certificates`` ``wget`` ``curl`` ``file`` "
#~ "``unzip`` ``python`` ``cmake``"

#~ msgid "Use this code to install dependencies on Debian-based Linux distro."
#~ msgstr "DebianベースのLinuxディストリビューションにディペンデンシーをインストールするには、このコードを使用してください。"

#~ msgid ""
#~ "If you are willing to actively "
#~ "develop Iroha and to build shared "
#~ "libraries, please consider installing the "
#~ "`latest release <https://cmake.org/download/>`_ of"
#~ " CMake."
#~ msgstr ""
#~ "積極的にIrohaを開発し共有ライブラリを構築したい場合は、CMakeの最新リリース<https://cmake.org/download/>"
#~ " _をインストールすることを検討してください。"

#~ msgid "macOS"
#~ msgstr "macOS"

#~ msgid ""
#~ "If you want to build it from "
#~ "scratch and actively develop it, please"
#~ " use this code to install all "
#~ "dependencies with Homebrew."
#~ msgstr "最初からビルドして積極的に開発したい場合は、このコードを使用してHomebrewにすべてのディペンデンシーをインストールしてください。"

#~ msgid "To install the Homebrew itself please run"
#~ msgstr "Homebrew自体のインストールは、以下を実行して下さい。"

#~ msgid ""
#~ "``ruby -e \"$(curl -fsSL "
#~ "https://raw.githubusercontent.com/homebrew/install/master/install)\"``"
#~ msgstr ""
#~ "``ruby -e \"$(curl -fsSL "
#~ "https://raw.githubusercontent.com/homebrew/install/master/install)\"``"

#~ msgid "Cloning the Repository"
#~ msgstr "リポジトリをクローンする"

#~ msgid ""
#~ "Clone the `Iroha repository "
#~ "<https://github.com/hyperledger/iroha>`_ to the "
#~ "directory of your choice."
#~ msgstr ""
#~ "`Irohaリポジトリ<https://github.com/hyperledger/iroha>` "
#~ "_を目的に応じたディレクトリにクローンします。"

#~ msgid ""
#~ "If you have installed the prerequisites"
#~ " with Docker, you don't need to "
#~ "clone Iroha again, because when you "
#~ "run ``run-iroha-dev.sh`` it attaches "
#~ "to Iroha source code folder. Feel "
#~ "free to edit source code files "
#~ "with your host environment and build "
#~ "it within docker container."
#~ msgstr ""
#~ "前提条件をDockerでインストールしている場合、``run-iroha-"
#~ "dev.sh`を実行するとIrohaのソースコードフォルダに接続するので、Irohaを再度クローンする必要はありません。 "
#~ "ホスト環境で自由にソースコードファイルを編集し、docker container内でビルドしてください。"

#~ msgid "To build Iroha, use those commands"
#~ msgstr "いろはを構築するには、これらのコマンドを使って下さい。"

#~ msgid ""
#~ "Alternatively, you can use these "
#~ "shorthand parameters (they are not "
#~ "documented though)"
#~ msgstr "代わりに以下のような省略形のパラメータを使用することもできます（詳細説明はここでは省きます。）"

#~ msgid ""
#~ "On macOS ``$(nproc)`` variable does not"
#~ " work. Check the number of logical"
#~ " cores with ``sysctl -n hw.ncpu`` and"
#~ " put it explicitly in the command "
#~ "above, e.g. ``cmake --build build -- "
#~ "-j4``"
#~ msgstr ""
#~ "macOSでは``$(nproc)``変数は使用できませんので、CPUのコア数を ``sysctl -n "
#~ "hw.ncpu``で確認し、上記のコマンドに明示的に指定してください。例えば、``cmake --build "
#~ "build -- -j4``"

#~ msgid "CMake Parameters"
#~ msgstr "CMakeパラメーター"

#~ msgid ""
#~ "We use CMake to build platform-"
#~ "dependent build files. It has numerous"
#~ " flags for configuring the final "
#~ "build. Note that besides the listed "
#~ "parameters cmake's variables can be "
#~ "useful as well. Also as long as"
#~ " this page can be deprecated (or "
#~ "just not complete) you can browse "
#~ "custom flags via ``cmake -L``, "
#~ "``cmake-gui``, or ``ccmake``."
#~ msgstr ""
#~ "CMakeを使用して、プラットフォームに依存するビルドファイルを作成します。 "
#~ "CMakeには、最終的なビルドを設定するために多数のフラグがあります。 "
#~ "以下で列挙されたパラメータのほかに、cmake変数も有用になることがあります。 "
#~ "また、このページが非推奨（あるいは未完成）なものではない限り、 ``cmake -L``、 "
#~ "``cmake-gui``、または``ccmake``でカスタムフラグを閲覧することができると思います。"

#~ msgid ""
#~ "You can specify parameters at the "
#~ "cmake configuring stage (e.g cmake "
#~ "-DTESTING=ON)."
#~ msgstr "cmakeの設定段階（例: cmake -DTESTING=ON）でパラメータを指定することができます。"

#~ msgid "Main Parameters"
#~ msgstr "主なパラメーター"

#~ msgid "Possible values"
#~ msgstr "取り得る値"

#~ msgid "Default"
#~ msgstr "デフォルト"

#~ msgid "TESTING"
#~ msgstr "TESTING"

#~ msgid "ON/OFF"
#~ msgstr "ON/OFF"

#~ msgid "ON"
#~ msgstr "ON"

#~ msgid "Enables or disables build of the tests"
#~ msgstr "テスト時のビルドを有効または無効にします。"

#~ msgid "BENCHMARKING"
#~ msgstr "BENCHMARKING"

#~ msgid "OFF"
#~ msgstr "OFF"

#~ msgid "Enables or disables build of the Google Benchmarks library"
#~ msgstr "Google Benchmarksライブラリの作成を有効または無効にします"

#~ msgid "COVERAGE"
#~ msgstr "COVERAGE"

#~ msgid "Enables or disables lcov setting for code coverage generation"
#~ msgstr "コードカバレッジ生成のlcov設定を有効または無効にします"

#~ msgid "SWIG_PYTHON"
#~ msgstr "SWIG_PYTHON"

#~ msgid "Enables of disables the library building and Python bindings"
#~ msgstr "ライブラリ作成とPythonバインディングを有効または無効にします"

#~ msgid "SWIG_JAVA"
#~ msgstr "SWIG_JAVA"

#~ msgid "Enables of disables the library building and Java bindings"
#~ msgstr "ライブラリ作成とJavaバインディングを有効または無効にします"

#~ msgid "Packaging Specific Parameters"
#~ msgstr "特定のパラメータをパッケージ化する"

#~ msgid "ENABLE_LIBS_PACKAGING"
#~ msgstr "ENABLE_LIBS_PACKAGING"

#~ msgid "Enables or disables all types of packaging"
#~ msgstr "すべてのパッケージタイプを有効または無効にします。"

#~ msgid "PACKAGE_ZIP"
#~ msgstr "PACKAGE_ZIP"

#~ msgid "Enables or disables zip packaging"
#~ msgstr "zipパッケージを有効または無効にする"

#~ msgid "PACKAGE_TGZ"
#~ msgstr "PACKAGE__TGZ"

#~ msgid "Enables or disables tar.gz packaging"
#~ msgstr "tar.gzパッケージを有効または無効にします。"

#~ msgid "PACKAGE_RPM"
#~ msgstr "PACKAGE_RPM"

#~ msgid "Enables or disables rpm packaging"
#~ msgstr "rpmパッケージを有効または無効にする"

#~ msgid "PACKAGE_DEB"
#~ msgstr "PACKAGE_DEB"

#~ msgid "Enables or disables deb packaging"
#~ msgstr "debパッケージ化を有効または無効にする"

#~ msgid "Running Tests (optional)"
#~ msgstr "テストの実行（オプショナル）"

#~ msgid ""
#~ "After building Iroha, it is a good"
#~ " idea to run tests to check the"
#~ " operability of the daemon. You can"
#~ " run tests with this code:"
#~ msgstr "イロハを構築した後、テストを実行してデーモンの実行状況を確認することをお勧めします。 以下のコードでテストを実行できます："

#~ msgid "Alternatively, you can run following command in the ``build`` folder"
#~ msgstr "あるいは ` build``フォルダ内で次のコマンドを実行することもできます"

#~ msgid ""
#~ "Some of the tests will fail "
#~ "without PostgreSQL storage running, so "
#~ "if you are not using ``scripts/run-"
#~ "iroha-dev.sh`` script please run Docker"
#~ " container or create a local "
#~ "connection with following parameters:"
#~ msgstr ""
#~ "PostgreSQLストレージを実行していないとテスト中に失敗するものがありますので、もし``scripts / "
#~ "run-iroha-"
#~ "dev.sh``スクリプトを使用しない場合は、Dockerコンテナを実行するか、以下のパラメータを用いてローカル接続を行ってください："

#~ msgid "Installing Dependencies"
#~ msgstr "実行環境を整える"

#~ msgid ""
#~ "This page contains references and guides"
#~ " about installation of various tools "
#~ "you may need during build of "
#~ "different targets of Iroha project."
#~ msgstr "このページには、Irohaプロジェクトで必要になる様々なターゲットをビルドする際に必要となるツールのインストールに関する参考情報とガイドが含まれています。"

#~ msgid ""
#~ "Please note that most likely you "
#~ "do not need to install all the "
#~ "listed tools. Some of them are "
#~ "required only for building specific "
#~ "versions of Iroha Client Library."
#~ msgstr ""
#~ "ここで列挙されている全ツールをインストールする必要はありません。 それらの一部は、特定のバージョンのIroha "
#~ "Client Libraryをビルドする場合にのみ必要です。"

#~ msgid "Automake"
#~ msgstr "Automake"

#~ msgid "Installation on Ubuntu"
#~ msgstr "Ubuntuでインストール"

#~ msgid "Bison"
#~ msgstr "Bison"

#~ msgid "CMake"
#~ msgstr "CMake"

#~ msgid ""
#~ "Minimum required version is 3.8, but "
#~ "we recommend to install the latest "
#~ "available version (3.10.3 at the "
#~ "moment)."
#~ msgstr "最低限必要なバージョンは3.8ですが、最新バージョン（現時点では3.10.3）をインストールすることをお勧めします。"

#~ msgid ""
#~ "Since Ubuntu repositories contain unsuitable"
#~ " version of CMake, you need to "
#~ "install the new one manually. Here "
#~ "is how to build and install CMake"
#~ " from sources."
#~ msgstr ""
#~ "Ubuntuのリポジトリには不適切なバージョンのCMakeが含まれているため、新しいものを手動でインストールする必要があります。 "
#~ "ソースからCMakeをビルドしてインストールする方法は次のとおりです。"

#~ msgid "Installation on macOS"
#~ msgstr "MacOSでインストールする"

#~ msgid "Git"
#~ msgstr "Git"

#~ msgid "Python"
#~ msgstr "Python"

#~ msgid "For Python 2:"
#~ msgstr "Python 2:"

#~ msgid "For Python 3:"
#~ msgstr "Python 3:"

#~ msgid "PIP"
#~ msgstr "PIP"

#~ msgid "SWIG"
#~ msgstr "SWIG"

#~ msgid "Protobuf"
#~ msgstr "Protobuf"

#~ msgid ""
#~ "Please note that due to a known"
#~ " issue you would not get any "
#~ "exception if you pass invalid precision"
#~ " value. Valid range is: 0 <= "
#~ "precision <= 255"
#~ msgstr ""

#~ msgid "0 <= precision <= 255"
#~ msgstr ""

#~ msgid "RolePermission"
#~ msgstr ""

#~ msgid "id of the account to which the rights are granted"
#~ msgstr ""

#~ msgid "GrantablePermission name"
#~ msgstr ""

#~ msgid "name of grantable permission"
#~ msgstr ""

#~ msgid ""
#~ "If there was a value for a "
#~ "given key already in the storage "
#~ "then it will be replaced with the"
#~ " new value"
#~ msgstr ""

#~ msgid "id of the account to which the key-value information was set"
#~ msgstr ""

#~ msgid ""
#~ "number of signatories needed to be "
#~ "included within a transaction from this"
#~ " account"
#~ msgstr ""

#~ msgid "ID of the account to withdraw the asset from"
#~ msgstr ""

#~ msgid "ID of the account to send the asset to"
#~ msgstr ""

#~ msgid "ID of the asset to transfer"
#~ msgstr ""

#~ msgid "Message to attach to the transfer"
#~ msgstr ""

#~ msgid "Get Pending Transactions"
#~ msgstr ""

#~ msgid ""
#~ "GetPendingTransactions is used for retrieving"
#~ " a list of pending (not fully "
#~ "signed) `multisignature transactions "
#~ "<../core_concepts/glossary.html#multisignature-transactions>`_"
#~ " or `batches of transactions "
#~ "<../core_concepts/glossary.html#batch-of-transactions>`__"
#~ " issued by account of query creator."
#~ msgstr ""

#~ msgid ""
#~ "The response contains a list of "
#~ "`pending transactions <../core_concepts/glossary.html"
#~ "#pending-transactions>`_."
#~ msgstr ""

#~ msgid "an array of pending transactions"
#~ msgstr ""

#~ msgid "Pending transactions"
#~ msgstr ""

#~ msgid ""
#~ "In a case when a list of "
#~ "transactions per account is needed, "
#~ "`GetAccountTransactions` query can be formed."
#~ " .. note:: This query uses pagination"
#~ " for query responses."
#~ msgstr ""

#~ msgid "Page size"
#~ msgstr ""

#~ msgid ""
#~ "size of the page to be returned"
#~ " by the query, if the response "
#~ "contains fewer transactions than a page"
#~ " size, then next tx hash will "
#~ "be empty in response"
#~ msgstr ""

#~ msgid "page_size > 0"
#~ msgstr ""

#~ msgid "First tx hash"
#~ msgstr ""

#~ msgid ""
#~ "hash of the first transaction in "
#~ "the page. If that field is not "
#~ "set — then the first transactions "
#~ "are returned"
#~ msgstr ""

#~ msgid "hash in hex format"
#~ msgstr ""

#~ msgid "bddd58404d1315e0eb27902c5d7c8eb0602c16238f005773df406bc191308929"
#~ msgstr ""

#~ msgid "All transactions size"
#~ msgstr ""

#~ msgid "total number of transactions created by the given account"
#~ msgstr ""

#~ msgid "100"
#~ msgstr ""

#~ msgid "Next transaction hash"
#~ msgstr ""

#~ msgid ""
#~ "hash pointing to the next transaction"
#~ " after the last transaction in the"
#~ " page. Empty if a page contains "
#~ "the last transaction for the given "
#~ "account"
#~ msgstr ""

#~ msgid ""
#~ "`GetAccountAssetTransactions` query returns all "
#~ "transactions associated with given account "
#~ "and asset. .. note:: This query "
#~ "uses pagination for query responses."
#~ msgstr ""

#~ msgid "total number of transactions for given account and asset"
#~ msgstr ""

#~ msgid ""
#~ "hash pointing to the next transaction"
#~ " after the last transaction in the"
#~ " page. Empty if a page contains "
#~ "the last transaction for given account"
#~ " and asset"
#~ msgstr ""

#~ msgid ""
#~ "To get the state of all assets "
#~ "in an account (a balance), "
#~ "`GetAccountAssets` query can be used."
#~ msgstr ""

#~ msgid "Get Account Detail"
#~ msgstr ""

#~ msgid ""
#~ "To get details of the account, "
#~ "`GetAccountDetail` query can be used. "
#~ "Account details are key-value pairs, "
#~ "splitted into writers categories. Writers "
#~ "are accounts, which added the "
#~ "corresponding account detail. Example of "
#~ "such structure is:"
#~ msgstr ""

#~ msgid ""
#~ "Here, one can see four account "
#~ "details - \"age\", \"hobbies\" and "
#~ "\"sports\" - added by two writers "
#~ "- \"account@a_domain\" and \"account@b_domain\". "
#~ "All of these details, obviously, are "
#~ "about the same account."
#~ msgstr ""

#~ msgid ""
#~ "Pay attention, that all fields are "
#~ "optional. Reasons will be described "
#~ "later."
#~ msgstr ""

#~ msgid "account id to get details from"
#~ msgstr ""

#~ msgid "account@domain"
#~ msgstr ""

#~ msgid "key, under which to get details"
#~ msgstr ""

#~ msgid "string"
#~ msgstr ""

#~ msgid "age"
#~ msgstr ""

#~ msgid "Writer"
#~ msgstr ""

#~ msgid "account id of writer"
#~ msgstr ""

#~ msgid "Detail"
#~ msgstr ""

#~ msgid "key-value pairs with account details"
#~ msgstr ""

#~ msgid "see below"
#~ msgstr ""

#~ msgid "Usage Examples"
#~ msgstr ""

#~ msgid ""
#~ "Let's again consider the example of "
#~ "details from the beginning and see, "
#~ "how different variants of `GetAccountDetail`"
#~ " queries will change the resulting "
#~ "response."
#~ msgstr ""

#~ msgid "**account_id is not set**"
#~ msgstr ""

#~ msgid ""
#~ "If account_id is not set - other"
#~ " fields can be empty or not -"
#~ " it will automatically be substituted "
#~ "with query creator's account, which will"
#~ " lead to one of the next cases."
#~ msgstr ""

#~ msgid "**only account_id is set**"
#~ msgstr ""

#~ msgid ""
#~ "In this case, all details about "
#~ "that account are going to be "
#~ "returned, leading to the following "
#~ "response:"
#~ msgstr ""

#~ msgid "**account_id and key are set**"
#~ msgstr ""

#~ msgid ""
#~ "Here, details added by all writers "
#~ "under the key are going to be "
#~ "returned. For example, if we asked "
#~ "for the key \"age\", that's the "
#~ "response we would get:"
#~ msgstr ""

#~ msgid "**account_id and writer are set**"
#~ msgstr ""

#~ msgid ""
#~ "Now, the response will contain all "
#~ "details about this account, added by "
#~ "one specific writer. For example, if "
#~ "we asked for writer \"account@b_domain\", "
#~ "we would get:"
#~ msgstr ""

#~ msgid "**account_id, key and writer are set**"
#~ msgstr ""

#~ msgid ""
#~ "Lastly, if all three field are "
#~ "set, result will contain details, added"
#~ " the specific writer and under the"
#~ " specific key, for example, if we "
#~ "asked for key \"age\" and writer "
#~ "\"account@a_domain\", we would get:"
#~ msgstr ""

#~ msgid "`List of Iroha permissions <../maintenance/permissions.html>`_."
#~ msgstr ""

#~ msgid ""
#~ "In the context of transactions signing,"
#~ " quorum number is a minimum amount"
#~ " of signatures required to consider a"
#~ " transaction signed. The default value "
#~ "is 1. Each account can link "
#~ "additional public keys and increase own"
#~ " quorum number."
#~ msgstr ""

#~ msgid "Signatory"
#~ msgstr ""

#~ msgid ""
#~ "Represents an entity that can confirm"
#~ " multisignature transactions for some "
#~ "`account <#account>`__. It can be "
#~ "attached to account via `AddSignatory "
#~ "<../api/commands.html#add-signatory>`__ and detached"
#~ " via `RemoveSignatory <../api/commands.html#remove-"
#~ "signatory>`__."
#~ msgstr ""

#~ msgid "Transaction Structure"
#~ msgstr ""

#~ msgid "**Payload** stores all transaction fields, except signatures:"
#~ msgstr ""

#~ msgid "Time of creation (unix time, in milliseconds)"
#~ msgstr ""

#~ msgid "Account ID of transaction creator (username@domain)"
#~ msgstr ""

#~ msgid "Quorum field (indicates required number of signatures)"
#~ msgstr ""

#~ msgid ""
#~ "Repeated commands which are described in"
#~ " details in `commands section "
#~ "<../api/commands.html>`__"
#~ msgstr ""

#~ msgid ""
#~ "Batch meta information (optional part). "
#~ "See `Batch of Transactions`_ for details"
#~ msgstr ""

#~ msgid ""
#~ "**Signatures** contain one or many "
#~ "signatures (ed25519 public key + "
#~ "signature)"
#~ msgstr ""

#~ msgid "Reduced Transaction Hash"
#~ msgstr ""

#~ msgid ""
#~ "Reduced hash is calculated over "
#~ "transaction payload excluding batch meta "
#~ "information. Used in `Batch of "
#~ "Transactions`_."
#~ msgstr ""

#~ msgid "Transaction Statuses"
#~ msgstr ""

#~ msgid ""
#~ "Hyperledger Iroha supports both push and"
#~ " pull interaction mode with a client."
#~ " A client that uses pull mode "
#~ "requests status updates about transactions "
#~ "from Iroha peer by sending transaction"
#~ " hashes and awaiting a response. In"
#~ " contrary push interaction is done "
#~ "over the listening of an event "
#~ "stream for each transaction. In any "
#~ "of these modes, the set of "
#~ "transaction statuses is the same:"
#~ msgstr ""

#~ msgid "Transaction Status Set"
#~ msgstr ""

#~ msgid "NOT_RECEIVED: requested peer does not have this transaction."
#~ msgstr ""

#~ msgid ""
#~ "MST_EXPIRED: this transactions is a part"
#~ " of MST pipeline and has expired."
#~ msgstr ""

#~ msgid ""
#~ "STATELESS_VALIDATION_FAILED: the transaction was "
#~ "formed with some fields, not meeting "
#~ "stateless validation constraints. This status"
#~ " is returned to a client, who "
#~ "formed transaction, right after the "
#~ "transaction was sent. It would also "
#~ "return the reason — what rule was"
#~ " violated."
#~ msgstr ""

#~ msgid ""
#~ "STATELESS_VALIDATION_SUCCESS: the transaction has"
#~ " successfully passed stateless validation. "
#~ "This status is returned to a "
#~ "client, who formed transaction, right "
#~ "after the transaction was sent."
#~ msgstr ""

#~ msgid ""
#~ "STATEFUL_VALIDATION_FAILED: the transaction has "
#~ "commands, which violate validation rules, "
#~ "checking state of the chain (e.g. "
#~ "asset balance, account permissions, etc.). "
#~ "It would also return the reason —"
#~ " what rule was violated."
#~ msgstr ""

#~ msgid ""
#~ "STATEFUL_VALIDATION_SUCCESS: the transaction has "
#~ "successfully passed stateful validation."
#~ msgstr ""

#~ msgid ""
#~ "COMMITTED: the transaction is the part"
#~ " of a block, which gained enough "
#~ "votes and is in the block store"
#~ " at the moment."
#~ msgstr ""

#~ msgid "Pending Transactions"
#~ msgstr ""

#~ msgid ""
#~ "Any transaction that has lesser "
#~ "signatures at the moment than `quorum`_"
#~ " of transaction creator account is "
#~ "considered as pending. Pending transaction "
#~ "will be submitted for `stateful "
#~ "validation`_ as soon as `multisignature "
#~ "<#multisignature-transactions>`__ mechanism will "
#~ "collect required amount of signatures "
#~ "for quorum."
#~ msgstr ""

#~ msgid ""
#~ "Transaction that already has quorum of"
#~ " signatures can also be considered as"
#~ " pending in cases when the "
#~ "transaction is a part of `batch of"
#~ " transactions`_ and there is a not"
#~ " fully signed transaction."
#~ msgstr ""

#~ msgid "Batch of Transactions"
#~ msgstr ""

#~ msgid "*The feature is to be released.*"
#~ msgstr ""

#~ msgid ""
#~ "Transactions batch is a feature that "
#~ "allows sending several transactions to "
#~ "Iroha at once preserving their order."
#~ msgstr ""

#~ msgid ""
#~ "Each transaction within a batch includes"
#~ " batch meta information. Batch meta "
#~ "contains batch type identifier (atomic "
#~ "or ordered) and a list of `reduced"
#~ " hashes <#reduced-transaction-hash>`_ of"
#~ " all transactions within a batch. The"
#~ " order of hashes prescribes transactions"
#~ " sequence."
#~ msgstr ""

#~ msgid ""
#~ "Batch can contain transactions created "
#~ "by different accounts. Any transaction "
#~ "within a batch can require single "
#~ "or `multiple <#multisignature-transactions>`__ "
#~ "signatures (depends on quorum set for"
#~ " an account of transaction creator). "
#~ "At least one transaction inside a "
#~ "batch should have at least one "
#~ "signature to let the batch pass "
#~ "`stateless validation`_."
#~ msgstr ""

#~ msgid "Atomic Batch"
#~ msgstr ""

#~ msgid ""
#~ "All the transactions within an atomic"
#~ " batch should pass `stateful validation`_"
#~ " for the batch to be applied to"
#~ " a ledger."
#~ msgstr ""

#~ msgid "Ordered Batch"
#~ msgstr ""

#~ msgid ""
#~ "Ordered batch preserves only the "
#~ "sequence of transactions applying to a"
#~ " ledger. All the transactions that "
#~ "able to pass stateful validation within"
#~ " a batch will be applied to a"
#~ " ledger. Validation failure of one "
#~ "transaction would NOT directly imply the"
#~ " failure of the whole batch."
#~ msgstr ""

#~ msgid "Multisignature Transactions"
#~ msgstr ""

#~ msgid ""
#~ "A transaction which has the `quorum`_"
#~ " greater than one is considered as"
#~ " multisignature (also called mst). To "
#~ "achieve `stateful validity <#stateful-"
#~ "validation>`__ the confirmation is required"
#~ " by the `signatories <#signatory>`__ of "
#~ "the creator account. These participants "
#~ "need to send the same transaction "
#~ "with their signature."
#~ msgstr ""

#~ msgid "Sections"
#~ msgstr ""

#~ msgid ""
#~ "To keep things simple, in this "
#~ "guide we will create a network "
#~ "containing only one node. To understand"
#~ " how to run several peers, follow "
#~ "`this guide. "
#~ "<github.com/hyperledger/iroha/tree/master/deploy/ansible>`_"
#~ msgstr ""

#~ msgid ""
#~ "``--depth=1`` option allows us to "
#~ "download only latest commit and save "
#~ "some time and bandwidth. If you "
#~ "want to get a full commit history,"
#~ " you can omit this option."
#~ msgstr ""

#~ msgid ""
#~ "``--entrypoint=/bin/bash \\`` Because "
#~ "``hyperledger/iroha`` has the custom script"
#~ " which runs after starting the "
#~ "container, we want to override it "
#~ "so we can start Iroha Daemon "
#~ "manually."
#~ msgstr ""

#~ msgid ""
#~ "``hyperledger/iroha:develop`` is the image "
#~ "which has the ``develop`` branch."
#~ msgstr ""

#~ msgid ""
#~ "Specifying a new genesis block using "
#~ "`--genesis_block` with blocks already present"
#~ " in ledger requires `--overwrite_ledger` "
#~ "flag to be set. The daemon will"
#~ " fail otherwise."
#~ msgstr ""

#~ msgid "Fund Management"
#~ msgstr ""

#~ msgid ""
#~ "With the support of multisignature "
#~ "transactions it is possible to maintain"
#~ " a fund by many managers. In "
#~ "that scheme investment can only be "
#~ "made after the confirmation of the "
#~ "quorum participants."
#~ msgstr ""

#~ msgid ""
#~ "The fund assets should be held at"
#~ " one account. Its signatories should "
#~ "be fund managers, who are dealing "
#~ "with investments and portfolio distributions."
#~ " That can be added via "
#~ "``AddSignatory`` command. All of the "
#~ "assets should be held within one "
#~ "account, which signatories represent the "
#~ "fund managers. Thus the concrete "
#~ "exchanges can be performed with the "
#~ "multisignature transaction so that everyone"
#~ " will decide on a particular "
#~ "financial decision. The one may confirm"
#~ " a deal by sending the original "
#~ "transaction and one of managers' "
#~ "signature. Iroha will maintain the "
#~ "transaction sending so that the deal "
#~ "will not be completed until it "
#~ "receives the required number of "
#~ "confirmation, which is parametrized with "
#~ "the transaction quorum parameter."
#~ msgstr ""

#~ msgid ""
#~ "``mst_enable`` enables or disables "
#~ "multisignature transaction support in Iroha."
#~ " We recommend setting this parameter "
#~ "to ``false`` at the moment until "
#~ "you really need it."
#~ msgstr ""

#~ msgid ""
#~ "1. The script checks if you don't"
#~ " have containers with Iroha already "
#~ "running. Successful completion finishes with"
#~ " the new container shell. 2. The "
#~ "script will download ``hyperledger/iroha:develop-"
#~ "build`` and ``postgres`` images. "
#~ "``hyperledger/iroha:develop-build`` image contains"
#~ " all development dependencies and is "
#~ "based on top of ``ubuntu:16.04``. "
#~ "``postgres`` image is required for "
#~ "starting and running Iroha. 3. Two "
#~ "containers are created and launched. 4."
#~ " The user is attached to the "
#~ "interactive environment for development and"
#~ " testing with ``iroha`` folder mounted "
#~ "from the host machine. Iroha folder "
#~ "is mounted to ``/opt/iroha`` in Docker"
#~ " container."
#~ msgstr ""

#~ msgid ""
#~ "Iroha requires Boost of at least "
#~ "1.65 version. To install Boost libraries"
#~ " (``libboost-all-dev``), use `current "
#~ "release <http://www.boost.org/users/download/>`_ from "
#~ "Boost webpage. The only dependencies are"
#~ " thread, system and filesystem, so "
#~ "use ``./bootstrap.sh --with-"
#~ "libraries=thread,system,filesystem`` when you are"
#~ " building the project."
#~ msgstr ""

#~ msgid ""
#~ "Minimum required version is 3.11.4, but"
#~ " we recommend to install the latest"
#~ " available version (3.12.0 at the "
#~ "moment)."
#~ msgstr ""

#~ msgid "Entity-relationship model"
#~ msgstr ""

#~ msgid ""
#~ "Each Hyperledger Iroha peer has a "
#~ "state, called \"World State View\", "
#~ "which is represented by a set of"
#~ " entities and relations between them. "
#~ "To explain you more which entities "
#~ "exist in the system and what are"
#~ " the relations, this sections includes "
#~ "ER diagram and an explanation of "
#~ "its components."
#~ msgstr ""

#~ msgid "ER diagram"
#~ msgstr ""

#~ msgid ""
#~ "address — network address and internal"
#~ " port, is used for synchronization, "
#~ "consensus, and communication with the "
#~ "ordering service"
#~ msgstr ""

#~ msgid ""
#~ "public_key — key, which will be "
#~ "used for signing blocks during consensus"
#~ " process"
#~ msgstr ""

#~ msgid "asset_id — identifier of asset, formatted as asset_name#domain_id"
#~ msgstr ""

#~ msgid ""
#~ "domain_id — identifier of domain, where"
#~ " the asset was created, references "
#~ "existing domain"
#~ msgstr ""

#~ msgid "precision — size of fractional part"
#~ msgstr ""

#~ msgid "data — JSON with arbitrary structure of asset description"
#~ msgstr ""

#~ msgid "public_key — a public key"
#~ msgstr ""

#~ msgid "domain_id — identifier of a domain"
#~ msgstr ""

#~ msgid ""
#~ "default_role — a default role per "
#~ "user created in the domain, references"
#~ " existing role"
#~ msgstr ""

#~ msgid "role_id — identifier of role"
#~ msgstr ""

#~ msgid "RoleHasPermissions"
#~ msgstr ""

#~ msgid "role_id — identifier of role, references existing role"
#~ msgstr ""

#~ msgid "permission_id — an id of predefined role"
#~ msgstr ""

#~ msgid "account_id — identifier of account, formatted as account_name@domain_id"
#~ msgstr ""

#~ msgid ""
#~ "domain_id — identifier of domain where"
#~ " the account was created, references "
#~ "existing domain"
#~ msgstr ""

#~ msgid ""
#~ "quorum — number of signatories required"
#~ " for creation of valid transaction "
#~ "from this account"
#~ msgstr ""

#~ msgid "transaction_count – counter of transactions created by this account"
#~ msgstr ""

#~ msgid "data — key-value storage for any information, related to the account"
#~ msgstr ""

#~ msgid "AccountHasSignatory"
#~ msgstr ""

#~ msgid "account_id — identifier of account, references existing account"
#~ msgstr ""

#~ msgid ""
#~ "public_key — a public key (which "
#~ "is also called signatory), references "
#~ "existing signatory"
#~ msgstr ""

#~ msgid "AccountHasAsset"
#~ msgstr ""

#~ msgid "asset_id — identifier of asset, references existing asset"
#~ msgstr ""

#~ msgid "amount — an amount of the asset, belonging to the account"
#~ msgstr ""

#~ msgid "AccountHasRoles"
#~ msgstr ""

#~ msgid "AccountHasGrantablePermissions"
#~ msgstr ""

#~ msgid ""
#~ "account_id — identifier of account, "
#~ "references existing account. This account "
#~ "gives grantable permission to perform "
#~ "operation over itself to permittee."
#~ msgstr ""

#~ msgid ""
#~ "permittee_account_id — identifier of account,"
#~ " references existing account. This account"
#~ " is given permission to perform "
#~ "operation over account_id."
#~ msgstr ""

#~ msgid "permission_id — identifier of grantable_permission"
#~ msgstr ""

#~ msgid "Deploying Iroha on Kubernetes cluster"
#~ msgstr ""

#~ msgid ""
#~ "By following this guide you will "
#~ "be able to deploy a Kubernetes "
#~ "cluster from scratch on AWS cloud "
#~ "using Terraform and Kubespray, and "
#~ "deploy a network of Iroha nodes on"
#~ " it."
#~ msgstr ""

#~ msgid "machine running Linux (tested on Ubuntu 16.04) or MacOS"
#~ msgstr ""

#~ msgid "Python 3.3+"
#~ msgstr ""

#~ msgid "boto3"
#~ msgstr ""

#~ msgid "Ansible 2.4+"
#~ msgstr ""

#~ msgid ""
#~ "*ed25519-cli* utility for key generation. "
#~ "Statically linked binary (for x86_64 "
#~ "platform) can be found in "
#~ "deploy/ansible/playbooks/iroha-k8s/scripts directory. "
#~ "You may need to `compile it "
#~ "yourself <https://github.com/Warchant/ed25519-cli>`__."
#~ msgstr ""

#~ msgid ""
#~ "You do not need the items below"
#~ " if you already have a working "
#~ "Kubernetes (k8s) cluster. You can skip"
#~ " to `Generating Iroha configs`_ chapter."
#~ msgstr ""

#~ msgid "Terraform 0.11.8+"
#~ msgstr ""

#~ msgid "AWS account for deploying a k8s cluster on EC2"
#~ msgstr ""

#~ msgid "Preparation"
#~ msgstr ""

#~ msgid ""
#~ "You need to obtain AWS key for "
#~ "managing resources. We recommend to "
#~ "create a separate IAM user for "
#~ "that. Go to your AWS console, head"
#~ " to \"My Security Credentials\" menu "
#~ "and create a user in \"Users\" "
#~ "section. Assign \"AmazonEC2FullAccess\" and "
#~ "\"AmazonVPCFullAccess\" policies to that user."
#~ " Click \"Create access key\" on "
#~ "Security credentials tab. Take a note"
#~ " for values of Access key ID "
#~ "and Secret key. Set these values "
#~ "as environment variables in your "
#~ "console:"
#~ msgstr ""

#~ msgid "Checkout the source tree from Github:"
#~ msgstr ""

#~ msgid "Setting up cloud infrastructure"
#~ msgstr ""

#~ msgid ""
#~ "We use Hashicorp's Terraform infrastructure"
#~ " management tool for automated deployment"
#~ " of AWS EC2 nodes in multiple "
#~ "regions. `Kubespray <https://github.com/kubernetes-"
#~ "incubator/kubespray>`__ Ansible module is used"
#~ " for setting up a production-grade"
#~ " k8s cluster."
#~ msgstr ""

#~ msgid ""
#~ "Terraform module creates 3 AWS instances"
#~ " in 3 different regions: eu-west-1,"
#~ " eu-west-2, eu-west-3 by default. "
#~ "Instance type is *c5.large*. There is"
#~ " a separate VPC created in every "
#~ "region. All created VPCs are then "
#~ "connected using VPC peering connection. "
#~ "That is to create a seamless "
#~ "network for k8s cluster."
#~ msgstr ""

#~ msgid ""
#~ "There are several configurable options: "
#~ "number of nodes in each region and"
#~ " its role in k8s cluster (kube-"
#~ "master or kube-node). They can be"
#~ " set either in *variables.tf* file or"
#~ " via environment variables (using the "
#~ "same variable name but prefixed with "
#~ "TF_VAR. See more in `Terraform docs "
#~ "<https://www.terraform.io/intro/getting-started/variables.html"
#~ "#from-environment-variables>`__). More options"
#~ " can be configured by tuning "
#~ "parameters in module's *variables.tf* file."
#~ msgstr ""

#~ msgid ""
#~ "You must set up SSH key in "
#~ "*deploy/tf/k8s/variables.tf* as well. Replace "
#~ "public key with your own. It will"
#~ " added on each created EC2 instance."
#~ msgstr ""

#~ msgid ""
#~ "Navigate to *deploy/tf/k8s* directory. "
#~ "Terraform needs to download required "
#~ "modules first:"
#~ msgstr ""

#~ msgid "Then run module execution:"
#~ msgstr ""

#~ msgid ""
#~ "Review the execution plan and type "
#~ "*yes* to approve. Upon completion you"
#~ " should see an output similar to "
#~ "this:"
#~ msgstr ""

#~ msgid ""
#~ "We are now ready to deploy k8s "
#~ "cluster. Wait a couple of minutes "
#~ "before instances are initialized."
#~ msgstr ""

#~ msgid "Setting up k8s cluster"
#~ msgstr ""

#~ msgid ""
#~ "There is an Ansible role for "
#~ "setting up k8s cluster. It is an"
#~ " external module called Kubespray. It "
#~ "is stored as a submodule in "
#~ "Hyperledger Iroha repository. This means "
#~ "it needs to be initialized first:"
#~ msgstr ""

#~ msgid "This command will download Kubespray from master repository."
#~ msgstr ""

#~ msgid "Install required dependencies:"
#~ msgstr ""

#~ msgid ""
#~ "Proceed to actual cluster deployment. "
#~ "Make sure you replaced *key-file* "
#~ "parameter with an actual path to "
#~ "SSH private key that was used "
#~ "previously during Terraform configuration. "
#~ "*REGIONS* variable corresponds to default "
#~ "list of regions used on a previous"
#~ " step. Modify it accordingly in case"
#~ " you added or removed any. Inventory"
#~ " file is a Python script that "
#~ "returns Ansible-compatible list of hosts"
#~ " filtered by tag."
#~ msgstr ""

#~ msgid "Upon successful completion you will have working k8s cluster."
#~ msgstr ""

#~ msgid "Generating Iroha configs"
#~ msgstr ""

#~ msgid ""
#~ "In order for Iroha to work "
#~ "properly it requires to generate a "
#~ "key pair for each node, genesis "
#~ "block and configuration file. This is"
#~ " usually a tedious and error-prone"
#~ " procedure, especially for a large "
#~ "number of nodes. We automated it "
#~ "with Ansible role. You can skip to"
#~ " `Deploying Iroha on the cluster`_ "
#~ "chapter if you want to quick start"
#~ " using default configs for k8s "
#~ "cluster with 4 Iroha replicas."
#~ msgstr ""

#~ msgid ""
#~ "Generate configuration files for *N* "
#~ "Iroha nodes. *replicas* variable controls "
#~ "the number of *N*:"
#~ msgstr ""

#~ msgid ""
#~ "You should find files created in "
#~ "*deploy/ansible/roles/iroha-k8s/files/conf*."
#~ msgstr ""

#~ msgid "Deploying Iroha on the cluster"
#~ msgstr ""

#~ msgid ""
#~ "Make sure you have configuration files"
#~ " in *deploy/ansible/roles/iroha-k8s/files*. "
#~ "Specifically, non-empty *conf* directory "
#~ "and *k8s-iroha.yaml* file."
#~ msgstr ""

#~ msgid ""
#~ "There are two options for managing "
#~ "k8s cluster: logging into either of "
#~ "master node and executing commands there"
#~ " or configure remote management. We "
#~ "will cover the second option here "
#~ "as the first one is trivial."
#~ msgstr ""

#~ msgid ""
#~ "In case you set up cluster using"
#~ " Kubespray, you can find *admin.conf* "
#~ "file on either of master node in"
#~ " */etc/kubernetes* directory. Copy this "
#~ "file on the control machine (the "
#~ "one you will be running *kubectl* "
#~ "command from). Make sure *server* "
#~ "parameter in this file points to "
#~ "external IP address or DNS name of"
#~ " a master node. Usually, there is "
#~ "a private IP address of the node"
#~ " (in case of AWS). Make sure "
#~ "*kubectl* utility is installed (`check "
#~ "out the docs <https://kubernetes.io/docs/tasks/tools"
#~ "/install-kubectl/>`__ for instructions)."
#~ msgstr ""

#~ msgid "Replace the default *kubectl* configuration:"
#~ msgstr ""

#~ msgid "We can now control the remote k8s cluster"
#~ msgstr ""

#~ msgid ""
#~ "*k8s-iroha.yaml* pod specification file "
#~ "requires the creation of a *config-"
#~ "map* first. This is a special "
#~ "resource that is mounted in the "
#~ "init container of each pod, and "
#~ "contains the configuration and genesis "
#~ "block files required to run Iroha."
#~ msgstr ""

#~ msgid ""
#~ "Each peer will have their public "
#~ "and private keys stored in a "
#~ "Kubernetes secret which is  mounted in"
#~ " the init container and copied over"
#~ " for Iroha to use. Peers will "
#~ "only be able read their assigned "
#~ "secret when running Iroha."
#~ msgstr ""

#~ msgid "Deploy Iroha network pod specification:"
#~ msgstr ""

#~ msgid ""
#~ "Wait a moment before each node "
#~ "downloads and starts Docker containers. "
#~ "Executing *kubectl get pods* command "
#~ "should eventually return a list of "
#~ "deployed pods each in *Running* state."
#~ msgstr ""

#~ msgid ""
#~ "Pods do not expose ports externally. "
#~ "You need to connect to Iroha "
#~ "instance by its hostname (iroha-0, "
#~ "iroha-1, etc). For that you have "
#~ "to have a running pod in the "
#~ "same network."
#~ msgstr ""

#~ msgid ""
#~ "Hyperledger Iroha uses a role-based "
#~ "access control system to limit actions"
#~ " of its users. This system greatly"
#~ " helps to implement use cases "
#~ "involving user groups having different "
#~ "access levels — ranging from the "
#~ "weak users, who can't even receive "
#~ "asset transfer to the super-users. "
#~ "The beauty of our permission system "
#~ "is that you don't have to have "
#~ "a super-user in your Iroha setup"
#~ " or use all the possible permissions:"
#~ " you can create segregated and "
#~ "lightweight roles."
#~ msgstr ""

#~ msgid ""
#~ "Maintenance of the system involves "
#~ "setting up roles and permissions, that"
#~ " are included in the roles. This "
#~ "might be done at the initial step"
#~ " of system deployment — in genesis"
#~ " block, or later when Iroha network"
#~ " is up and running, roles can "
#~ "be changed (if there is a role "
#~ "that can do that :)"
#~ msgstr ""

#~ msgid ""
#~ "This section will help you to "
#~ "understand permissions and give you an"
#~ " idea of how to create roles "
#~ "including certain permissions. Each permission"
#~ " is provided with an example written"
#~ " in Python that demonstrates the way"
#~ " of transaction or query creation, "
#~ "which require specific permission. Every "
#~ "example uses *commons.py* module, which "
#~ "listing is available at `Supplementary "
#~ "Sources`_ section."
#~ msgstr ""

#~ msgid "List of Permissions"
#~ msgstr ""

#~ msgid "Permission Name"
#~ msgstr ""

#~ msgid "Category"
#~ msgstr ""

#~ msgid "Type"
#~ msgstr ""

#~ msgid "`can_create_account`_"
#~ msgstr ""

#~ msgid "`can_set_detail`_"
#~ msgstr ""

#~ msgid "`can_set_my_account_detail`_ ``grantable``"
#~ msgstr ""

#~ msgid "`can_create_asset`_"
#~ msgstr ""

#~ msgid "`can_receive`_"
#~ msgstr ""

#~ msgid "`can_transfer`_"
#~ msgstr ""

#~ msgid "`can_transfer_my_assets`_ ``grantable``"
#~ msgstr ""

#~ msgid "`can_add_asset_qty`_"
#~ msgstr ""

#~ msgid "Asset Quantity"
#~ msgstr ""

#~ msgid "`can_subtract_asset_qty`_"
#~ msgstr ""

#~ msgid "`can_add_domain_asset_qty`_"
#~ msgstr ""

#~ msgid "`can_subtract_domain_asset_qty`_"
#~ msgstr ""

#~ msgid "`can_create_domain`_"
#~ msgstr ""

#~ msgid "`can_grant_can_add_my_signatory`_"
#~ msgstr ""

#~ msgid "Grant"
#~ msgstr ""

#~ msgid "`can_grant_can_remove_my_signatory`_"
#~ msgstr ""

#~ msgid "`can_grant_can_set_my_account_detail`_"
#~ msgstr ""

#~ msgid "`can_grant_can_set_my_quorum`_"
#~ msgstr ""

#~ msgid "`can_grant_can_transfer_my_assets`_"
#~ msgstr ""

#~ msgid "`can_add_peer`_"
#~ msgstr ""

#~ msgid "`can_append_role`_"
#~ msgstr ""

#~ msgid "`can_create_role`_"
#~ msgstr ""

#~ msgid "`can_detach_role`_"
#~ msgstr ""

#~ msgid "`can_add_my_signatory`_ ``grantable``"
#~ msgstr ""

#~ msgid "`can_add_signatory`_"
#~ msgstr ""

#~ msgid "`can_remove_my_signatory`_ ``grantable``"
#~ msgstr ""

#~ msgid "`can_remove_signatory`_"
#~ msgstr ""

#~ msgid "`can_set_my_quorum`_ ``grantable``"
#~ msgstr ""

#~ msgid "`can_set_quorum`_"
#~ msgstr ""

#~ msgid "`can_get_all_acc_detail`_"
#~ msgstr ""

#~ msgid "`can_get_all_accounts`_"
#~ msgstr ""

#~ msgid "`can_get_domain_acc_detail`_"
#~ msgstr ""

#~ msgid "`can_get_domain_accounts`_"
#~ msgstr ""

#~ msgid "`can_get_my_acc_detail`_"
#~ msgstr ""

#~ msgid "`can_get_my_account`_"
#~ msgstr ""

#~ msgid "`can_get_all_acc_ast`_"
#~ msgstr ""

#~ msgid "Account Asset"
#~ msgstr ""

#~ msgid "`can_get_domain_acc_ast`_"
#~ msgstr ""

#~ msgid "`can_get_my_acc_ast`_"
#~ msgstr ""

#~ msgid "`can_get_all_acc_ast_txs`_"
#~ msgstr ""

#~ msgid "Account Asset Transaction"
#~ msgstr ""

#~ msgid "`can_get_domain_acc_ast_txs`_"
#~ msgstr ""

#~ msgid "`can_get_my_acc_ast_txs`_"
#~ msgstr ""

#~ msgid "`can_get_all_acc_txs`_"
#~ msgstr ""

#~ msgid "Account Transaction"
#~ msgstr ""

#~ msgid "`can_get_domain_acc_txs`_"
#~ msgstr ""

#~ msgid "`can_get_my_acc_txs`_"
#~ msgstr ""

#~ msgid "`can_read_assets`_"
#~ msgstr ""

#~ msgid "`can_get_blocks`_"
#~ msgstr ""

#~ msgid "Block Stream"
#~ msgstr ""

#~ msgid "`can_get_roles`_"
#~ msgstr ""

#~ msgid "`can_get_all_signatories`_"
#~ msgstr ""

#~ msgid "`can_get_domain_signatories`_"
#~ msgstr ""

#~ msgid "`can_get_my_signatories`_"
#~ msgstr ""

#~ msgid "`can_get_all_txs`_"
#~ msgstr ""

#~ msgid "`can_get_my_txs`_"
#~ msgstr ""

#~ msgid "Command-related permissions"
#~ msgstr ""

#~ msgid "can_create_account"
#~ msgstr ""

#~ msgid ""
#~ "Allows creating new `accounts "
#~ "<../core_concepts/glossary.html#account>`__."
#~ msgstr ""

#~ msgid ""
#~ "Related API method: `Create Account "
#~ "<../api/commands.html#create-account>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kCreateAccount``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kCreateAccount``"
#~ msgstr ""

#~ msgid "**Example**"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain \"test\" that "
#~ "contains only can_create_account permission "
#~ "and Alice account in that domain. "
#~ "Alice can create Bob account."
#~ msgstr ""

#~ msgid "can_set_detail"
#~ msgstr ""

#~ msgid ""
#~ "Allows setting `account "
#~ "<../core_concepts/glossary.html#account>`__ detail."
#~ msgstr ""

#~ msgid ""
#~ "The `permission "
#~ "<../core_concepts/glossary.html#permission>`__ allows "
#~ "setting details to other accounts. "
#~ "Another way to set detail without "
#~ "can_set_detail permission is to grant "
#~ "`can_set_my_account_detail`_ permission to someone."
#~ " In order to grant, `transaction "
#~ "<../core_concepts/glossary.html#transaction>`__ creator "
#~ "should have `can_grant_can_set_my_account_detail`_ "
#~ "permission."
#~ msgstr ""

#~ msgid ""
#~ "Transaction creator can always set "
#~ "detail for own account even without "
#~ "that permission."
#~ msgstr ""

#~ msgid ""
#~ "Related API method: `Set Account Detail"
#~ " <../api/commands.html#set-account-detail>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kSetDetail``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kSetDetail``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain \"test\" that "
#~ "contains only can_set_detail permission and"
#~ " Alice account in that domain. Alice"
#~ " can set detail for Admin account."
#~ msgstr ""

#~ msgid "can_set_my_account_detail"
#~ msgstr ""

#~ msgid "This is a grantable permission."
#~ msgstr ""

#~ msgid ""
#~ "`Permission <../core_concepts/glossary.html#permission>`__ "
#~ "that allows a specified `account "
#~ "<../core_concepts/glossary.html#account>`__ to set "
#~ "details for the another specified "
#~ "account."
#~ msgstr ""

#~ msgid ""
#~ "To grant the permission an account "
#~ "should already have a role with "
#~ "`can_grant_can_set_my_account_detail`_ permission."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Grantable.kSetMyAccountDetail``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Grantable_kSetMyAccountDetail``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain \"test\" that "
#~ "contains only can_grant_can_set_my_account_detail "
#~ "permission and two accounts for Alice"
#~ " and Bob in that domain. Alice "
#~ "grants to Bob can_set_my_account_detail "
#~ "permission. Bob can set detail for "
#~ "Alice account."
#~ msgstr ""

#~ msgid "can_create_asset"
#~ msgstr ""

#~ msgid "Allows creating new `assets <../core_concepts/glossary.html#asset>`__."
#~ msgstr ""

#~ msgid ""
#~ "Related API method: `Create Asset "
#~ "<../api/commands.html#create-asset>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kCreateAsset``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kCreateAsset``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain \"test\" that "
#~ "contains only can_create_asset permission and"
#~ " Alice account in that domain. Alice"
#~ " can create new assets."
#~ msgstr ""

#~ msgid "can_receive"
#~ msgstr ""

#~ msgid ""
#~ "Allows `account "
#~ "<../core_concepts/glossary.html#account>`__ receive "
#~ "`assets <../core_concepts/glossary.html#asset>`__."
#~ msgstr ""

#~ msgid ""
#~ "Related API method: `Transfer Asset "
#~ "<../api/commands.html#transfer-asset>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kReceive``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kReceive``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain \"test\" that "
#~ "contains can_receive and can_transfer "
#~ "permissions and two accounts for Alice"
#~ " and Bob. Admin creates \"coin\" "
#~ "asset, adds some quantity of it "
#~ "and transfers the asset to Alice. "
#~ "Alice can transfer assets to Bob "
#~ "(Alice has can_transfer permission and "
#~ "Bob has can_receive permission)."
#~ msgstr ""

#~ msgid "can_transfer"
#~ msgstr ""

#~ msgid ""
#~ "Allows sending `assets "
#~ "<../core_concepts/glossary.html#asset>`__ from an "
#~ "`account <../core_concepts/glossary.html#account>`__ of"
#~ " `transaction <../core_concepts/glossary.html#transaction>`__"
#~ " creator."
#~ msgstr ""

#~ msgid ""
#~ "You can transfer an asset from one"
#~ " `domain <../core_concepts/glossary.html#domain>`__ to"
#~ " another, even if the other domain"
#~ " does not have an asset with "
#~ "the same name."
#~ msgstr ""

#~ msgid "Destination account should have `can_receive`_ permission."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kTransfer``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kTransfer``"
#~ msgstr ""

#~ msgid "can_transfer_my_assets"
#~ msgstr ""

#~ msgid ""
#~ "`Permission <../core_concepts/glossary.html#permission>`__ "
#~ "that allows a specified `account "
#~ "<../core_concepts/glossary.html#account>`__ to transfer"
#~ " `assets <../core_concepts/glossary.html#asset>`__ of"
#~ " another specified account."
#~ msgstr ""

#~ msgid "See the example (to be done) for the usage details."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Grantable.kTransferMyAssets``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Grantable_kTransferMyAssets``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain \"test\" that "
#~ "contains can_grant_can_transfer_my_assets, can_receive,"
#~ " can_transfer permissions and two accounts"
#~ " for Alice and Bob in that "
#~ "domain. Admin issues some amount of "
#~ "\"coin\" asset and transfers it to "
#~ "Alice. Alice grants to Bob "
#~ "can_transfer_my_assets permission. Bob can "
#~ "transfer Alice's assets to any account"
#~ " that has can_receive permission, for "
#~ "example, to Admin."
#~ msgstr ""

#~ msgid "can_add_asset_qty"
#~ msgstr ""

#~ msgid "Allows issuing `assets <../core_concepts/glossary.html#asset>`__."
#~ msgstr ""

#~ msgid ""
#~ "The corresponding `command "
#~ "<../core_concepts/glossary.html#command>`__ can be "
#~ "executed only for an `account "
#~ "<../core_concepts/glossary.html#account>`__ of "
#~ "`transaction <../core_concepts/glossary.html#transaction>`__ "
#~ "creator and only if that account "
#~ "has a `role <../core_concepts/glossary.html#role>`__"
#~ " with the `permission "
#~ "<../core_concepts/glossary.html#permission>`__."
#~ msgstr ""

#~ msgid ""
#~ "Related API method: `Add Asset Quantity"
#~ " <../api/commands.html#add-asset-quantity>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kAddAssetQty``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kAddAssetQty``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain \"test\" that "
#~ "contains only can_add_asset_qty permission and"
#~ " Alice account in that domain. Admin"
#~ " craetes \"coin\" asset. Alice can "
#~ "add to own account any amount of"
#~ " any asset (e.g. \"coin\" asset)."
#~ msgstr ""

#~ msgid "can_subtract_asset_qty"
#~ msgstr ""

#~ msgid "Allows burning `assets <../core_concepts/glossary.html#asset>`__."
#~ msgstr ""

#~ msgid ""
#~ "Related API method: `Subtract Asset "
#~ "Quantity <../api/commands.html#subtract-asset-"
#~ "quantity>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kSubtractAssetQty``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kSubtractAssetQty``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain \"test\" that "
#~ "contains only can_subtract_asset_qty permission "
#~ "and Alice account in that domain. "
#~ "Admin issues some amount of \"coin\" "
#~ "asset and transfers some amount of "
#~ "\"coin\" asset to Alice. Alice can "
#~ "burn any amount of \"coin\" assets."
#~ msgstr ""

#~ msgid "can_add_domain_asset_qty"
#~ msgstr ""

#~ msgid ""
#~ "Allows issuing `assets "
#~ "<../core_concepts/glossary.html#asset>`__ only in "
#~ "own `domain <../core_concepts/glossary.html#domain>`__."
#~ msgstr ""

#~ msgid ""
#~ "The corresponding `command "
#~ "<../core_concepts/glossary.html#command>`__ can be "
#~ "executed only for an `account "
#~ "<../core_concepts/glossary.html#account>`__ of "
#~ "`transaction <../core_concepts/glossary.html#transaction>`__ "
#~ "creator and only if that account "
#~ "has a `role <../core_concepts/glossary.html#role>`__"
#~ " with the `permission "
#~ "<../core_concepts/glossary.html#permission>`__ and only"
#~ " for assets in creator’s domain."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kAddDomainAssetQty``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kAddDomainAssetQty``"
#~ msgstr ""

#~ msgid "can_subtract_domain_asset_qty"
#~ msgstr ""

#~ msgid ""
#~ "Allows burning `assets "
#~ "<../core_concepts/glossary.html#asset>`__ only in "
#~ "own `domain <../core_concepts/glossary.html#domain>`__."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kSubtractDomainAssetQty``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kSubtractDomainAssetQty``"
#~ msgstr ""

#~ msgid "can_create_domain"
#~ msgstr ""

#~ msgid ""
#~ "Allows creating new `domains "
#~ "<../core_concepts/glossary.html#domain>`__ within the "
#~ "system."
#~ msgstr ""

#~ msgid ""
#~ "Related API method: `Create Domain "
#~ "<../api/commands.html#create-domain>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kCreateDomain``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kCreateDomain``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain that contains only"
#~ " can_create_domain permission and Alice "
#~ "account in that domain. Alice can "
#~ "create new domains."
#~ msgstr ""

#~ msgid "can_grant_can_add_my_signatory"
#~ msgstr ""

#~ msgid ""
#~ "Allows `role <../core_concepts/glossary.html#role>`__ "
#~ "owners grant `can_add_my_signatory`_ `permission "
#~ "<../core_concepts/glossary.html#permission>`__."
#~ msgstr ""

#~ msgid ""
#~ "Related API methods: `Grant Permission "
#~ "<../api/commands.html#grant-permission>`__, `Revoke "
#~ "Permission <../api/commands.html#revoke-permission>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kAddMySignatory``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kAddMySignatory``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain that contains only"
#~ " can_grant_can_add_my_signatory permission and "
#~ "two accounts for Alice and Bob in"
#~ " that domain. Alice can grant to "
#~ "Bob and revoke can_add_my_signatory "
#~ "permission."
#~ msgstr ""

#~ msgid "can_grant_can_remove_my_signatory"
#~ msgstr ""

#~ msgid ""
#~ "Allows `role <../core_concepts/glossary.html#role>`__ "
#~ "owners grant `can_remove_my_signatory`_ `permission"
#~ " <../core_concepts/glossary.html#permission>`__."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kRemoveMySignatory``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kRemoveMySignatory``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain that contains only"
#~ " can_grant_can_remove_my_signatory permission and "
#~ "two accounts for Alice and Bob in"
#~ " that domain. Alice can grant to "
#~ "Bob and revoke can_remove_my_signatory "
#~ "permission."
#~ msgstr ""

#~ msgid "can_grant_can_set_my_account_detail"
#~ msgstr ""

#~ msgid ""
#~ "Allows `role <../core_concepts/glossary.html#role>`__ "
#~ "owners grant `can_set_my_account_detail`_ "
#~ "`permission <../core_concepts/glossary.html#permission>`__."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kSetMyAccountDetail``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kSetMyAccountDetail``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain that contains only"
#~ " can_grant_can_set_my_account_detail permission and "
#~ "two accounts for Alice and Bob in"
#~ " that domain. Alice can grant to "
#~ "Bob and revoke can_set_my_account_detail "
#~ "permission."
#~ msgstr ""

#~ msgid "can_grant_can_set_my_quorum"
#~ msgstr ""

#~ msgid ""
#~ "Allows `role <../core_concepts/glossary.html#role>`__ "
#~ "owners grant `can_set_my_quorum`_ `permission "
#~ "<../core_concepts/glossary.html#permission>`__."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kSetMyQuorum``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kSetMyQuorum``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain that contains only"
#~ " can_grant_can_set_my_quorum permission and two"
#~ " accounts for Alice and Bob in "
#~ "that domain. Alice can grant to "
#~ "Bob and revoke can_set_my_quorum permission."
#~ msgstr ""

#~ msgid "can_grant_can_transfer_my_assets"
#~ msgstr ""

#~ msgid ""
#~ "Allows `role <../core_concepts/glossary.html#role>`__ "
#~ "owners grant `can_transfer_my_assets`_ `permission"
#~ " <../core_concepts/glossary.html#permission>`__."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kTransferMyAssets``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kTransferMyAssets``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain that contains only"
#~ " can_grant_can_transfer_my_assets permission and "
#~ "two accounts for Alice and Bob in"
#~ " that domain. Alice can grant to "
#~ "Bob and revoke can_transfer_my_assets "
#~ "permission."
#~ msgstr ""

#~ msgid "can_add_peer"
#~ msgstr ""

#~ msgid ""
#~ "Allows adding `peers "
#~ "<../core_concepts/glossary.html#peer>`__ to the "
#~ "network."
#~ msgstr ""

#~ msgid ""
#~ "A new peer will be a valid "
#~ "participant in the next `consensus "
#~ "<../core_concepts/glossary.html#consensus>`__ round after"
#~ " an agreement on `transaction "
#~ "<../core_concepts/glossary.html#transaction>`__ containing "
#~ "\"addPeer\" `command "
#~ "<../core_concepts/glossary.html#command>`__."
#~ msgstr ""

#~ msgid "Related API method: `Add Peer <../api/commands.html#add-peer>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kAddPeer``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kAddPeer``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain that contains only"
#~ " can_add_peer permission and Alice account"
#~ " in that domain. Alice can add "
#~ "new peers."
#~ msgstr ""

#~ msgid "can_append_role"
#~ msgstr ""

#~ msgid ""
#~ "Allows appending `roles "
#~ "<../core_concepts/glossary.html#role>`__ to another "
#~ "`account <../core_concepts/glossary.html#account>`__."
#~ msgstr ""

#~ msgid ""
#~ "You can append only that role that"
#~ " has lesser or the same set of"
#~ " privileges as `transaction "
#~ "<../core_concepts/glossary.html#transaction>`__ creator."
#~ msgstr ""

#~ msgid "Related API method: `Append Role <../api/commands.html#append-role>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kAppendRole``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kAppendRole``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domian that contains "
#~ "can_append_role and can_add_peer permissions "
#~ "and two accounts for Alice and Bob"
#~ " in that domain. Admin creates the"
#~ " second role that contains only "
#~ "can_add_peer permission. Alice can append "
#~ "role to Bob."
#~ msgstr ""

#~ msgid "can_create_role"
#~ msgstr ""

#~ msgid ""
#~ "Allows creating a new `role "
#~ "<../core_concepts/glossary.html#role>`__ within a "
#~ "system."
#~ msgstr ""

#~ msgid ""
#~ "Possible set of `permissions "
#~ "<../core_concepts/glossary.html#permission>`__ for a "
#~ "new role is limited to those "
#~ "permissions that `transaction "
#~ "<../core_concepts/glossary.html#transaction>`__ creator "
#~ "has."
#~ msgstr ""

#~ msgid "Related API method: `Create Role <../api/commands.html#create-role>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kCreateRole``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kCreateRole``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain that contains only"
#~ " can_create_role permission and Alice "
#~ "account in that domain. Alice can "
#~ "create new roles."
#~ msgstr ""

#~ msgid "can_detach_role"
#~ msgstr ""

#~ msgid ""
#~ "Allows revoking a `role "
#~ "<../core_concepts/glossary.html#role>`__ from a "
#~ "user."
#~ msgstr ""

#~ msgid ""
#~ "Due to a known issue the "
#~ "permission allows to detach any role "
#~ "without limitations "
#~ "https://soramitsu.atlassian.net/browse/IR-1468"
#~ msgstr ""

#~ msgid "Related API method: `Detach Role <../api/commands.html#detach-role>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kDetachRole``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kDetachRole``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain that contains only"
#~ " can_detach_role permission and creates "
#~ "Alice account in that domain. Admin "
#~ "has two roles test_role and admin_role."
#~ " Alice can detach test_role from "
#~ "Admin account."
#~ msgstr ""

#~ msgid "can_add_my_signatory"
#~ msgstr ""

#~ msgid ""
#~ "`Permission <../core_concepts/glossary.html#permission>`__ "
#~ "that allows a specified `account "
#~ "<../core_concepts/glossary.html#account>`__ to add "
#~ "an extra public key to the another"
#~ " specified account."
#~ msgstr ""

#~ msgid ""
#~ "Related API method: `Add Signatory "
#~ "<../api/commands.html#add-signatory>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Grantable.kAddMySignatory``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Grantable_kAddMySignatory``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain that contains only"
#~ " can_grant_can_add_my_signatory permission and "
#~ "two accounts for Alice and Bob in"
#~ " that domain. Alice can grant to "
#~ "Bob can_add_my_signatory permission. Bob can"
#~ " add an extra key to Alice "
#~ "account."
#~ msgstr ""

#~ msgid "can_add_signatory"
#~ msgstr ""

#~ msgid ""
#~ "Allows linking additional public keys to"
#~ " `account <../core_concepts/glossary.html#account>`__."
#~ msgstr ""

#~ msgid ""
#~ "The corresponding `command "
#~ "<../core_concepts/glossary.html#command>`__ can be "
#~ "executed only for an account of "
#~ "`transaction <../core_concepts/glossary.html#transaction>`__ "
#~ "creator and only if that account "
#~ "has a `role <../core_concepts/glossary.html#role>`__"
#~ " with the `permission "
#~ "<../core_concepts/glossary.html#permission>`__."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kAddSignatory``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kAddSignatory``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain that contains only"
#~ " can_add_signatory permission and Alice "
#~ "account in that domain. Alice can "
#~ "add to own account additional keys."
#~ msgstr ""

#~ msgid "can_remove_my_signatory"
#~ msgstr ""

#~ msgid ""
#~ "`Permission <../core_concepts/glossary.html#permission>`__ "
#~ "that allows a specified `account "
#~ "<../core_concepts/glossary.html#account>`__ remove public"
#~ " key from the another specified "
#~ "account."
#~ msgstr ""

#~ msgid ""
#~ "Related API method: `Remove Signatory "
#~ "<../api/commands.html#remove-signatory>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Grantable.kRemoveMySignatory``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Grantable_kRemoveMySignatory``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain that contains "
#~ "can_add_signatory and can_grant_can_remove_my_signatory"
#~ " permissions and two accounts for "
#~ "Alice and Bob. Alice grants "
#~ "can_remove_my_signatory permission to Bob and"
#~ " adds additional key to own account."
#~ " Bob can remove one of Alice's "
#~ "keys."
#~ msgstr ""

#~ msgid "can_remove_signatory"
#~ msgstr ""

#~ msgid ""
#~ "Allows unlinking additional public keys "
#~ "from an `account "
#~ "<../core_concepts/glossary.html#account>`__."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kRemoveSignatory``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kRemoveSignatory``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domian that contains "
#~ "can_remove_signatory permission and Alice "
#~ "account in that domain. Admin adds "
#~ "an extra key to Alice account. "
#~ "Alice can remove one of the keys."
#~ msgstr ""

#~ msgid "can_set_my_quorum"
#~ msgstr ""

#~ msgid ""
#~ "`Permission <../core_concepts/glossary.html#permission>`__ "
#~ "that allows a specified `account "
#~ "<../core_concepts/glossary.html#account>`__ to set "
#~ "`quorum <../core_concepts/glossary.html#quorum>`__ for "
#~ "the another specified account."
#~ msgstr ""

#~ msgid "Account should have greater or equal amount of keys than quorum."
#~ msgstr ""

#~ msgid ""
#~ "Related API method: `Set Account Quorum"
#~ " <../api/commands.html#set-account-quorum>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Grantable.kSetMyQuorum``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Grantable_kSetMyQuorum``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain that contains "
#~ "can_grant_can_set_my_quorum and can_add_signatory "
#~ "permissions and create two accounts for"
#~ " Alice and Bob in that domain. "
#~ "Alice grants to Bob can_set_my_qourum "
#~ "permission and adds an extra key "
#~ "to account. Bob can set quorum for"
#~ " Alice."
#~ msgstr ""

#~ msgid "can_set_quorum"
#~ msgstr ""

#~ msgid "Allows setting `quorum <../core_concepts/glossary.html#quorum>`__."
#~ msgstr ""

#~ msgid ""
#~ "At least the same number (or more)"
#~ " of public keys should be already "
#~ "linked to an `account "
#~ "<../core_concepts/glossary.html#account>`__."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kSetQuorum``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kSetQuorum``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain that contains only"
#~ " can_set_quorum permission and creates "
#~ "Alice account in that domain. Admin "
#~ "adds an extra key for Alice "
#~ "account. Alice can set quorum equals "
#~ "two."
#~ msgstr ""

#~ msgid "Query-related permissions"
#~ msgstr ""

#~ msgid "can_get_all_acc_detail"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting all the details set "
#~ "to any `account "
#~ "<../core_concepts/glossary.html#account>`__ within the "
#~ "system."
#~ msgstr ""

#~ msgid ""
#~ "Related API method: `Get Account Detail"
#~ " <../api/queries.html#get-account-detail>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetAllAccDetail``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetAllAccDetail``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in a "
#~ "diffrerent domain that has only "
#~ "can_get_all_acc_detail permission. Alice can "
#~ "access details set to Admin account."
#~ msgstr ""

#~ msgid "can_get_all_accounts"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting `account "
#~ "<../core_concepts/glossary.html#account>`__ information: "
#~ "`quorum <../core_concepts/glossary.html#quorum>`__ and "
#~ "all the details related to the "
#~ "account."
#~ msgstr ""

#~ msgid ""
#~ "With this `permission "
#~ "<../core_concepts/glossary.html#permission>`__, `query "
#~ "<../core_concepts/glossary.html#query>`__ creator can "
#~ "get information about any account within"
#~ " a system."
#~ msgstr ""

#~ msgid ""
#~ "All the details (set by the "
#~ "account owner or owners of other "
#~ "accounts) will be returned."
#~ msgstr ""

#~ msgid "Related API method: `Get Account <../api/queries.html#get-account>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetAllAccounts``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetAllAccounts``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in a "
#~ "different domain that has only "
#~ "can_get_all_accounts permission. Alice can "
#~ "access account information of Admin."
#~ msgstr ""

#~ msgid "can_get_domain_acc_detail"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting all the details set "
#~ "to any `account "
#~ "<../core_concepts/glossary.html#account>`__ within the "
#~ "same `domain <../core_concepts/glossary.html#domain>`__"
#~ " as a domain of `query "
#~ "<../core_concepts/glossary.html#query>`__ creator account."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetDomainAccDetail``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetDomainAccDetail``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in the "
#~ "same domain that has only "
#~ "can_get_domain_acc_detail permission. Alice can "
#~ "get details set to Admin account."
#~ msgstr ""

#~ msgid "can_get_domain_accounts"
#~ msgstr ""

#~ msgid ""
#~ "With this `permission "
#~ "<../core_concepts/glossary.html#permission>`__, `query "
#~ "<../core_concepts/glossary.html#query>`__ creator can "
#~ "get information only about accounts from"
#~ " the same `domain "
#~ "<../core_concepts/glossary.html#domain>`__."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetDomainAccounts``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetDomainAccounts``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in the "
#~ "same domain that has only "
#~ "can_get_domain_accounts. Alice can access "
#~ "account information of Admin."
#~ msgstr ""

#~ msgid "can_get_my_acc_detail"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting all the details set "
#~ "to the `account "
#~ "<../core_concepts/glossary.html#account>`__ of `query "
#~ "<../core_concepts/glossary.html#query>`__ creator."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetMyAccDetail``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetMyAccDetail``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in the "
#~ "domain that has only can_get_my_acc_detail "
#~ "permission. Alice can get details set"
#~ " to own account."
#~ msgstr ""

#~ msgid "can_get_my_account"
#~ msgstr ""

#~ msgid ""
#~ "With this `permission "
#~ "<../core_concepts/glossary.html#permission>`__, `query "
#~ "<../core_concepts/glossary.html#query>`__ creator can "
#~ "get information only about own account."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetMyAccount``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetMyAccount``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in the "
#~ "domain that has only can_get_my_account "
#~ "permission. Alice can access own account"
#~ " information."
#~ msgstr ""

#~ msgid "can_get_all_acc_ast"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting a balance of `assets "
#~ "<../core_concepts/glossary.html#asset>`__ on any "
#~ "`account <../core_concepts/glossary.html#account>`__ "
#~ "within the system."
#~ msgstr ""

#~ msgid ""
#~ "`Query <../core_concepts/glossary.html#query>`__ response"
#~ " will contain information about all "
#~ "the assets that ever been assigned "
#~ "to an account."
#~ msgstr ""

#~ msgid ""
#~ "Related API method: `Get Account Assets"
#~ " <../api/queries.html#get-account-assets>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetAllAccAst``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetAllAccAst``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in a "
#~ "different domain that has only "
#~ "can_get_all_acc_ast permission. Alice can "
#~ "access assets balance on Admin account."
#~ msgstr ""

#~ msgid "can_get_domain_acc_ast"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting a balance of specified"
#~ " `asset <../core_concepts/glossary.html#asset>`__ on"
#~ " any `account "
#~ "<../core_concepts/glossary.html#account>`__ within the "
#~ "same `domain <../core_concepts/glossary.html#domain>`__"
#~ " as a domain of `query "
#~ "<../core_concepts/glossary.html#query>`__ creator account."
#~ msgstr ""

#~ msgid ""
#~ "Query response will contain information "
#~ "about all the assets that ever "
#~ "been assigned to an account."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetDomainAccAst``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetDomainAccAst``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in the "
#~ "same domain that has only "
#~ "can_get_domain_acc_ast permission. Alice can "
#~ "access assets balance on Admin account."
#~ msgstr ""

#~ msgid "can_get_my_acc_ast"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting a balance of specified"
#~ " `asset <../core_concepts/glossary.html#asset>`__ on"
#~ " `account <../core_concepts/glossary.html#account>`__ "
#~ "of `query <../core_concepts/glossary.html#query>`__ "
#~ "creator."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetMyAccAst``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetMyAccAst``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in a "
#~ "domain that has only can_get_my_acc_ast "
#~ "permission. Alice can access assets "
#~ "balance on own account."
#~ msgstr ""

#~ msgid "can_get_all_acc_ast_txs"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting `transactions "
#~ "<../core_concepts/glossary.html#transaction>`__ associated "
#~ "with a specified `asset "
#~ "<../core_concepts/glossary.html#asset>`__ and any "
#~ "`account <../core_concepts/glossary.html#account>`__ "
#~ "within the system."
#~ msgstr ""

#~ msgid "Incoming asset transfers will also appear in the query response."
#~ msgstr ""

#~ msgid ""
#~ "Related API method: `Get Account Asset"
#~ " Transactions <../api/queries.html#get-account-"
#~ "asset-transactions>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetAllAccAstTxs``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetAllAccAstTxs``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in a "
#~ "different domain that has "
#~ "can_get_all_acc_ast_txs, can_receive and "
#~ "can_transfer permissions. Admin issues some"
#~ " amount of coins and transfers them"
#~ " to Alice. Alice can query all "
#~ "transactions related to coins and Admin"
#~ " account."
#~ msgstr ""

#~ msgid "can_get_domain_acc_ast_txs"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting `transactions "
#~ "<../core_concepts/glossary.html#transaction>`__ associated "
#~ "with a specified `asset "
#~ "<../core_concepts/glossary.html#asset>`__ and an "
#~ "`account <../core_concepts/glossary.html#account>`__ from"
#~ " the same `domain "
#~ "<../core_concepts/glossary.html#domain>`__ as `query "
#~ "<../core_concepts/glossary.html#query>`__ creator."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetDomainAccAstTxs``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetDomainAccAstTxs``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice in the same "
#~ "domain that has only "
#~ "can_get_domain_acc_ast_txs permission. Admin issues"
#~ " some amount of coins and transfers"
#~ " them to Alice. Alice can query "
#~ "all transactions related to coins and"
#~ " Admin account."
#~ msgstr ""

#~ msgid "can_get_my_acc_ast_txs"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting `transactions "
#~ "<../core_concepts/glossary.html#transaction>`__ associated "
#~ "with the `account "
#~ "<../core_concepts/glossary.html#account>`__ of `query "
#~ "<../core_concepts/glossary.html#query>`__ creator and "
#~ "specified `asset "
#~ "<../core_concepts/glossary.html#asset>`__."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetMyAccAstTxs``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetMyAccAstTxs``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in a "
#~ "domain that has only can_get_my_acc_ast_txs"
#~ " permission. Admin issues some amount "
#~ "of coins and transfers them to "
#~ "Alice. Alice can query all transactions"
#~ " related to coins and own account."
#~ msgstr ""

#~ msgid "can_get_all_acc_txs"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting all `transactions "
#~ "<../core_concepts/glossary.html#transaction>`__ issued by"
#~ " any `account "
#~ "<../core_concepts/glossary.html#account>`__ within the "
#~ "system."
#~ msgstr ""

#~ msgid ""
#~ "Incoming asset transfer inside a "
#~ "transaction would NOT lead to an "
#~ "appearance of the transaction in the "
#~ "command output."
#~ msgstr ""

#~ msgid ""
#~ "Related API method: `Get Account "
#~ "Transactions <../api/queries.html#get-account-"
#~ "transactions>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetAllAccTxs``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetAllAccTxs``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in a "
#~ "different domain that has only "
#~ "can_get_all_acc_txs permiison. Alice can "
#~ "request all the transactions issues by"
#~ " Admin."
#~ msgstr ""

#~ msgid "can_get_domain_acc_txs"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting all `transactions "
#~ "<../core_concepts/glossary.html#transaction>`__ issued by"
#~ " any `account "
#~ "<../core_concepts/glossary.html#account>`__ from the "
#~ "same `domain <../core_concepts/glossary.html#domain>`__"
#~ " as `query <../core_concepts/glossary.html#query>`__"
#~ " creator."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetDomainAccTxs``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetDomainAccTxs``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in the "
#~ "same domain that has only "
#~ "can_get_domain_acc_txs permission. Alice can "
#~ "request all the transactions issued by"
#~ " Admin."
#~ msgstr ""

#~ msgid "can_get_my_acc_txs"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting all `transactions "
#~ "<../core_concepts/glossary.html#transaction>`__ issued by"
#~ " an `account "
#~ "<../core_concepts/glossary.html#account>`__ of `query "
#~ "<../core_concepts/glossary.html#query>`__ creator."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetMyAccTxs``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetMyAccTxs``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in a "
#~ "domain that has only can_get_my_acc_txs "
#~ "permission. Alice can get all "
#~ "transactions issued by own account."
#~ msgstr ""

#~ msgid "can_read_assets"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting information about `asset "
#~ "<../core_concepts/glossary.html#asset>`__ precision."
#~ msgstr ""

#~ msgid ""
#~ "Related API method: `Get Asset Info "
#~ "<../api/queries.html#get-asset-info>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kReadAssets``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kReadAssets``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in a "
#~ "domain that has can_read_assets permissions."
#~ " Alice can query information about "
#~ "any asset."
#~ msgstr ""

#~ msgid "can_get_blocks"
#~ msgstr ""

#~ msgid ""
#~ "Allows subscription to the stream of "
#~ "accepted `blocks "
#~ "<../core_concepts/glossary.html#block>`__."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetBlocks``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetBlocks``"
#~ msgstr ""

#~ msgid "can_get_roles"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting a list of `roles "
#~ "<../core_concepts/glossary.html#role>`__ within the "
#~ "system. Allows getting a list of "
#~ "`permissions <../core_concepts/glossary.html#permission>`__ "
#~ "associated with a role."
#~ msgstr ""

#~ msgid ""
#~ "Related API methods: `Get Roles "
#~ "<../api/queries.html#get-roles>`__, `Get Role "
#~ "Permissions <../api/queries.html#get-role-"
#~ "permissions>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetRoles``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetRoles``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in a "
#~ "domain that has can_get_roles permission. "
#~ "Alice can query list of all "
#~ "existing roles. Alice can query list "
#~ "of permissions contained in any role."
#~ msgstr ""

#~ msgid "can_get_all_signatories"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting a list of public "
#~ "keys linked to an `account "
#~ "<../core_concepts/glossary.html#account>`__ within the "
#~ "system."
#~ msgstr ""

#~ msgid ""
#~ "Related API method: `Get Signatories "
#~ "<../api/queries.html#get-signatories>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetAllSignatories``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetAllSignatories``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in a "
#~ "different domain that has only "
#~ "can_get_all_signatories permission. Alice can "
#~ "query a list of public keys "
#~ "related to Admin account."
#~ msgstr ""

#~ msgid "can_get_domain_signatories"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting a list of public "
#~ "keys of any `account "
#~ "<../core_concepts/glossary.html#account>`__ within the "
#~ "same `domain <../core_concepts/glossary.html#domain>`__"
#~ " as the domain of `query "
#~ "<../core_concepts/glossary.html#query>`__ creator account."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetDomainSignatories``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetDomainSignatories``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in the "
#~ "same domain that has only "
#~ "can_get_domain_signatories permission. Alice can "
#~ "query a list of public keys "
#~ "related to Admin account."
#~ msgstr ""

#~ msgid "can_get_my_signatories"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting a list of public "
#~ "keys of `query "
#~ "<../core_concepts/glossary.html#query>`__ creator `account"
#~ " <../core_concepts/glossary.html#account>`__."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetMySignatories``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetMySignatories``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in a "
#~ "domain that has only can_get_my_signatories"
#~ " permission. Alice can query a list"
#~ " of public keys related to own "
#~ "account."
#~ msgstr ""

#~ msgid "can_get_all_txs"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting any `transaction "
#~ "<../core_concepts/glossary.html#transaction>`__ by hash."
#~ msgstr ""

#~ msgid ""
#~ "Related API method: `Get Transactions "
#~ "<../api/queries.html#get-transactions>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetAllTxs``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetAllTxs``"
#~ msgstr ""

#~ msgid ""
#~ "Admin issues several transactions and "
#~ "creates Alice account in a different "
#~ "domain that has only can_get_all_txs "
#~ "permission. Alice (knowing transactions "
#~ "hashes) can query transactions issued by"
#~ " Admin Account."
#~ msgstr ""

#~ msgid "can_get_my_txs"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting `transaction "
#~ "<../core_concepts/glossary.html#transaction>`__ (that was"
#~ " issued by `query "
#~ "<../core_concepts/glossary.html#query>`__ creator) by "
#~ "hash."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetMyTxs``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetMyTxs``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in a "
#~ "different domain. Alice (knowing transactions"
#~ " hashes) issues several transactions. Alice"
#~ " can query own transactions."
#~ msgstr ""

#~ msgid "Supplementary Sources"
#~ msgstr ""

#~ msgid "commons.py"
#~ msgstr ""

#~ msgid "consts.py"
#~ msgstr ""

