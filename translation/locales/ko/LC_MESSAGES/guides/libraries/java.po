
msgid ""
msgstr ""
"Project-Id-Version: Hyperledger Iroha Documentation\n"
"Report-Msgid-Bugs-To: EMAIL@ADDRESS\n"
"POT-Creation-Date: 2018-12-16 20:34+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ko\n"
"Language-Team: ko <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.3\n"

#: ../iroha/docs/source/guides/libraries/java.rst:2
msgid "Java Library"
msgstr ""

#: ../iroha/docs/source/guides/libraries/java.rst:5
#: ../iroha/docs/source/guides/libraries/java.rst:130
#, fuzzy
msgid "Prerequisites"
msgstr "요구 사항"

#: ../iroha/docs/source/guides/libraries/java.rst:7
msgid "Java 6"
msgstr ""

#: ../iroha/docs/source/guides/libraries/java.rst:8
msgid "Gradle"
msgstr ""

#: ../iroha/docs/source/guides/libraries/java.rst:11
msgid "Build Process"
msgstr ""

#: ../iroha/docs/source/guides/libraries/java.rst:13
msgid "Clone Iroha repository"
msgstr ""

#: ../iroha/docs/source/guides/libraries/java.rst:20
msgid ""
"For the latest version checkout a ``develop`` branch by adding ``-b "
"develop`` parameter."
msgstr ""

#: ../iroha/docs/source/guides/libraries/java.rst:23
msgid ""
"Now we need to build our Java native library. Run "
"``example/java/build_library.sh``, which will take care of it."
msgstr ""

#: ../iroha/docs/source/guides/libraries/java.rst:31
msgid ""
"``build_library.sh`` script creates a ``dist`` folder with files, needed "
"in :ref:`java-how-to-use` section."
msgstr ""

#: ../iroha/docs/source/guides/libraries/java.rst:37
msgid "How to Use"
msgstr ""

#: ../iroha/docs/source/guides/libraries/java.rst:39
msgid "There are two ways of adding the Java library to your project:"
msgstr ""

#: ../iroha/docs/source/guides/libraries/java.rst:41
msgid "Import Java bindings through Maven Central"
msgstr ""

#: ../iroha/docs/source/guides/libraries/java.rst:42
msgid "Compile Java bindings manually"
msgstr ""

#: ../iroha/docs/source/guides/libraries/java.rst:44
msgid "Both options are described in the following sections."
msgstr ""

#: ../iroha/docs/source/guides/libraries/java.rst:47
msgid "Import Java Bindings from Maven Central"
msgstr ""

#: ../iroha/docs/source/guides/libraries/java.rst:49
msgid ""
"First of all, you need to copy ``example/java/dist/libirohajava.jnilib`` "
"to the root folder of your project."
msgstr ""

#: ../iroha/docs/source/guides/libraries/java.rst:56
msgid ""
"If you use **Gradle**, add the following line to your ``build.gradle`` "
"file:"
msgstr ""

#: ../iroha/docs/source/guides/libraries/java.rst:58
#: ../iroha/docs/source/guides/libraries/java.rst:98
msgid "build.gradle"
msgstr ""

#: ../iroha/docs/source/guides/libraries/java.rst:65
#: ../iroha/docs/source/guides/libraries/java.rst:114
msgid "pom.xml"
msgstr ""

#: ../iroha/docs/source/guides/libraries/java.rst:75
msgid ""
"Set the latest version number from our `Maven repository "
"<https://mvnrepository.com/artifact/jp.co.soramitsu/iroha>`_"
msgstr ""

#: ../iroha/docs/source/guides/libraries/java.rst:79
msgid "Compiling Java Bindings Manually"
msgstr ""

#: ../iroha/docs/source/guides/libraries/java.rst:81
msgid ""
"Java bindings were compiled with ``example/java/build_library.sh`` in "
"`Build Process` section. You need to copy "
"``example/java/dist/libirohajava.jnilib`` to the root folder of your "
"project:"
msgstr ""

#: ../iroha/docs/source/guides/libraries/java.rst:89
msgid ""
"If you use **Gradle**, you need to copy "
"``example/java/dist/iroha_lib.jar`` to the ``libs`` folder of your "
"project"
msgstr ""

#: ../iroha/docs/source/guides/libraries/java.rst:96
msgid "Then please add the following to your ``build.gradle`` file:"
msgstr ""

#: ../iroha/docs/source/guides/libraries/java.rst:112
msgid "After it please add this to your ``pom.xml``:"
msgstr ""

#: ../iroha/docs/source/guides/libraries/java.rst:125
msgid "Example code"
msgstr ""

#: ../iroha/docs/source/guides/libraries/java.rst:126
msgid ""
"Explore ``example/java/TransactionExample.java`` file to get an idea of "
"how to work with a library."
msgstr ""

#: ../iroha/docs/source/guides/libraries/java.rst:131
msgid ""
"To run this example, you need an Iroha node up and running. Please check "
"out :ref:`getting-started` if you want to learn how to start it."
msgstr ""

#: ../iroha/docs/source/guides/libraries/java.rst:135
msgid "Running the Example"
msgstr ""

#: ../iroha/docs/source/guides/libraries/java.rst:136
msgid "To start the example, you need to build the example:"
msgstr ""

#: ../iroha/docs/source/guides/libraries/java.rst:143
msgid "Now, to run this example please write:"
msgstr ""

#~ msgid "Configuration"
#~ msgstr "설정"

#~ msgid ""
#~ "In this section we will understand "
#~ "how to configure Iroha. Let's take "
#~ "a look at ``example/config.sample``"
#~ msgstr "이 섹션에서는 Iroha를 설정하는 방법에 대해 설명합니다. 우선 ``example/config.sample``을 봅시다."

#~ msgid ""
#~ "As you can see, configuration file "
#~ "is a valid ``json`` structure. Let's "
#~ "go line-by-line and understand "
#~ "what every parameter means."
#~ msgstr ""
#~ "위에서 확인할 수 있듯이, 설정 파일은 ``json`` "
#~ "파일입니다. 한 줄 한 줄 확인해보면서 모든 "
#~ "파라미터들이 무엇을 의미하는지 알아봅시다."

#~ msgid "Deployment-specific parameters"
#~ msgstr "배포(Deployment)관련 파라미터"

#~ msgid "``block_store_path`` sets path to the folder where blocks are stored."
#~ msgstr "``block_store_path``은 블록을 저장할 폴더의 경로를 설정합니다."

#~ msgid ""
#~ "``torii_port`` sets the port for "
#~ "external communications. Queries and "
#~ "transactions are sent here."
#~ msgstr "``torii_port``는 외부 통신을 위한 포트를 설정합니다. 쿼리와 트랜젝션은 여기를 통해 전송됩니다."

#~ msgid ""
#~ "``internal_port`` sets the port for "
#~ "internal communications: ordering service, "
#~ "consensus and block loader."
#~ msgstr ""
#~ "``internal_port``는 오더링 서비스(Ordering Service)나 "
#~ "합의(Consensus), 블록 로더(Block Loader)와 같은 "
#~ "내부 통신을 위한 포트를 설정합니다."

#~ msgid ""
#~ "``pg_opt`` is used for setting "
#~ "credentials of PostgreSQL: hostname, port, "
#~ "username and password."
#~ msgstr ""
#~ "``pg_opt``는 PostgreSQL의 자격증명(Credentials)를 설정하는 "
#~ "데 사용됩니다. 호스트 이름, 포트, 유저 이름, "
#~ "패스워드를 설정할 수 있습니다."

#~ msgid "Environment-specific parameters"
#~ msgstr "환경(Environment) 관련 파라미터"

#~ msgid ""
#~ "``max_proposal_size`` is the maximum amount"
#~ " of transactions that can be in "
#~ "one proposal, and as a result in"
#~ " a single block as well. So, by"
#~ " changing this value you define the"
#~ " size of potential block. For a "
#~ "starter you can stick to ``10``. "
#~ "However, we recommend to increase this"
#~ " number if you have a lot of"
#~ " transactions per second."
#~ msgstr ""
#~ "``max_proposal_size``는 한 프로포절에 포함될 수 있는"
#~ " 트랜젝션의 수의 최대값을 설정합니다. 이는 하나의 "
#~ "블록에 들어갈 수 있는 트랜젝션의 수의 최대값을 "
#~ "의미하기도 합니다. 이 값을 바꿈으로써 블록의 크기를 "
#~ "설정할 수 있습니다. 처음에는 ``10``을 사용해도 되지만"
#~ " 초당 트랜젝션의 수를 늘리기 위해서는 이 값을 "
#~ "크게 하는 것을 추천합니다."

#~ msgid ""
#~ "``proposal_delay`` is a maximum waiting "
#~ "time in milliseconds before emitting a"
#~ " new proposal. Proposal is emitted if"
#~ " the ``max_proposal_size`` is reached or"
#~ " ``proposal_delay`` milliseconds had passed. "
#~ "You can start with ``5000`` and "
#~ "increase this number if you have a"
#~ " lot of transactions per second since"
#~ " it is likely that with an "
#~ "intense load (over 100 transactions per"
#~ " second) and low value of "
#~ "``proposal_delay`` there will be many "
#~ "proposals of small size."
#~ msgstr ""
#~ "``proposal_delay``는 새로운 프로포절을 내보내기까지 밀리세컨드 "
#~ "단위의 최대 대기 시간을 의미합니다. 프로포절은 "
#~ "``max_proposal_size`` ````"

#~ msgid ""
#~ "``vote_delay`` is a waiting time in "
#~ "milliseconds before sending vote to the"
#~ " next peer. Optimal value depends "
#~ "heavily on the amount of Iroha "
#~ "peers in the network (higher amount "
#~ "of nodes requires longer ``vote_delay``). "
#~ "We recommend to start with 100-1000 "
#~ "milliseconds."
#~ msgstr ""
#~ "``vote_delay``는 다음 피어에게 투표를 보내기까지의 밀리세컨드"
#~ " 단위의 대기시간입니다. 이 값은 네트워크 내의 "
#~ "Iroha 피어의 수에 따라 결정하는 것이 좋습니다 "
#~ "(노드의 수가 많아질수록 더 긴 ``vote_delay``가 "
#~ "필요합니다). 100-1000 밀리 세컨드로 시작하는 것을 "
#~ "추천합니다."

#~ msgid ""
#~ "``load_delay`` is a waiting time in "
#~ "milliseconds before loading committed block"
#~ " from next peer. We recommend setting"
#~ " this number the same value as "
#~ "``proposal_delay`` or even higher."
#~ msgstr ""
#~ "``load_delay``는 다음 피어로부터 커밋된 블록을 로딩하기까지"
#~ " 밀리세컨드 단위의 대기 시간입니다. 이 값을 "
#~ "``proposal_delay``값과 같거나 더 크게 설정하는 것을"
#~ " 추천합니다."

#~ msgid "Commands"
#~ msgstr "커맨드"

#~ msgid "Add asset quantity"
#~ msgstr "에셋 수량 늘리기"

#~ msgid "Add peer"
#~ msgstr "피어 추가하기"

#~ msgid "Add signatory"
#~ msgstr "서명자 더하기"

#~ msgid "Append role"
#~ msgstr "역할 추가하기"

#~ msgid "Create account"
#~ msgstr "어커운트 생성하기"

#~ msgid "Create asset"
#~ msgstr "에셋 생성하기"

#~ msgid "Create domain"
#~ msgstr "도메인 생성하기"

#~ msgid "Create role"
#~ msgstr "역할 생성하기"

#~ msgid "Detach role"
#~ msgstr "역할 제거하기"

#~ msgid "Grant permission"
#~ msgstr "퍼미션 부여하기"

#~ msgid "Revoke permission"
#~ msgstr "퍼미션 취소하기"

#~ msgid "Set account detail"
#~ msgstr "어카운트 세부 사항 설정하기"

#~ msgid "Set account quorum"
#~ msgstr "어카운트 정족수(quorum) 설정하기"

#~ msgid "Subtract asset quantity"
#~ msgstr "에셋 수량 줄이기"

#~ msgid "Transfer asset"
#~ msgstr "에셋 보내기"

#~ msgid "С++ library"
#~ msgstr "C++ 라이브러리"

#~ msgid ""
#~ "This section only contains code "
#~ "reference (autogenerated docs are possible "
#~ "with a description of arguments and "
#~ "return values)"
#~ msgstr "이 섹션은 코드 레퍼런스만 포함하고 있습니다.(자동으로 생성된 문서는 인수와 리턴값에 대한 설명이 있습니다)"

#~ msgid "Iroha API reference"
#~ msgstr "Iroha API 레퍼런스"

#~ msgid ""
#~ "In API section we will take a "
#~ "look at building blocks of an "
#~ "application interacting with Iroha. We "
#~ "will overview commands and queries that"
#~ " the system have, and the set "
#~ "of client libraries encompassing transport "
#~ "and application layer logic."
#~ msgstr ""
#~ "이 API 섹션에서 Iroha와 상호작용하는 어플리케이션의 "
#~ "블록을 만드는 과정을 살펴볼 것입니다. 명령어와 쿼리를 "
#~ "간략하게 살펴본 후 전송 레이어와 어플리케이션 레이어를 "
#~ "포함하는 클라이언트 라이브러리에 대해 알아볼 것입니다."

#~ msgid "Table of contents"
#~ msgstr "목차"

#~ msgid "Java library"
#~ msgstr "자바 라이브러리"

#~ msgid "NodeJS library"
#~ msgstr "NodeJS 라이브러리"

#~ msgid "Objective-C library"
#~ msgstr "Objective-C 라이브러리"

#~ msgid "Python library"
#~ msgstr "파이썬 라이브러리"

#~ msgid "Queries"
#~ msgstr "쿼리"

#~ msgid "Get account"
#~ msgstr "어커운트 조회하기"

#~ msgid "Get signatories"
#~ msgstr "서명자 얻기"

#~ msgid "Get transactions"
#~ msgstr "트랜젝션 얻기"

#~ msgid "Get account transactions"
#~ msgstr "어커운트의 트랜젝션 얻기"

#~ msgid "Get account asset transactions"
#~ msgstr "어커운트의 에셋의 트랜젝션 얻기"

#~ msgid "Get account assets"
#~ msgstr "어커운트 에셋 얻기"

#~ msgid "Get asset info"
#~ msgstr "에셋 정보 얻기"

#~ msgid "Get roles"
#~ msgstr "역할 얻기"

#~ msgid "Get role permissions"
#~ msgstr "역할 권한 얻기"

#~ msgid "Swift library"
#~ msgstr "Swift 라이브러리"

#~ msgid "Contribution"
#~ msgstr "기여"

#~ msgid "Code of conduct"
#~ msgstr "행동강령"

#~ msgid "Process"
#~ msgstr "프로세스"

#~ msgid "Communication"
#~ msgstr "커뮤니케이션"

#~ msgid "Issue tracker"
#~ msgstr "이슈 트래커"

#~ msgid "A term"
#~ msgstr ""

#~ msgid "B term"
#~ msgstr ""

#~ msgid "C term"
#~ msgstr ""

#~ msgid "Remaining parts (WSV, etc.)"
#~ msgstr "남은 부분(WSV 외)"

#~ msgid "Core concepts"
#~ msgstr "주요 개념"

#~ msgid ""
#~ "Why Iroha runs in a network? How"
#~ " to understand the objects inside and"
#~ " outside the system? How peers in "
#~ "the network collaborate and decide which"
#~ " data to put into the blockchain? "
#~ "We will look through the basics of"
#~ " Iroha in this section."
#~ msgstr ""
#~ "왜 Iroha는 네트워크에서 실행되고 있을까요? 시스템 내외의"
#~ " 여러 객체를 어떻게 이해해야 할까요? 네트워크의 "
#~ "피어들은 어떻게 작동하며 어떤 데이터를 `블록체인`에 넣을지"
#~ " 결정할까요? 이 섹션에서는 Iroha의 기초적인 개념에 "
#~ "대해 살펴보고자 합니다."

#~ msgid "Is having an account in Iroha means being a user?"
#~ msgstr "Iroha 상에서 계정(Account)를 가지고 있다는 것이 유저가 된다는 것을 의미할까요?"

#~ msgid "Are there differences compared to client-server systems?"
#~ msgstr "클라이언트-서버 시스템과 비교할 때 차이점이 있을까요?"

#~ msgid "Assets, domains and other internal objects"
#~ msgstr "에셋, 도메인, 다른 내부 객체들"

#~ msgid "Does everyone have to maintain their own peer?"
#~ msgstr "모든 사람이 각자의 피어들을 관리해야 합니까?"

#~ msgid "How peers communicate with each other?"
#~ msgstr "피어들은 서로 어떻게 통신할까요?"

#~ msgid "ER model"
#~ msgstr "ER 모델"

#~ msgid "Transaction"
#~ msgstr "트랜젝션"

#~ msgid "Transaction statuses"
#~ msgstr "트랜젝션 상태"

#~ msgid "Query"
#~ msgstr "쿼리"

#~ msgid "Validation"
#~ msgstr "검증"

#~ msgid "Stateless"
#~ msgstr "Stateless"

#~ msgid "Stateful"
#~ msgstr "Stateful"

#~ msgid "Glossary"
#~ msgstr "용어 사전"

#~ msgid "Getting Started"
#~ msgstr "시작하기"

#~ msgid ""
#~ "In this guide, we will create a"
#~ " very basic Iroha network, launch it,"
#~ " create a couple of transactions, and"
#~ " check the data written in the "
#~ "ledger. To keep things simple, we "
#~ "will use Docker."
#~ msgstr ""
#~ "이 가이드에서는 간단한 Iroha 네트워크를 만들고 실행시키며"
#~ " 몇 개의 트랜젝션을 만들어 볼 것입니다. 또한 "
#~ "원장(Ledger)에 쓰인 데이터를 확인해볼 것입니다. 가이드 "
#~ "진행을 쉽게 하기 위해 Docker를 사용할 것입니다."

#~ msgid ""
#~ "Ledger is the synonym for a "
#~ "blockchain, and Hyperledger Iroha is "
#~ "known also as Distributed Ledger "
#~ "Technology — which in essence is "
#~ "the same as \"blockchain framework\". "
#~ "You can check the rest of "
#~ "terminology used in the Glossary "
#~ "section."
#~ msgstr ""
#~ "원장은 블록체인과 동일한 의미를 가지고 있으며 "
#~ "Hyperledger Iroha는 분산원장기술(Distributed Ledger "
#~ "Technology)로도 알려져 있습니다. 이는 본질적으로 `블록체인"
#~ " 프레임워크`와 동일한 의미입니다. 용어사전 섹션에서 나머지 "
#~ "용어에 대해 확인할 수 있습니다."

#~ msgid ""
#~ "For this guide, you need a "
#~ "computer running Unix-like system with"
#~ " ``docker`` installed. You can read "
#~ "how to install it on a `Docker's"
#~ " website <https://www.docker.com/community-edition/>`_."
#~ msgstr ""
#~ "이 가이드를 따라하기 위해서는 컴퓨터에 Unix 계열의 "
#~ "시스템에 ``docker``가 설치되어 있어야 합니다. docker를"
#~ " 설치하는 방법은 `Docker 웹사이트 "
#~ "<https://www.docker.com/community-edition/>` 를 참고하시면"
#~ " 됩니다."

#~ msgid ""
#~ "Please note that you can use Iroha"
#~ " without ``docker`` as well. You can"
#~ " read about it in other parts "
#~ "of documentation."
#~ msgstr ""
#~ "``docker``를 쓰지 않고 Iroha를 사용할 수 "
#~ "있습니다. 이에 대한 자세한 사항은 문서의 다른 "
#~ "섹션을 참고하시면 됩니다."

#~ msgid "Starting Iroha Node"
#~ msgstr "Iroha 노드 시작하기"

#~ msgid "Creating a Docker Network"
#~ msgstr "도커 네트워크 생성하기"

#~ msgid ""
#~ "To operate, Iroha requires a "
#~ "``PostgreSQL`` database. Let's start with "
#~ "creating a Docker network, so containers"
#~ " for Postgres and Iroha can run "
#~ "on the same virtual network and "
#~ "successfully communicate. In this guide "
#~ "we will call it ``iroha-network``, "
#~ "but you can use any name. In "
#~ "your terminal write following command:"
#~ msgstr ""
#~ "Iroha는 ``PostgreSQL`` 데이터베이스를 필요로 합니다. "
#~ "우선 도커 네트워크를 생성하여 Postgres와 Iroha가 "
#~ "같은 가상 네트워크에서 실행되어 성공적으로 통신할 수 "
#~ "있게 합니다. 이 가이드에서는 방금 생성한 가상 "
#~ "네트워크를 ``Iroha-network``라고 부를 것이지만 원하는"
#~ " 이름으로 설정해도 됩니다. 터미널을 열어 다음 커맨드를"
#~ " 입력하세요."

#~ msgid "Starting PostgreSQL Container"
#~ msgstr "PostgreSQL 컨테이너 시작하기"

#~ msgid ""
#~ "Now we need to run ``PostgreSQL`` "
#~ "in a container, attach it to the"
#~ " network you have created before, and"
#~ " expose ports for communication:"
#~ msgstr ""
#~ "이제 컨테이너 안에서 ``PostgreSQL``을 실행하고 이를 "
#~ "방금 생성한 네트워크에 할당(attach)하고 통신을 위한 "
#~ "포트를 열어야 합니다."

#~ msgid ""
#~ "If you already have Postgres running "
#~ "on a host system on default port"
#~ " (5432), then you should pick another"
#~ " free port that will be occupied. "
#~ "For example, 5433: ``-p 5433:5432 \\``"
#~ msgstr ""
#~ "만약 Postgres가 호스트의 디폴트 포트(5432)에서 이미 "
#~ "실행되고 있다면 , 다른 포트를 선택해야 합니다. "
#~ "예를 들면, 5433:``-p 5433:5432 \\``"

#~ msgid "Creating Blockstore"
#~ msgstr "블록스토어 만들기"

#~ msgid ""
#~ "Before we run Iroha container, we "
#~ "should create persistent volume to store"
#~ " files, storing blocks for the chain."
#~ " It is done via the following "
#~ "command:"
#~ msgstr "Iroha 컨테이너를 실행하기 전에, "

#~ msgid "Configuring Iroha Network"
#~ msgstr "Iroha 네트워크 구성하기"

#~ msgid ""
#~ "To keep things simple, in this "
#~ "guide we will create a network "
#~ "containing only one node. To understand"
#~ " how to run several peers, follow "
#~ "this guide."
#~ msgstr ""
#~ "쉬운 설명을 위해 이 가이드에서는 노드가 하나인 "
#~ "네트워크를 생성할 것입니다. 여러 노드가 작동하는 네트워크에"
#~ " 대해서 이해하려면 이 가이드를 따라하세요."

#~ msgid ""
#~ "Now we need to configure our Iroha"
#~ " network. This includes creating a "
#~ "configuration file, generating keypairs for"
#~ " a users, writing a list of "
#~ "peers and creating a genesis block. "
#~ "However, we have prepared an example "
#~ "configuration for this guide, so you "
#~ "can start playing with Iroha faster. "
#~ "In order to get those files, you"
#~ " need to clone the `Iroha repository"
#~ " <github.com/hyperledger/iroha>`_ from Github."
#~ msgstr ""
#~ "이제 Iroha 네트워크를 설정해야 합니다. 설정은 설정"
#~ " 파일 만들기외 유저의 키쌍 생성, 피어 리스트 "
#~ "작성, 제네시스 블록 생성 등의 작업을 포함합니다. "
#~ "하지만 이 가이드를 위한 설정 파일이 미리 "
#~ "준비되어있기 때문에 Iroha를 가지고 빨리 재미있는 것을"
#~ " 해볼 수 있습니다. 미리 준비된 설정 파일을 "
#~ "다운로드 받기 위해서는 깃허브에서 `Iroha repository "
#~ "<github.com/hyperledger/iroha>`를 클론해야 합니다."

#~ msgid ""
#~ "``--depth-1`` option allows us to "
#~ "download only latest commit and save "
#~ "some time and bandwidth. If you "
#~ "want to get a full commit history,"
#~ " you can omit this option."
#~ msgstr ""
#~ "``--depth-1`` 옵션은 가장 최근 커밋만을 다운받을 "
#~ "수 있게 해주어 시간과 대역폭을 절약할 수 "
#~ "있습니다. 만약 전체 커밋 히스토리를 다운받고 싶다면 "
#~ "이 옵션을 제외하면 됩니다."

#~ msgid "Starting Iroha Container"
#~ msgstr "Iroha 컨테이너 시작하기"

#~ msgid ""
#~ "We are ready to launch our Iroha"
#~ " container. Let's do it with the "
#~ "following command"
#~ msgstr "Iroha 컨테이너를 시작할 준비가 다 되었습니다. 아래 커맨드를 입력해보세요."

#~ msgid "Let's look in detail what this command does:"
#~ msgstr "이 커맨드가 무엇을 하는지 자세히 살펴봅시다:"

#~ msgid ""
#~ "``docker run -it --name iroha \\`` "
#~ "attaches you to docker container called"
#~ " ``iroha``"
#~ msgstr ""
#~ "``docker run -it --name iroha \\`` "
#~ "명령은 ``iroha``란 이름을 가지는 도커 컨테이너에 "
#~ "진입할 수 있게합니다."

#~ msgid ""
#~ "with ``$(pwd)/iroha/example:/opt/iroha_data \\`` we"
#~ " add a folder containing our prepared"
#~ " configuration to a docker container "
#~ "into ``/opt/iroha_data``."
#~ msgstr ""
#~ "``$(pwd)/iroha/example:/opt/iroha_data \\`` 명령으로 우리는"
#~ " 사전에 필요한 설정들이 들어있는 폴더를 도커 컨테이너"
#~ " 안의 ``/opt/iroha_data`` 폴더로 지정 시켰습니다."

#~ msgid ""
#~ "``-v blockstore:/tmp/block_store \\`` adds a"
#~ " persistent block storage which we "
#~ "created before to a container, so "
#~ "our blocks won't be lost after we"
#~ " stop the container"
#~ msgstr ""
#~ "``-v blockstore:/tmp/block_store \\`` 명령으로 블록"
#~ " 저장소가 지속성을 가지게 만들었습니다. 우리의 블록 "
#~ "데이터들은 컨테이너가 정지(stop) 된 이후에도 남아있을 "
#~ "겁니다."

#~ msgid ""
#~ "``--network=iroha-network \\`` adds our "
#~ "container to previously created ``iroha-"
#~ "network``, so Iroha and Postgres could"
#~ " see each other."
#~ msgstr ""
#~ "``--network=iroha-network \\`` 명령으로 전에 "
#~ "만들었던 ``iroha-network`` 에 컨테이너를 추가합니다."
#~ " 이를 통해 Iroha 와 Postgres 가 서로"
#~ " 연결되게 만들었습니다."

#~ msgid ""
#~ "``--entrypoint=/bin/bash \\`` Because ``hyperledger"
#~ "/iroha-docker`` has the custom script "
#~ "which runs after starting the container,"
#~ " we want to override it so we"
#~ " can start Iroha Daemon manually."
#~ msgstr ""
#~ "``--entrypoint=/bin/bash \\`` 명령은 ``hyperledger"
#~ "/iroha-docker`` 컨테이너가 실행된 직후 자동으로 특정"
#~ " 스크립트를 실행하게 만든 설정을 덮어씌워 우리가 "
#~ "수동으로 Iroha 데몬(Daemon) 을 실행할 수 있게"
#~ " 하기 위함입니다."

#~ msgid ""
#~ "``hyperledger/iroha-docker:develop`` is the "
#~ "image which has the ``develop`` branch."
#~ msgstr "``hyperledger/iroha-docker:develop`` 은 ``develop(개발 버전)`` 브렌치의 이미지 입니다."

#~ msgid "Launching Iroha Daemon"
#~ msgstr "Iroha 데몬 실행하기"

#~ msgid ""
#~ "Now you are in the interactive "
#~ "shell of Iroha's container. To actually"
#~ " run Iroha, we need to launch "
#~ "Iroha daemon – ``irohad``."
#~ msgstr ""
#~ "자 이제 Iroha 컨테이너 환경안에서 쉘을 띄웠습니다."
#~ " 실제로 Iroha 를 실행하기 위해선 우리는 Iroha"
#~ " 데몬을 실행시켜야 합니다 – ``irohad``."

#~ msgid ""
#~ "In the usual situation, you need "
#~ "to provide a config file, generate "
#~ "genesis block and keypair. However, as"
#~ " a part of this guide, we "
#~ "provide an example configuration for "
#~ "you. Please do not use these "
#~ "settings in a production. You can "
#~ "read more about configuration here."
#~ msgstr ""
#~ "원래 보통의 경우라면, 당신은 설정 파일을 작성하고, "
#~ "초기 블록(genesis block) 이나 키쌍(keypair) 등을"
#~ " 생성해야 하겠지만, 이 가이드를 진행하기 위에 우리는"
#~ " 미리 이런 설정들을 준비해두었습니다. 따라서 이 "
#~ "설정들은 실제 운영시에는 사용하지 마십시오. 추후에 이 "
#~ "설정들에 대한 내용을 찾아볼 수 있을 것입니다."

#~ msgid ""
#~ "Congratulations! You have an Iroha node"
#~ " up and running! In the next "
#~ "section, we will test it by "
#~ "sending some transactions."
#~ msgstr ""
#~ "축하합니다! Iroha 노드(node)가 문제없이 잘 구동되었네요."
#~ " 이 다음 섹션에서는 트랜잭션들을 전송하고 테스트 해볼"
#~ " 겁니다."

#~ msgid ""
#~ "You can get more information about "
#~ "``irohad`` and its launch options in "
#~ "this section"
#~ msgstr ""

#~ msgid "Interacting with Iroha Network"
#~ msgstr "Iroha 네트워크와 상호작용 하기"

#~ msgid ""
#~ "You can interact with Iroha using "
#~ "various ways. You can use our "
#~ "client libraries to write code in "
#~ "various programming languages (e.g. Java, "
#~ "Python, Javascript, Swift) which communicates"
#~ " with Iroha. Alternatively, you can "
#~ "use ``iroha-cli`` – our command-"
#~ "line tool for interacting with Iroha."
#~ " As a part of this guide, let's"
#~ " get familiar with ``iroha-cli``"
#~ msgstr ""

#~ msgid ""
#~ "Despite that ``iroha-cli`` is arguably"
#~ " the simplest way to start working"
#~ " with Iroha, ``iroha-cli`` was "
#~ "engineered very fast and lacks tests,"
#~ " so user experience might not be "
#~ "the best. For example, the order "
#~ "of menu items can differ from that"
#~ " you see in this guide. In the"
#~ " future, we will deliver a better "
#~ "version and appreciate contributions."
#~ msgstr ""

#~ msgid ""
#~ "Open a new terminal (note that "
#~ "Iroha container and ``irohad`` should be"
#~ " up and running) and attach to "
#~ "an ``iroha`` docker container:"
#~ msgstr ""

#~ msgid ""
#~ "Now you are in the interactive "
#~ "shell of Iroha's container again. We "
#~ "need to launch ``iroha-cli`` and "
#~ "pass an account name of the "
#~ "desired user. In our example, the "
#~ "account ``admin`` is already created in"
#~ " a ``test`` domain. Let's use this"
#~ " account to work with Iroha."
#~ msgstr ""

#~ msgid ""
#~ "Full account name has a ``@`` "
#~ "symbol between name and domain. Note "
#~ "that the keypair has the same "
#~ "name."
#~ msgstr ""

#~ msgid "Creating the First Transaction"
#~ msgstr ""

#~ msgid ""
#~ "You can see the interface of "
#~ "``iroha-cli`` now. Let's create a new"
#~ " asset, add some asset to the "
#~ "admin account and transfer it to "
#~ "other account. To achieve this, please"
#~ " choose option ``1. New transaction "
#~ "(tx)`` by writing ``tx`` or ``1`` "
#~ "to a console."
#~ msgstr ""

#~ msgid ""
#~ "Now you can see a list of "
#~ "available commands. Let's try creating a"
#~ " new asset. Select ``14. Create Asset"
#~ " (crt_ast)``. Now enter a name for"
#~ " your asset, for example ``coolcoin``. "
#~ "Next, enter a Domain ID. In our"
#~ " example we already have a domain "
#~ "``test``, so let's use it. Then we"
#~ " need to enter an asset precision "
#~ "– the amount of numbers in a "
#~ "fractional part. Let's set precision to"
#~ " ``2``."
#~ msgstr ""

#~ msgid ""
#~ "Congratulations, you have created your "
#~ "first command and added it to a"
#~ " transaction! You can either send it"
#~ " to Iroha or add some more "
#~ "commands ``1. Add one more command "
#~ "to the transaction (add)``. Let's add"
#~ " more commands, so we can do "
#~ "everything in one shot. Type ``add``."
#~ msgstr ""

#~ msgid ""
#~ "Now try adding some ``coolcoins`` to "
#~ "our account. Select ``16. Add Asset "
#~ "Quantity (add_ast_qty)``, enter Account ID "
#~ "– ``admin@test``, asset ID – "
#~ "``coolcoin#test``, integer part and precision."
#~ " For example, to add 200.50 "
#~ "``coolcoins``, we need to enter integer"
#~ " part as ``20050`` and precision as"
#~ " ``2``, so it becomes ``200.50``."
#~ msgstr ""

#~ msgid "Full asset name has a ``#`` symbol between name and domain."
#~ msgstr ""

#~ msgid ""
#~ "Let's transfer 100.50 ``coolcoins`` from "
#~ "``admin@test`` to ``test@test`` by adding "
#~ "one more command and choosing ``5. "
#~ "Transfer Assets (tran_ast)``. Enter Source "
#~ "Account and Destination Account, in our"
#~ " case ``admin@test`` and ``test@test``, "
#~ "Asset ID (``coolcoin#test``), integer part "
#~ "and precision (``10050`` and ``2`` "
#~ "accordingly)."
#~ msgstr ""

#~ msgid ""
#~ "Now we need to send our "
#~ "transaction to Iroha peer (``2. Send "
#~ "to Iroha peer (send)``). Enter peer "
#~ "address (in our case ``localhost``) and"
#~ " port (``50051``). Congratulations, your "
#~ "transaction is submitted and you can "
#~ "see your transaction hash. You can "
#~ "use it to check transaction's status."
#~ msgstr ""

#~ msgid ""
#~ "Go back to a terminal where "
#~ "``irohad`` is running. You can see "
#~ "logs of your transaction."
#~ msgstr ""

#~ msgid "Congratulations! You have submitted your first transaction to Iroha."
#~ msgstr ""

#~ msgid "Creating the First Query"
#~ msgstr "첫번째 쿼리 만들기"

#~ msgid ""
#~ "Now let's check if ``coolcoins`` were"
#~ " successfully transferred from ``admin@test`` "
#~ "to ``test@test``. Choose ``2. New query"
#~ " (qry)``. ``7. Get Account's Assets "
#~ "(get_acc_ast)`` can help you to check"
#~ " if ``test@test`` now has ``coolcoin``. "
#~ "Form a query in a similar way "
#~ "you did with commands you did with"
#~ " commands and ``1. Send to Iroha "
#~ "peer (send)``. Now you can see "
#~ "information about how many ``coolcoin`` "
#~ "does ``test@test`` have. It will look"
#~ " similar to this:"
#~ msgstr ""

#~ msgid ""
#~ "Congratulations! You have submitted your "
#~ "first query to Iroha and got a "
#~ "response!"
#~ msgstr "축하합니다! 당신은 드디어 Iroha 에 첫번째 쿼리를 제출하고 이에 대한 응답도 받았습니다."

#~ msgid ""
#~ "To get information about all available"
#~ " commands and queries please check "
#~ "our API section."
#~ msgstr "사용가능한 모든 커맨드나 쿼리에 대한 내용들은 본 문서의 API 절을 참고하세요."

#~ msgid "Being Badass"
#~ msgstr ""

#~ msgid ""
#~ "Let's try being badass and cheat "
#~ "Iroha. For example, let's transfer more"
#~ " ``coolcoins`` than ``admin@test`` has. Try"
#~ " to transfer 100000.00 ``coolcoins`` from"
#~ " ``admin@test`` to ``test@test``. Again, "
#~ "proceed to ``1. New transaction (tx)``,"
#~ " ``5. Transfer Assets (tran_ast)``, enter"
#~ " Source Account and Destination Account,"
#~ " in our case ``admin@test`` and "
#~ "``test@test``, Asset ID (``coolcoin#test``), "
#~ "integer part and precision (``10000000`` "
#~ "and ``2`` accordingly). Send a "
#~ "transaction to Iroha peer as you "
#~ "did before. Well, it says"
#~ msgstr ""

#~ msgid ""
#~ "`Your transaction was accepted for "
#~ "processing`. Does it mean that we "
#~ "had successfully cheated Iroha? Let's "
#~ "try to see transaction's status. Choose"
#~ " ``3. New transaction status request "
#~ "(st)`` and enter transaction's hash "
#~ "which you can get in the console"
#~ " after the previous command. Let's "
#~ "send it to Iroha. It replies with:"
#~ msgstr ""

#~ msgid ""
#~ "Apparently no. Our transaction was not"
#~ " accepted because it did not pass "
#~ "stateful validation and ``coolcoins`` were "
#~ "not transferred. You can check the "
#~ "status of ``admin@test`` and ``test@test`` "
#~ "with queries to be sure (like we"
#~ " did earlier)."
#~ msgstr ""

#~ msgid "Deploying Iroha"
#~ msgstr "Iroha 배포하기"

#~ msgid ""
#~ "Hyperledger Iroha can be deployed in "
#~ "different ways, depending on the "
#~ "perspective and the purpose. There can"
#~ " be either a single node deployed,"
#~ " or multiple nodes running in several"
#~ " containers on a local machine or "
#~ "spread across the network — so "
#~ "pick any case you need. This page"
#~ " describes different scenarios and is "
#~ "intended to act as a how-to "
#~ "guide for users, primarily trying out"
#~ " Iroha for the first time."
#~ msgstr ""

#~ msgid "Running single instance"
#~ msgstr ""

#~ msgid ""
#~ "Generally, people want to run Iroha "
#~ "locally in order to try out the"
#~ " API and explore the capabilities. "
#~ "This can be done in local or "
#~ "container environment (Docker). We will "
#~ "explore both possible cases, but in "
#~ "order to simplify peer components "
#~ "deployment, *it is advised to have "
#~ "Docker installed on your machine*."
#~ msgstr ""

#~ msgid "Local environment"
#~ msgstr "로컬 환경"

#~ msgid ""
#~ "By local environment, it is meant "
#~ "to have daemon process and Postgres "
#~ "deployed without any containers. This "
#~ "might be helpful in cases when "
#~ "messing up with Docker is not "
#~ "preferred — generally a quick "
#~ "exploration of the features."
#~ msgstr ""

#~ msgid "Run postgres server"
#~ msgstr "postgres 서버 실행"

#~ msgid ""
#~ "In order to run postgres server "
#~ "locally, you should check postgres "
#~ "`website <https://www.postgresql.org/docs/current/static"
#~ "/server-start.html>`__ and follow their "
#~ "description. Generally, postgres server runs"
#~ " automatically when the system starts, "
#~ "but this should be checked in the"
#~ " configuration of the system."
#~ msgstr ""

#~ msgid "Run iroha daemon (irohad)"
#~ msgstr "iroha 데몬 실행 (irohad)"

#~ msgid ""
#~ "There is a list of preconditions "
#~ "which you should meet before proceeding:"
#~ msgstr ""

#~ msgid "Postgres server is up and running"
#~ msgstr "Postgres 서버가 정상적으로 잘 구동되었네요"

#~ msgid "`irohad` Iroha daemon binary is built and accessible in your system"
#~ msgstr ""

#~ msgid "The genesis block and configuration files were created"
#~ msgstr "genesis 블럭과 설정파일들이 생성되었습니다"

#~ msgid "Config file uses valid postgres connection settings"
#~ msgstr ""

#~ msgid "A keypair for the peer is generated"
#~ msgstr ""

#~ msgid ""
#~ "This is the first time you run "
#~ "the Iroha on this peer and you "
#~ "want to create new chain"
#~ msgstr ""

#~ msgid ""
#~ "Have you got something that is not"
#~ " the same as in the list of "
#~ "assumptions? Please, refer to the "
#~ "section below the document, titled as"
#~ " `Dealing with troubles`_."
#~ msgstr ""

#~ msgid ""
#~ "In case of valid assumptions, the "
#~ "only thing that remains is to "
#~ "launch the daemon process with following"
#~ " parameters:"
#~ msgstr ""

#~ msgid "Parameter"
#~ msgstr ""

#~ msgid "Meaning"
#~ msgstr ""

#~ msgid "config"
#~ msgstr "설정"

#~ msgid ""
#~ "configuration file, containing postgres "
#~ "connection and values to tune the "
#~ "system"
#~ msgstr ""

#~ msgid "genesis_block"
#~ msgstr "genesis_block"

#~ msgid "initial block in the ledger"
#~ msgstr ""

#~ msgid "keypair_name"
#~ msgstr "keypair_name"

#~ msgid ""
#~ "private and public key file names "
#~ "without file extension, used by peer "
#~ "to sign the blocks"
#~ msgstr ""

#~ msgid "An example of shell command, running Iroha daemon is"
#~ msgstr ""

#~ msgid ""
#~ "If you have stopped the daemon and"
#~ " want to use existing chain — "
#~ "you should not pass the genesis "
#~ "block parameter."
#~ msgstr ""

#~ msgid "Docker"
#~ msgstr "Docker"

#~ msgid ""
#~ "In order to run Iroha peer as "
#~ "a single instance in Docker, you "
#~ "should pull the image for Iroha "
#~ "first:"
#~ msgstr ""

#~ msgid ""
#~ "Use *latest* tag for latest stable "
#~ "release, and *develop* for latest "
#~ "development version"
#~ msgstr ""

#~ msgid ""
#~ "Then, you have to create an "
#~ "enviroment for the image to run "
#~ "without problems:"
#~ msgstr ""

#~ msgid "Create docker network"
#~ msgstr "docker 네트워크 생성"

#~ msgid ""
#~ "Containers for Postgres and Iroha should"
#~ " run in the same virtual network, "
#~ "in order to be available to each"
#~ " other. Create a network, by typing"
#~ " following command (you can use any"
#~ " name for the network, but in "
#~ "the example, we use *iroha-network* "
#~ "name):"
#~ msgstr ""

#~ msgid "Run Postgresql in a container"
#~ msgstr "Postgresql 을 컨테이너 환경에서 실행"

#~ msgid ""
#~ "Similarly, run postgres server, attaching "
#~ "it to the network you have created"
#~ " before, and exposing ports for "
#~ "communication:"
#~ msgstr ""

#~ msgid "Create volume for block storage"
#~ msgstr "블록 저장공간(block storage)을 위한 볼륨(volume) 생성"

#~ msgid ""
#~ "Before we run iroha daemon in the"
#~ " container, we should create persistent "
#~ "volume to store files, storing blocks"
#~ " for the chain. It is done via"
#~ " the following command:"
#~ msgstr ""

#~ msgid "Running iroha daemon in docker container"
#~ msgstr "iroha 데몬(daemon)을 컨테이너 환경에서 실행"

#~ msgid ""
#~ "There is a list of assumptions "
#~ "which you should review before "
#~ "proceeding:"
#~ msgstr ""

#~ msgid "Postgres server is running on the same docker network"
#~ msgstr ""

#~ msgid "There is a folder, containing config file and keypair for a single node"
#~ msgstr ""

#~ msgid "If they are met, you can move forward with the following command:"
#~ msgstr ""

#~ msgid "Running multiple instances (peer network)"
#~ msgstr ""

#~ msgid ""
#~ "In order to set up a peer "
#~ "network, one should follow routines, "
#~ "described in this section. In this "
#~ "version, we support manual deployment "
#~ "and automated by Ansible Playbook. "
#~ "Choose an option, that meets your "
#~ "security criteria and other needs."
#~ msgstr ""

#~ msgid "Manually"
#~ msgstr ""

#~ msgid ""
#~ "By manual deployment, we mean that "
#~ "Iroha peer network is set up "
#~ "without automated assistance. It is "
#~ "similar to the process of running "
#~ "a single local instance, although the"
#~ " difference is the genesis block "
#~ "includes more than a single peer. "
#~ "In order to form a block, which"
#~ " includes more than a single peer,"
#~ " or requires customization for your "
#~ "needs, please take a look at "
#~ "`Dealing with troubles`_ section."
#~ msgstr ""

#~ msgid "Automated"
#~ msgstr ""

#~ msgid ""
#~ "Anyone can reuse existing Ansible "
#~ "Playbook in order to create a "
#~ "network of peers running Iroha. "
#~ "Currently, this is a solution for "
#~ "development and testing, in other words,"
#~ " a proof of concept, and cannot "
#~ "be used in production environment, due"
#~ " to some security flaws. For "
#~ "production network, a manual composing "
#~ "of genesis block is required."
#~ msgstr ""

#~ msgid "One ore more <virtual> machines with a Linux distributive installed."
#~ msgstr ""

#~ msgid "SSH access to those machines"
#~ msgstr ""

#~ msgid "Ansible installed on a local machine"
#~ msgstr ""

#~ msgid "Step-by-step guide"
#~ msgstr ""

#~ msgid "Create peers.list file in $IROHA_HOME/deploy/ansible/data"
#~ msgstr ""

#~ msgid ""
#~ "Write all peers IP addresses followed"
#~ " by the internal port 10001 (e.g "
#~ "31.192.120.36:10001)"
#~ msgstr ""

#~ msgid "Open $IROHA_HOME/deploy/ansible/hosts file"
#~ msgstr ""

#~ msgid "Write all IP addresses in [hosts] group"
#~ msgstr ""

#~ msgid "Open terminal"
#~ msgstr ""

#~ msgid ""
#~ "Disable host key checking, because it"
#~ " can cause troubles due to "
#~ "interactive prompt"
#~ msgstr ""

#~ msgid "Go to ansible folder"
#~ msgstr ""

#~ msgid "Run playbook, providing your private key and hosts file"
#~ msgstr ""

#~ msgid "Wait until playbook finishes and then Iroha network is ready and up."
#~ msgstr ""

#~ msgid "Checking Iroha peer status"
#~ msgstr ""

#~ msgid "SSH into any of your machines"
#~ msgstr ""

#~ msgid "Check Iroha container logs:"
#~ msgstr ""

#~ msgid "Dealing with troubles"
#~ msgstr ""

#~ msgid "—\"Please, help me, because I am…\""
#~ msgstr ""

#~ msgid "Not having Iroha daemon binary"
#~ msgstr ""

#~ msgid ""
#~ "You can build Iroha daemon binary "
#~ "from sources, following API section from"
#~ " the `website <https://hyperledger.github.io/iroha-"
#~ "api/#build>`__"
#~ msgstr ""

#~ msgid "Not having config file"
#~ msgstr ""

#~ msgid ""
#~ "Check how to create a configuration "
#~ "file by following this `link "
#~ "<https://hyperledger.github.io/iroha-api/#prepare-"
#~ "configuration-file>`__"
#~ msgstr ""

#~ msgid "Not having genesis block"
#~ msgstr ""

#~ msgid ""
#~ "Create genesis block by generating it"
#~ " via `iroha-cli` or manually, as "
#~ "it is described `here "
#~ "<https://hyperledger.github.io/iroha-api/#create-"
#~ "genesis-block>`__"
#~ msgstr ""

#~ msgid "Not having a keypair for a peer"
#~ msgstr ""

#~ msgid ""
#~ "In order to create a keypair for"
#~ " an account or a peer, use "
#~ "iroha-cli binary by passing the name"
#~ " of the peer with `--new_account` "
#~ "option."
#~ msgstr ""

#~ msgid "Guides and how-tos"
#~ msgstr ""

#~ msgid ""
#~ "Here we will take a look more "
#~ "closely at how to use Iroha. In"
#~ " essence, this section is a "
#~ "collection of how-tos for different "
#~ "scenarios: - how to install Iroha "
#~ "- what is required to build client"
#~ " libraries and how to use them "
#~ "(for example https://developers.google.com/protocol-"
#~ "buffers/docs/javatutorial) - how to use "
#~ "CLI - how to deploy a network "
#~ "of Iroha peers, etc."
#~ msgstr ""

#~ msgid "Client libraries"
#~ msgstr ""

#~ msgid "C++ library"
#~ msgstr ""

#~ msgid "Where to get"
#~ msgstr ""

#~ msgid "How to use/import"
#~ msgstr ""

#~ msgid "Troubleshooting"
#~ msgstr ""

#~ msgid "Troubleshoting"
#~ msgstr ""

#~ msgid "Maintenance"
#~ msgstr ""

#~ msgid ""
#~ "Hardware requirements, deployment process in"
#~ " details, aspects related to security, "
#~ "configuration files — all of the "
#~ "listed is explained in this separate "
#~ "section, helpful for DevOps engineers or"
#~ " those who are digging deeper in "
#~ "the system capabilities."
#~ msgstr ""

#~ msgid "Ansible"
#~ msgstr ""

#~ msgid "Use Case Scenarios"
#~ msgstr ""

#~ msgid ""
#~ "We list a number of use cases "
#~ "and specific advantages that Hyperledger "
#~ "Iroha can introduce to these "
#~ "applications. We hope that the "
#~ "applications and use cases will inspire"
#~ " developers and creators to further "
#~ "innovation with Hyperledger Iroha."
#~ msgstr ""

#~ msgid "Certificates in Education, Healthcare"
#~ msgstr ""

#~ msgid ""
#~ "Hyperledger Iroha incorporates into the "
#~ "system multiple certifying authorities such"
#~ " as universities, schools, and medical "
#~ "institutions. Flexible permission model used"
#~ " in Hyperledger Iroha allows building "
#~ "certifying identities, and grant certificates."
#~ " The storage of explicit and implicit"
#~ " information in users' account allows "
#~ "building various reputation and identity "
#~ "systems."
#~ msgstr ""

#~ msgid ""
#~ "By using Hyperledger Iroha each "
#~ "education or medical certificate can be"
#~ " verified that it was issued by "
#~ "certain certifying authorities. Immutability "
#~ "and clear validation rules provide "
#~ "transparency to health and education "
#~ "significantly reducing the usage of fake"
#~ " certificates."
#~ msgstr ""

#~ msgid "Example"
#~ msgstr ""

#~ msgid ""
#~ "Imagine a medical institution registered "
#~ "as a ``hospital`` domain in Hyperledger"
#~ " Iroha. This domain has certified and"
#~ " registered workers each having some "
#~ "role, e.g. ``physician``, ``therapist``, "
#~ "``nurse``. Each patient of the hospital"
#~ " has an account with full medical "
#~ "history. Each medical record, like blood"
#~ " test results, is securely and "
#~ "privately stored in the account of "
#~ "the patient as JSON key/values. Rules"
#~ " in ``hospital`` domain are defined "
#~ "such that only certified medical workers"
#~ " and the user can access the "
#~ "personal information. The medical data "
#~ "returned by a query is verified "
#~ "that it comes from a trusted "
#~ "source."
#~ msgstr ""

#~ msgid ""
#~ "Hospital is tied to a specific "
#~ "location, following legal rules of that"
#~ " location, like storing personal data "
#~ "of citizens only in specific "
#~ "regions(`privacy rules`_). A multi-domain "
#~ "approach in Hyperledger Iroha allows "
#~ "sharing information across multiple countries"
#~ " not violating legal rules. For "
#~ "example, if the user ``makoto@hospital`` "
#~ "decides to share personal case history"
#~ " with a medical institution in "
#~ "another country, the user can use "
#~ "``grant`` command with permission "
#~ "``can_get_my_acc_detail``."
#~ msgstr ""

#~ msgid ""
#~ "Similar to a medical institution, a "
#~ "registered university in Hyperledger Iroha "
#~ "has permissions to push information to"
#~ " the graduated students. A diploma or"
#~ " certificate is essentially Proof-of-"
#~ "Graduation with a signature of "
#~ "recognized University. This approach helps "
#~ "to ease hiring process, with an "
#~ "employer making a query to Hyperledger"
#~ " Iroha to get the acquired skills "
#~ "and competence of the potential "
#~ "employee."
#~ msgstr ""

#~ msgid "Cross-Border Asset Transfers"
#~ msgstr ""

#~ msgid ""
#~ "Hyperledger Iroha provides fast and "
#~ "clear trade and settlement rules using"
#~ " multi-signature accounts and atomic "
#~ "exchange. Asset management is easy as"
#~ " in centralized systems while providing "
#~ "necessary security guarantees. By simplifying"
#~ " the rules and commands required to"
#~ " create and transfer assets, we lower"
#~ " the barrier to entry, while at "
#~ "the same time maintaining high-security"
#~ " guarantees."
#~ msgstr ""

#~ msgid ""
#~ "For example [#f1]_, a user might "
#~ "want to transfer the ownership of "
#~ "a car. User ``haruto`` has registered"
#~ " owner-asset relationship with a car"
#~ " of ``sora`` brand with parameters: "
#~ "``{\"id\": \"34322069732074686520616E73776572\", "
#~ "\"color\": \"red\", \"size\": \"small\"}``. "
#~ "This ownership is fixed in an "
#~ "underlying database of the system with"
#~ " copies at each validating peer. To"
#~ " perform the transfer operation user "
#~ "``haruto`` creates an offer, i.e. a "
#~ "multi-signature transaction with two "
#~ "commands: ``transfer`` to user ``haru`` "
#~ "the car identifier and ``transfer`` some"
#~ " amount of ``usd`` tokens from "
#~ "``haru`` to ``haruto``. Upon receiving "
#~ "the offer ``haru`` accepts it by "
#~ "signing the multi-signature transaction, "
#~ "in this case, transaction atomically "
#~ "commits to the system."
#~ msgstr ""

#~ msgid ""
#~ "Hypeledger Iroha has no built-in "
#~ "token, but it supports different assets"
#~ " from various creators. This approach "
#~ "allows building a decentralized exchange "
#~ "market. For example, the system can "
#~ "have central banks from different "
#~ "countries to issue assets."
#~ msgstr ""

#~ msgid "Currently not implemented"
#~ msgstr ""

#~ msgid "Financial Applications"
#~ msgstr ""

#~ msgid ""
#~ "Hyperleger Iroha can be very useful "
#~ "in the auditing process. Each "
#~ "information is validated by business "
#~ "rules and is constantly maintained by"
#~ " distinct network participants. Access "
#~ "control rules along with some encryption"
#~ " maintain desired level of privacy. "
#~ "Access control rules can be defined "
#~ "at different levels: user-level, "
#~ "domain-level or system-level. At the"
#~ " user-level privacy rules for a "
#~ "specific individual are defined. If "
#~ "access rules are determined at domain"
#~ " or system level, they are affecting"
#~ " all users in the domain. In "
#~ "Hyperledger Iroha we provide convenient "
#~ "role-based access control rules, where "
#~ "each role has specific permissions."
#~ msgstr ""

#~ msgid ""
#~ "Transactions can be traced with a "
#~ "local database. Using Iroha-API auditor"
#~ " can query and perform analytics on"
#~ " the data, execute specific audit "
#~ "software. Hyperledger Iroha supports different"
#~ " scenarios for deploying analytics "
#~ "software:  on a local computer, or "
#~ "execute code on specific middleware. "
#~ "This approach allows analyzing Big Data"
#~ " application with Hadoop, Apache, and "
#~ "others. Hypeledger Iroha serves as a "
#~ "guarantor of data integrity and privacy"
#~ " (due to the query permissions "
#~ "restriction)."
#~ msgstr ""

#~ msgid ""
#~ "For example, auditing can be helpful "
#~ "in financial applications. An auditor "
#~ "account has a role of the "
#~ "``auditor`` with permissions to access "
#~ "the information of users in the "
#~ "domain without bothering the user. To"
#~ " reduce the probability of account "
#~ "hijacking and prevent the auditor from"
#~ " sending malicious queries, the auditor "
#~ "is typically defined as a multi-"
#~ "signature account, meaning that auditor "
#~ "can make queries only having signatures"
#~ " from multiple separate identities. The "
#~ "auditor can make queries not only "
#~ "to fetch account data and balance "
#~ "but also all transactions of a "
#~ "user, e.g. all transfers of user "
#~ "``haruto`` in domain ``konoha``. To "
#~ "efficiently analyze data of million "
#~ "users each Iroha node can work in"
#~ " tandem with analytics software."
#~ msgstr ""

#~ msgid ""
#~ "Multi-signature transactions are a "
#~ "powerful tool of Hyperledger Iroha that"
#~ " can disrupt tax system. Each "
#~ "transaction in a certain domain can "
#~ "be as a multi-signature transaction, "
#~ "where one signature comes from the "
#~ "user (for example asset transfer) and"
#~ " the second signature comes from "
#~ "special taxing nodes. Taxing nodes will"
#~ " have special validation rules written "
#~ "using Iroha-API, e.g. each purchase "
#~ "in the certified stores must pay "
#~ "taxes. In other words, Iroha a "
#~ "valid purchase transaction must contain "
#~ "two commands: money transfer(purchase) to "
#~ "the store and money transfer(tax "
#~ "payment) to the government."
#~ msgstr ""

#~ msgid "Identity Management"
#~ msgstr ""

#~ msgid ""
#~ "Hyperledger Iroha has an intrinsic "
#~ "support for identity management. Each "
#~ "user in the system has a uniquely"
#~ " identified account with personal "
#~ "information, and each transaction is "
#~ "signed and associated with a certain "
#~ "user. This makes Hyperledger Iroha "
#~ "perfect for various application with KYC"
#~ " (Know Your Customer) features."
#~ msgstr ""

#~ msgid ""
#~ "For example, insurance companies can "
#~ "benefit from querying the information of"
#~ " user’s transaction without worrying about"
#~ " the information truthfulness. Users can"
#~ " also benefit from storing personal "
#~ "information on a blockchain since "
#~ "authenticated information will reduce the "
#~ "time of claims processing. Imagine a "
#~ "situation where a user wants to "
#~ "make a hard money loan. Currently, "
#~ "pre-qualification is a tedious process"
#~ " of gathering information about income, "
#~ "debts and information verification. Each "
#~ "user in Hyperledger Iroha has an "
#~ "account with verified personal information,"
#~ " such as owning assets, job "
#~ "positions, and debts. User income and"
#~ " debts can be traced using query "
#~ "``GetAccountTransactions``, owning assets using "
#~ "query ``GetAccountAssets`` and job positions"
#~ " using ``GetAccountDetail``. Each query "
#~ "returns verified result reducing the "
#~ "processing time of hard money loan "
#~ "will take only a few seconds. To"
#~ " incentivize users to share personal "
#~ "information, various companies can come "
#~ "up with business processes. For example,"
#~ " insurance companies can create bonus "
#~ "discounts for users making fitness "
#~ "activities. Fitness applications can push "
#~ "private Proof-of-Activity to the "
#~ "system, and the user can decide "
#~ "later to share information with "
#~ "insurance companies using ``GrantPermission`` "
#~ "with permission ``can_get_my_acc_detail``."
#~ msgstr ""

#~ msgid "Supply Chain"
#~ msgstr ""

#~ msgid ""
#~ "Governance of a decentralized system and"
#~ " representing legal rules as a "
#~ "system's code is an essential "
#~ "combination of any supply chain system."
#~ " Certification system used in Hyperledger"
#~ " Iroha allows tokenization of physical "
#~ "items and embedding them into the "
#~ "system. Each item comes with the "
#~ "information about “what, when, where and"
#~ " why”."
#~ msgstr ""

#~ msgid ""
#~ "Permission systems and restricted set of"
#~ " secure core commands narrows the "
#~ "attack vector and provides effortlessly "
#~ "a basic level of privacy. Each "
#~ "transaction is traceable within a system"
#~ " with a hash value, by the "
#~ "credentials or certificates of the "
#~ "creator."
#~ msgstr ""

#~ msgid ""
#~ "Food supply chain is a shared "
#~ "system with multiple different actors, "
#~ "such as farmers, storehouses, grocery "
#~ "stores, and customers. The goal is "
#~ "to deliver food from a farmer's "
#~ "field to the table of a customer."
#~ " The product goes through many "
#~ "stages, with each stage recorded in "
#~ "shared space. A customer scans a "
#~ "code of the product via a mobile"
#~ " device, in which an Iroha query "
#~ "is encoded. Iroha query provides a "
#~ "full history with all stages, "
#~ "information about the product and the"
#~ " farmer."
#~ msgstr ""

#~ msgid ""
#~ "For example, ``gangreen`` is a "
#~ "registered farmer ``tomato`` asset creator,"
#~ " he serves as a guarantor tokenizing"
#~ " physical items, i.e. associating each "
#~ "tomato with an Iroha ``tomato`` item."
#~ " Asset creation and distribution processes"
#~ " are totally transparent for network "
#~ "participants. Iroha ``tomato`` goes on a"
#~ " journey through a multitude of "
#~ "vendors to finally come to user "
#~ "``chad``."
#~ msgstr ""

#~ msgid ""
#~ "We simplified asset creation to just "
#~ "a single command ``CreateAsset`` without "
#~ "the need to create complex smart "
#~ "contracts. One the major advantages of"
#~ " Hyperledger Iroha is in its ease,"
#~ " that allows developers to focus on"
#~ " the provided value of their "
#~ "applications."
#~ msgstr ""

#~ msgid "Related Research"
#~ msgstr ""

#~ msgid ""
#~ "(The idea was to show current "
#~ "pioneers of blockchain applications and "
#~ "their works.)"
#~ msgstr ""

#~ msgid "Hyperledger Iroha documentation"
#~ msgstr ""

#~ msgid "Last Reviewed"
#~ msgstr ""

#~ msgid "2018-03-06"
#~ msgstr ""

#~ msgid ""
#~ "Welcome! Hyperledger Iroha is a simple"
#~ " blockchain platform you can use to"
#~ " make trusted, secure, and fast "
#~ "applications by bringing the power of"
#~ " permission-based blockchain with Byzantine"
#~ " fault-tolerant consensus. It's free, "
#~ "open-source, and works on Linux "
#~ "and Mac OS, with a variety of "
#~ "mobile and desktop libraries."
#~ msgstr ""

#~ msgid ""
#~ "You can download the source code "
#~ "of Hyperledger Iroha and latest releases"
#~ " from `GitHub page "
#~ "<https://github.com/hyperledger/iroha>`_."
#~ msgstr ""

#~ msgid ""
#~ "This documentation will guide you "
#~ "through the installation, deployment, and "
#~ "launch of Iroha network, and explain "
#~ "to you how to write an application"
#~ " for it. We will also see which"
#~ " use case scenarios are feasible now,"
#~ " and are going to be implemented "
#~ "in the future."
#~ msgstr ""

#~ msgid ""
#~ "As Hyperledger Iroha is an open-"
#~ "source project, we will also cover "
#~ "contribution part and explain you a "
#~ "working process."
#~ msgstr ""

#~ msgid ""
#~ "There is a separate website for "
#~ "all external API documentation, which is"
#~ " `Iroha API <https://hyperledger.github.io/iroha-"
#~ "api>`_. We are in the process of"
#~ " migration, so that in future only"
#~ " RTD is maintained and updated."
#~ msgstr ""

#~ msgid "Overview of Iroha"
#~ msgstr ""

#~ msgid "What are the key features of Iroha?"
#~ msgstr ""

#~ msgid "Where Iroha can be used?"
#~ msgstr ""

#~ msgid "How is it different from Bitcoin or Ethereum?"
#~ msgstr ""

#~ msgid ""
#~ "How is it different from the rest"
#~ " of Hyperledger frameworks or other "
#~ "permissioned blockchains?"
#~ msgstr ""

#~ msgid "Is it fast?"
#~ msgstr ""

#~ msgid "How to create applications around Iroha?"
#~ msgstr ""

#~ msgid ""
#~ "A command changes the state, called "
#~ "World State View, by performing an "
#~ "action over an entity (asset, account)"
#~ " in the system. Any command should"
#~ " be included in a transaction to "
#~ "perform an action."
#~ msgstr ""

#~ msgid "Purpose"
#~ msgstr ""

#~ msgid ""
#~ "The purpose of add asset quantity "
#~ "command is to increase the quantity "
#~ "of an asset on account of "
#~ "transaction creator. Use case scenario "
#~ "is to increase the number of a "
#~ "mutable asset in the system, which "
#~ "can act as a claim on a "
#~ "commodity (e.g. money, gold, etc.)"
#~ msgstr ""

#~ msgid "Schema"
#~ msgstr ""

#~ msgid "Structure"
#~ msgstr ""

#~ msgid "Field"
#~ msgstr ""

#~ msgid "Description"
#~ msgstr ""

#~ msgid "Constraint"
#~ msgstr ""

#~ msgid "Account ID"
#~ msgstr ""

#~ msgid "account id in which to add asset"
#~ msgstr ""

#~ msgid "<account_name>@<domain_id>"
#~ msgstr ""

#~ msgid "alex@morgan"
#~ msgstr ""

#~ msgid "Asset ID"
#~ msgstr ""

#~ msgid "id of the asset"
#~ msgstr ""

#~ msgid "<asset_name>#<domain_id>"
#~ msgstr ""

#~ msgid "usd#morgan"
#~ msgstr ""

#~ msgid "Amount"
#~ msgstr ""

#~ msgid "positive amount of the asset to add"
#~ msgstr ""

#~ msgid "> 0"
#~ msgstr ""

#~ msgid "200.02"
#~ msgstr ""

#~ msgid "Asset and account should exist"
#~ msgstr ""

#~ msgid "Added quantity precision should be equal to asset precision"
#~ msgstr ""

#~ msgid ""
#~ "Creator of a transaction should have "
#~ "a role which has permissions for "
#~ "issuing assets"
#~ msgstr ""

#~ msgid "Creator of a transaction adds account quantity to his/her account only"
#~ msgstr ""

#~ msgid ""
#~ "The purpose of add peer command is"
#~ " to write into ledger the fact "
#~ "of peer addition into the peer "
#~ "network. After a transaction with "
#~ "AddPeer has been committed, consensus "
#~ "and synchronization components will start "
#~ "using it."
#~ msgstr ""

#~ msgid "Address"
#~ msgstr ""

#~ msgid "resolvable address in network (IPv4, IPv6, domain name, etc.)"
#~ msgstr ""

#~ msgid "should be resolvable"
#~ msgstr ""

#~ msgid "192.168.1.1:50541"
#~ msgstr ""

#~ msgid "Peer key"
#~ msgstr ""

#~ msgid ""
#~ "peer public key, which is used in"
#~ " consensus algorithm to sign-off "
#~ "vote, commit, reject messages"
#~ msgstr ""

#~ msgid "ed25519 public key"
#~ msgstr ""

#~ msgid "292a8714694095edce6be799398ed5d6244cd7be37eb813106b217d850d261f2"
#~ msgstr ""

#~ msgid "Creator of the transaction has a role which has CanAddPeer permission"
#~ msgstr ""

#~ msgid "Such network address has not been already added"
#~ msgstr ""

#~ msgid ""
#~ "The purpose of add signatory command "
#~ "is to add an identifier to the "
#~ "account. Such identifier is a public "
#~ "key of another device or a public"
#~ " key of another user."
#~ msgstr ""

#~ msgid "Account to which to add signatory"
#~ msgstr ""

#~ msgid "makoto@soramitsu"
#~ msgstr ""

#~ msgid "Public key"
#~ msgstr ""

#~ msgid "Signatory to add to account"
#~ msgstr ""

#~ msgid "359f925e4eeecfdd6aa1abc0b79a6a121a5dd63bb612b603247ea4f8ad160156"
#~ msgstr ""

#~ msgid "Two cases:"
#~ msgstr ""

#~ msgid ""
#~ "Case 1. Transaction creator wants to "
#~ "add a signatory to his or her "
#~ "account, having permission CanAddSignatory"
#~ msgstr ""

#~ msgid "Case 2. CanAddSignatory was granted to transaction creator"
#~ msgstr ""

#~ msgid ""
#~ "The purpose of append role command "
#~ "is to promote an account to some"
#~ " created role in the system, where"
#~ " a role is a set of permissions"
#~ " account has to perform an action "
#~ "(command or query)."
#~ msgstr ""

#~ msgid "id or account to append role to"
#~ msgstr ""

#~ msgid "already existent"
#~ msgstr ""

#~ msgid "Role name"
#~ msgstr ""

#~ msgid "name of already created role"
#~ msgstr ""

#~ msgid "MoneyCreator"
#~ msgstr ""

#~ msgid "The role should exist in the system"
#~ msgstr ""

#~ msgid ""
#~ "Transaction creator should have permissions"
#~ " to append role (CanAppendRole)"
#~ msgstr ""

#~ msgid ""
#~ "Account, which appends role, has set "
#~ "of permissions in his roles that "
#~ "is a superset of appended role (in"
#~ " other words no-one can append "
#~ "role that is more powerful than "
#~ "what transaction creator is)"
#~ msgstr ""

#~ msgid ""
#~ "The purpose of create account command"
#~ " is to make entity in the "
#~ "system, capable of sending transactions "
#~ "or queries, storing signatories, personal "
#~ "data and identifiers."
#~ msgstr ""

#~ msgid "Account name"
#~ msgstr ""

#~ msgid "domain-unique name for account"
#~ msgstr ""

#~ msgid "`[a-z_0-9]{1,32}`"
#~ msgstr ""

#~ msgid "morgan_stanley"
#~ msgstr ""

#~ msgid "Domain ID"
#~ msgstr ""

#~ msgid "target domain to make relation with"
#~ msgstr ""

#~ msgid "should be created before the account"
#~ msgstr ""

#~ msgid "america"
#~ msgstr ""

#~ msgid "Main pubkey"
#~ msgstr ""

#~ msgid "first public key to add to the account"
#~ msgstr ""

#~ msgid "407e57f50ca48969b08ba948171bb2435e035d82cec417e18e4a38f5fb113f83"
#~ msgstr ""

#~ msgid "Transaction creator has permission to create an account"
#~ msgstr ""

#~ msgid "Domain, passed as domain_id, has already been created in the system"
#~ msgstr ""

#~ msgid ""
#~ "Such public key has not been added"
#~ " before as first public key of "
#~ "account or added to a multi-"
#~ "signature account"
#~ msgstr ""

#~ msgid ""
#~ "The purpose of сreate asset command "
#~ "is to create a new type of "
#~ "asset, unique in a domain. An "
#~ "asset is a countable representation of"
#~ " a commodity."
#~ msgstr ""

#~ msgid "Asset name"
#~ msgstr ""

#~ msgid "domain-unique name for asset"
#~ msgstr ""

#~ msgid "soracoin"
#~ msgstr ""

#~ msgid "RFC1035 [#f1]_, RFC1123 [#f2]_"
#~ msgstr ""

#~ msgid "japan"
#~ msgstr ""

#~ msgid "Precision"
#~ msgstr ""

#~ msgid "number of digits after comma/dot"
#~ msgstr ""

#~ msgid "0 <= precision <= uint32 max"
#~ msgstr ""

#~ msgid "2"
#~ msgstr ""

#~ msgid "Transaction creator has permission to create assets"
#~ msgstr ""

#~ msgid "Asset name is unique in domain"
#~ msgstr ""

#~ msgid ""
#~ "The purpose of create domain command "
#~ "is to make new domain in Iroha "
#~ "network, which is a group of "
#~ "accounts."
#~ msgstr ""

#~ msgid "ID for created domain"
#~ msgstr ""

#~ msgid "unique, RFC1035 [#f1]_, RFC1123 [#f2]_"
#~ msgstr ""

#~ msgid "japan05"
#~ msgstr ""

#~ msgid "Default role"
#~ msgstr ""

#~ msgid "role for any created user in the domain"
#~ msgstr ""

#~ msgid "one of the existing roles"
#~ msgstr ""

#~ msgid "User"
#~ msgstr ""

#~ msgid "Domain ID is unique"
#~ msgstr ""

#~ msgid ""
#~ "Account, who sends this command in "
#~ "transaction, has role with permission to"
#~ " create domain"
#~ msgstr ""

#~ msgid ""
#~ "Role, which will be assigned to "
#~ "created user by default, exists in "
#~ "the system"
#~ msgstr ""

#~ msgid ""
#~ "The purpose of create role command "
#~ "is to create a new role in "
#~ "the system from the set of "
#~ "permissions. Combining different permissions "
#~ "into roles, maintainers of Iroha peer"
#~ " network can create customized security "
#~ "model."
#~ msgstr ""

#~ msgid "name of role to create"
#~ msgstr ""

#~ msgid "Permissions"
#~ msgstr ""

#~ msgid "array of already existent permissions"
#~ msgstr ""

#~ msgid ""
#~ "set of passed permissions is fully "
#~ "included into set of existing "
#~ "permissions"
#~ msgstr ""

#~ msgid "{can_receive, can_transfer}"
#~ msgstr ""

#~ msgid ""
#~ "Set of passed permissions is fully "
#~ "included into set of existing "
#~ "permissions"
#~ msgstr ""

#~ msgid "Set of the permissions is not empty"
#~ msgstr ""

#~ msgid ""
#~ "The purpose of detach role command "
#~ "is to detach a role from the "
#~ "set of roles of an account. By "
#~ "executing this command it is possible"
#~ " to decrease the number of possible"
#~ " actions in the system for the "
#~ "user."
#~ msgstr ""

#~ msgid "ID of account where role will be deleted"
#~ msgstr ""

#~ msgid "a detached role name"
#~ msgstr ""

#~ msgid "existing role"
#~ msgstr ""

#~ msgid "The role exists in the system"
#~ msgstr ""

#~ msgid "The account has such role"
#~ msgstr ""

#~ msgid ""
#~ "The purpose of grant permission command"
#~ " is to give another account rights"
#~ " to perform actions on the account"
#~ " of transaction sender (give someone "
#~ "right to do something with my "
#~ "account)."
#~ msgstr ""

#~ msgid "id of account whom rights are granted"
#~ msgstr ""

#~ msgid "Permission name"
#~ msgstr ""

#~ msgid "name of granted permission"
#~ msgstr ""

#~ msgid "permission is defined"
#~ msgstr ""

#~ msgid "CanTransferAssets"
#~ msgstr ""

#~ msgid "Account exists"
#~ msgstr ""

#~ msgid "Transaction creator is allowed to grant this permission"
#~ msgstr ""

#~ msgid "Remove signatory"
#~ msgstr ""

#~ msgid ""
#~ "Purpose of remove signatory command is"
#~ " to remove a public key, associated"
#~ " with an identity, from an account"
#~ msgstr ""

#~ msgid "Signatory to delete"
#~ msgstr ""

#~ msgid ""
#~ "When signatory is deleted, we should "
#~ "check if invariant of **size(signatories) "
#~ ">= quorum** holds"
#~ msgstr ""

#~ msgid "Signatory should have been previously added to the account"
#~ msgstr ""

#~ msgid ""
#~ "Case 1. When transaction creator wants"
#~ " to remove signatory from their "
#~ "account and he or she has "
#~ "permission CanRemoveSignatory"
#~ msgstr ""

#~ msgid "Case 2. CanRemoveSignatory was granted to transaction creator"
#~ msgstr ""

#~ msgid ""
#~ "The purpose of revoke permission command"
#~ " is to revoke or dismiss given "
#~ "granted permission from another account "
#~ "in the network."
#~ msgstr ""

#~ msgid "permission was granted"
#~ msgstr ""

#~ msgid ""
#~ "Transaction creator should have previously "
#~ "granted this permission to a target "
#~ "account"
#~ msgstr ""

#~ msgid ""
#~ "Purpose of set account detail command"
#~ " is to set key-value information "
#~ "for a given account"
#~ msgstr ""

#~ msgid "id of account whom key-value information was set"
#~ msgstr ""

#~ msgid "Key"
#~ msgstr ""

#~ msgid "key of information being set"
#~ msgstr ""

#~ msgid "`[A-Za-z0-9_]{1,64}`"
#~ msgstr ""

#~ msgid "Name"
#~ msgstr ""

#~ msgid "Value"
#~ msgstr ""

#~ msgid "value of corresponding key"
#~ msgstr ""

#~ msgid "≤ 4096"
#~ msgstr ""

#~ msgid "Makoto"
#~ msgstr ""

#~ msgid ""
#~ "Case 1. When transaction creator wants"
#~ " to set account detail to his/her "
#~ "account and he or she has "
#~ "permission CanSetAccountInfo"
#~ msgstr ""

#~ msgid "Case 2. CanSetAccountInfo was granted to transaction creator"
#~ msgstr ""

#~ msgid ""
#~ "The purpose of set account quorum "
#~ "command is to set the number of"
#~ " signatories required to confirm the "
#~ "identity of a user, who creates "
#~ "the transaction. Use case scenario is"
#~ " to set the number of different "
#~ "users, utilizing single account, to sign"
#~ " off the transaction."
#~ msgstr ""

#~ msgid "ID of account to set quorum"
#~ msgstr ""

#~ msgid "Quorum"
#~ msgstr ""

#~ msgid ""
#~ "number of signatories needed to be "
#~ "included with a transaction from this"
#~ " account"
#~ msgstr ""

#~ msgid "0 < quorum ≤ public-key set up to account ≤ 128"
#~ msgstr ""

#~ msgid "5"
#~ msgstr ""

#~ msgid ""
#~ "When quorum is set, it is checked"
#~ " if invariant of **size(signatories) >= "
#~ "quorum** holds."
#~ msgstr ""

#~ msgid ""
#~ "Case 1. When transaction creator wants"
#~ " to set quorum for his/her account"
#~ " and he or she has permission "
#~ "CanRemoveSignatory"
#~ msgstr ""

#~ msgid ""
#~ "The purpose of subtract asset quantity"
#~ " command is the opposite of "
#~ "AddAssetQuantity commands — to decrease "
#~ "the number of assets on account of"
#~ " transaction creator."
#~ msgstr ""

#~ msgid "account id from which to subtract asset"
#~ msgstr ""

#~ msgid "positive amount of the asset to subtract"
#~ msgstr ""

#~ msgid "200"
#~ msgstr ""

#~ msgid ""
#~ "Creator of the transaction should have"
#~ " a role which has permissions for "
#~ "subtraction of assets"
#~ msgstr ""

#~ msgid ""
#~ "Creator of transaction subtracts account "
#~ "quantity in his/her account only"
#~ msgstr ""

#~ msgid ""
#~ "The purpose of transfer asset command"
#~ " is to share assets within the "
#~ "account in peer network: in the "
#~ "way that source account transfers assets"
#~ " to the target account."
#~ msgstr ""

#~ msgid "Source account ID"
#~ msgstr ""

#~ msgid "ID of account to withdraw asset from"
#~ msgstr ""

#~ msgid "Destination account ID"
#~ msgstr ""

#~ msgid "ID of account to send asset at"
#~ msgstr ""

#~ msgid "alex@california"
#~ msgstr ""

#~ msgid "ID of asset to transfer"
#~ msgstr ""

#~ msgid "usd#usa"
#~ msgstr ""

#~ msgid "Message to attach to transfer"
#~ msgstr ""

#~ msgid "Max length is 64"
#~ msgstr ""

#~ msgid "here's my money take it"
#~ msgstr ""

#~ msgid "amount of the asset to transfer"
#~ msgstr ""

#~ msgid "0 < amount < max_uint256"
#~ msgstr ""

#~ msgid "200.20"
#~ msgstr ""

#~ msgid "Source account has this asset in its AccountHasAsset relation [#f1]_"
#~ msgstr ""

#~ msgid ""
#~ "An amount is a positive number and"
#~ " asset precision is consistent with "
#~ "the asset definition"
#~ msgstr ""

#~ msgid "Source account has enough amount of asset to transfer and is not zero"
#~ msgstr ""

#~ msgid ""
#~ "Source account can transfer money, and"
#~ " destination account can receive money "
#~ "(their roles have these permissions)"
#~ msgstr ""

#~ msgid "https://www.ietf.org/rfc/rfc1035.txt"
#~ msgstr ""

#~ msgid "https://www.ietf.org/rfc/rfc1123.txt"
#~ msgstr ""

#~ msgid "Contents are missing for now."
#~ msgstr ""

#~ msgid ""
#~ "In API section we will take a "
#~ "look at building blocks of an "
#~ "application interacting with Iroha. We "
#~ "will overview commands and queries that"
#~ " the system has, and the set of"
#~ " client libraries encompassing transport "
#~ "and application layer logic."
#~ msgstr ""

#~ msgid ""
#~ "A query is a request related to"
#~ " certain part of World State View "
#~ "— the latest state of blockchain. "
#~ "Query cannot modify the contents of "
#~ "the chain and a response is "
#~ "returned to any client immediately after"
#~ " receiving peer has processed a "
#~ "query."
#~ msgstr ""

#~ msgid "The validation for all queries includes:"
#~ msgstr ""

#~ msgid ""
#~ "timestamp — shouldn't be from the "
#~ "past (24 hours prior to the peer"
#~ " time) or from the future (range "
#~ "of 5 minutes added to the peer "
#~ "time)"
#~ msgstr ""

#~ msgid ""
#~ "signature of query creator — used "
#~ "for checking the identity of query "
#~ "creator"
#~ msgstr ""

#~ msgid ""
#~ "query counter — checked to be "
#~ "incremented with every subsequent query "
#~ "from query creator"
#~ msgstr ""

#~ msgid ""
#~ "roles — depending on the query "
#~ "creator's role: the range of state "
#~ "available to query can relate to "
#~ "to the same account, account in "
#~ "the domain, to the whole chain, or"
#~ " not allowed at all"
#~ msgstr ""

#~ msgid "Get Account"
#~ msgstr ""

#~ msgid "Purpose of get account query is to get the state of an account."
#~ msgstr ""

#~ msgid "Request Schema"
#~ msgstr ""

#~ msgid "Request Structure"
#~ msgstr ""

#~ msgid "account id to request its state"
#~ msgstr ""

#~ msgid "Response Schema"
#~ msgstr ""

#~ msgid "Response Structure"
#~ msgstr ""

#~ msgid "account id"
#~ msgstr ""

#~ msgid "domain where the account was created"
#~ msgstr ""

#~ msgid "morgan"
#~ msgstr ""

#~ msgid "number of signatories needed to sign the transaction to make it valid"
#~ msgstr ""

#~ msgid "0 < quorum ≤ 128"
#~ msgstr ""

#~ msgid "JSON data"
#~ msgstr ""

#~ msgid "key-value account information"
#~ msgstr ""

#~ msgid "JSON"
#~ msgstr ""

#~ msgid "{ genesis: {name: alex} }"
#~ msgstr ""

#~ msgid "Get Signatories"
#~ msgstr ""

#~ msgid ""
#~ "Purpose of get signatories query is "
#~ "to get signatories, which act as "
#~ "an identity of the account."
#~ msgstr ""

#~ msgid "account id to request signatories"
#~ msgstr ""

#~ msgid "Keys"
#~ msgstr ""

#~ msgid "an array of public keys"
#~ msgstr ""

#~ msgid "`ed25519 <https://ed25519.cr.yp.to>`_"
#~ msgstr ""

#~ msgid "Get Transactions"
#~ msgstr ""

#~ msgid ""
#~ "GetTransactions is used for retrieving "
#~ "information about transactions, based on "
#~ "their hashes."
#~ msgstr ""

#~ msgid "Transactions hashes"
#~ msgstr ""

#~ msgid "an array of hashes"
#~ msgstr ""

#~ msgid "array with 32 byte hashes"
#~ msgstr ""

#~ msgid "{hash1, hash2…}"
#~ msgstr ""

#~ msgid "Transactions"
#~ msgstr ""

#~ msgid "an array of transactions"
#~ msgstr ""

#~ msgid "Committed transactions"
#~ msgstr ""

#~ msgid "{tx1, tx2…}"
#~ msgstr ""

#~ msgid "Get Account Transactions"
#~ msgstr ""

#~ msgid ""
#~ "In a case when a list of "
#~ "transactions per account is needed, "
#~ "`GetAccountTransactions` query can be formed."
#~ msgstr ""

#~ msgid "account id to request transactions from"
#~ msgstr ""

#~ msgid "an array of transactions for given account"
#~ msgstr ""

#~ msgid "Get Account Asset Transactions"
#~ msgstr ""

#~ msgid ""
#~ "`GetAccountAssetTransactions` query returns all "
#~ "transactions associated with given account "
#~ "and asset."
#~ msgstr ""

#~ msgid "asset id in order to filter transactions containing this asset"
#~ msgstr ""

#~ msgid "jpy#japan"
#~ msgstr ""

#~ msgid "an array of transactions for given account and asset"
#~ msgstr ""

#~ msgid "Get Account Assets"
#~ msgstr ""

#~ msgid ""
#~ "To get the state of an asset "
#~ "in an account (a balance), "
#~ "`GetAccountAssets` query can be used."
#~ msgstr ""

#~ msgid "account id to request balance from"
#~ msgstr ""

#~ msgid "asset id to know its balance"
#~ msgstr ""

#~ msgid "identifier of asset used for checking the balance"
#~ msgstr ""

#~ msgid "account which has this balance"
#~ msgstr ""

#~ msgid "Balance"
#~ msgstr ""

#~ msgid "balance of the asset"
#~ msgstr ""

#~ msgid "Not less than 0"
#~ msgstr ""

#~ msgid "Get Asset Info"
#~ msgstr ""

#~ msgid ""
#~ "In order to know precision for "
#~ "given asset, and other related info "
#~ "in the future, such as a "
#~ "description of the asset, etc. user "
#~ "can send `GetAssetInfo` query."
#~ msgstr ""

#~ msgid "asset id to know related information"
#~ msgstr ""

#~ msgid "jpy"
#~ msgstr ""

#~ msgid "domain related to this asset"
#~ msgstr ""

#~ msgid "number of digits after comma"
#~ msgstr ""

#~ msgid "0 < precision < 256"
#~ msgstr ""

#~ msgid "Get Roles"
#~ msgstr ""

#~ msgid ""
#~ "To get existing roles in the "
#~ "system, a user can send `GetRoles` "
#~ "query to Iroha network."
#~ msgstr ""

#~ msgid "Roles"
#~ msgstr ""

#~ msgid "array of created roles in the network"
#~ msgstr ""

#~ msgid "set of roles in the system"
#~ msgstr ""

#~ msgid "{MoneyCreator, User, Admin, …}"
#~ msgstr ""

#~ msgid "Get Role Permissions"
#~ msgstr ""

#~ msgid ""
#~ "To get available permissions per role"
#~ " in the system, a user can send"
#~ " `GetRolePermissions` query to Iroha "
#~ "network."
#~ msgstr ""

#~ msgid "Role ID"
#~ msgstr ""

#~ msgid "role to get permissions for"
#~ msgstr ""

#~ msgid "existing role in the system"
#~ msgstr ""

#~ msgid "array of permissions related to the role"
#~ msgstr ""

#~ msgid "string of permissions related to the role"
#~ msgstr ""

#~ msgid "{can_add_asset_qty, …}"
#~ msgstr ""

#~ msgid "Account"
#~ msgstr "Account"

#~ msgid ""
#~ "An Iroha entity that is able to"
#~ " perform specified set of actions. "
#~ "Each account belongs to one of "
#~ "existing `domains <#domain>`__."
#~ msgstr ""

#~ msgid ""
#~ "An account has some number of "
#~ "`roles <#role>`__ (can be none) — "
#~ "which is a collection of permissions."
#~ " Only `grantable permissions <#grantable-"
#~ "permission>`__ are assigned to an "
#~ "account directly."
#~ msgstr ""

#~ msgid "Ametsuchi"
#~ msgstr ""

#~ msgid ""
#~ "Iroha storage component, which stores "
#~ "blocks and a state generated from "
#~ "blocks, called `World State View "
#~ "<#world-state-view>`__. There is no "
#~ "way for the `client <#client>`__ to "
#~ "directly interact with Ametsuchi."
#~ msgstr ""

#~ msgid "Asset"
#~ msgstr ""

#~ msgid ""
#~ "Any countable commodity or value. Each"
#~ " asset is related to one of "
#~ "existing `domains <#domain>`__. For example,"
#~ " an asset can represent any kind "
#~ "of such units - currency unit, a"
#~ " bar of gold, real estate unit, "
#~ "etc."
#~ msgstr ""

#~ msgid "Block"
#~ msgstr ""

#~ msgid ""
#~ "Transaction data is permanently recorded "
#~ "in files called blocks. Blocks are "
#~ "organized into a linear sequence over"
#~ " time (also known as the block "
#~ "chain) [#f1]_."
#~ msgstr ""

#~ msgid ""
#~ "Blocks are signed with the cryptographic"
#~ " signatures of Iroha `peers <#peer>`__, "
#~ "voting for this block during `consensus"
#~ " <#consensus>`__. Signable content is "
#~ "called payload, so the structure of "
#~ "a block looks like this:"
#~ msgstr ""

#~ msgid "*Outside payload*"
#~ msgstr ""

#~ msgid "hash — SHA3-512 hash of block protobuf payload"
#~ msgstr ""

#~ msgid ""
#~ "signatures — signatures of peers, which"
#~ " voted for the block during consensus"
#~ " round"
#~ msgstr ""

#~ msgid "*Inside payload*"
#~ msgstr ""

#~ msgid "height — a number of blocks in the chain up to the block"
#~ msgstr ""

#~ msgid "timestamp — Unix time (in milliseconds) of block forming by a peer"
#~ msgstr ""

#~ msgid ""
#~ "body — transactions, which successfully "
#~ "passed validation and consensus step"
#~ msgstr ""

#~ msgid "transactions quantity"
#~ msgstr ""

#~ msgid "previous hash of a block"
#~ msgstr ""

#~ msgid "Block Creator"
#~ msgstr ""

#~ msgid ""
#~ "System component that forms a block "
#~ "from a set of transactions that "
#~ "have been passed `stateless <#stateless-"
#~ "validation>`__ and `stateful <#stateful-"
#~ "validation>`__ validation for further "
#~ "propagation to `consensus <#consensus>`__."
#~ msgstr ""

#~ msgid "Client"
#~ msgstr ""

#~ msgid "Any application that uses Iroha is treated as a client."
#~ msgstr ""

#~ msgid ""
#~ "A distinctive feature of Iroha is "
#~ "that all clients are using simple "
#~ "client-server abstractions when they "
#~ "interact with a peer network: they "
#~ "don't use any abstractions which are "
#~ "specific for blockchain-related systems. "
#~ "For example, in Bitcoin clients have "
#~ "to validate blocks, or in Fabric "
#~ "they need to poll several peers to"
#~ " make sure that a transaction was "
#~ "written in a block, whereas in "
#~ "Iroha a client interacts with any "
#~ "peer similarly to a single server."
#~ msgstr ""

#~ msgid "Command"
#~ msgstr ""

#~ msgid ""
#~ "A command is an intention to "
#~ "change the `state <#world-state-"
#~ "view>`__. For example, in order to "
#~ "create a new `role <#role>`__ in "
#~ "Iroha you have to issue `Create "
#~ "role <../api/commands.html#create-role>`__ command."
#~ msgstr ""

#~ msgid "Consensus"
#~ msgstr ""

#~ msgid ""
#~ "A consensus algorithm is a process "
#~ "in computer science used to achieve "
#~ "agreement on a single data value "
#~ "among distributed processes or systems. "
#~ "Consensus algorithms are designed to "
#~ "achieve reliability in a network "
#~ "involving multiple unreliable nodes. Solving"
#~ " that issue -- known as the "
#~ "consensus problem -- is important in "
#~ "distributed computing and multi-agent "
#~ "systems."
#~ msgstr ""

#~ msgid "*Consensus, as an algorithm*"
#~ msgstr ""

#~ msgid ""
#~ "An algorithm to achieve agreement on "
#~ "a block among peers in the "
#~ "network. By having it in the "
#~ "system, reliability is increased."
#~ msgstr ""

#~ msgid "*Consensus, as a component*"
#~ msgstr ""

#~ msgid ""
#~ "Preserves consistent state among the "
#~ "`peers <#peer>`__ within a peer network."
#~ " Iroha uses own consensus algorithm "
#~ "called Yet Another Consensus (aka YAC)."
#~ " Distinctive features of this algorithm "
#~ "are its scalability, performance, and "
#~ "`Byzantine fault tolerance "
#~ "<https://en.wikipedia.org/wiki/Byzantine_fault_tolerance>`_. If"
#~ " there are missing blocks, they will"
#~ " be downloaded from another peer via"
#~ " `Synchronizer <#synchronizer>`__. Committed "
#~ "blocks are stored in `Ametsuchi "
#~ "<#ametsuchi>`__ block storage."
#~ msgstr ""

#~ msgid "Domain"
#~ msgstr ""

#~ msgid ""
#~ "A named abstraction for grouping "
#~ "`accounts <#account>`__ and `assets "
#~ "<#asset>`__."
#~ msgstr ""

#~ msgid "Ordering Gate"
#~ msgstr ""

#~ msgid ""
#~ "Internal Iroha component that passes "
#~ "`transactions <#transaction>`__ from `Peer "
#~ "Communication Service <#peer-communication-"
#~ "service>`__ to `Ordering Service "
#~ "<#ordering-service>`__. Ordering Gate eventually"
#~ " recieves `proposals <#proposal>`__ from "
#~ "Ordering Service and sends them to "
#~ "`Simulator <#simulator>`__ for `stateful "
#~ "validation <#stateful-validation>`__."
#~ msgstr ""

#~ msgid "Ordering Service"
#~ msgstr ""

#~ msgid ""
#~ "Internal Iroha component that combines "
#~ "several `transactions <#transaction>`__ that "
#~ "have been passed `stateless validation "
#~ "<#stateless-validation>`__ into a `proposal "
#~ "<#proposal>`__. Proposal creation could be "
#~ "triggered by one of the following "
#~ "events:"
#~ msgstr ""

#~ msgid "Time limit dedicated to transactions collection has expired."
#~ msgstr ""

#~ msgid ""
#~ "Ordering service has received the "
#~ "maximum amount of transactions allowed "
#~ "for a single proposal."
#~ msgstr ""

#~ msgid ""
#~ "Both parameters (timeout and maximum "
#~ "size of proposal) are configurable "
#~ "(check `environment-specific parameters "
#~ "<../guides/configuration.html#environment-specific-"
#~ "parameters>`_ page)."
#~ msgstr ""

#~ msgid ""
#~ "A common precondition for both triggers"
#~ " is that at least one transaction "
#~ "should reach ordering service. Otherwise, "
#~ "no proposal will be formed."
#~ msgstr ""

#~ msgid "Peer"
#~ msgstr ""

#~ msgid ""
#~ "A node that is a part of "
#~ "Iroha network. It participates in "
#~ "`consensus <#consensus>`_ process."
#~ msgstr ""

#~ msgid "Peer Communication Service"
#~ msgstr ""

#~ msgid ""
#~ "Internal component of Iroha - an "
#~ "intermediary that transmits `transaction "
#~ "<#transaction>`__ from `Torii <#torii>`__ to"
#~ " `Ordering Gate <#ordering-gate>`__. The"
#~ " main goal of PCS is to hide"
#~ " the complexity of interaction with "
#~ "consensus implementation."
#~ msgstr ""

#~ msgid "Permission"
#~ msgstr ""

#~ msgid ""
#~ "A named rule that gives the "
#~ "privilege to perform a command. "
#~ "Permission **cannot** be granted to an"
#~ " `account <#account>`__ directly, instead, "
#~ "an account has roles, which are "
#~ "the collection of permissions."
#~ msgstr ""

#~ msgid "Grantable Permission"
#~ msgstr ""

#~ msgid ""
#~ "Only grantable permission is given to"
#~ " an `account <#account>`__ directly. An "
#~ "account that holds grantable permission "
#~ "is allowed to perform some particular"
#~ " action on behalf of another account."
#~ " For example, if the account "
#~ "a@domain1 gives the account b@domain2 a"
#~ " permission that it can transfer "
#~ "assets — then  b@domain2 can transfer"
#~ " assets of a@domain1 to anyone."
#~ msgstr ""

#~ msgid "Proposal"
#~ msgstr ""

#~ msgid ""
#~ "A set of `transactions <#transaction>`__ "
#~ "that have passed only `stateless "
#~ "validation <#stateless-validation>`__."
#~ msgstr ""

#~ msgid "Verified Proposal"
#~ msgstr ""

#~ msgid ""
#~ "A set of transactions that have "
#~ "been passed `stateless <#stateless-"
#~ "validation>`__ and `stateful <#stateful-"
#~ "validation>`__ validation, but were not "
#~ "committed yet."
#~ msgstr ""

#~ msgid "Role"
#~ msgstr ""

#~ msgid "A named abstraction that holds a set of `permissions <#permission>`__."
#~ msgstr ""

#~ msgid "Simulator"
#~ msgstr ""

#~ msgid "See `Verified Proposal Creator <#verified-proposal-creator>`__."
#~ msgstr ""

#~ msgid ""
#~ "A request to Iroha that does "
#~ "**not** change the `state <#world-"
#~ "state-view>`__. By performing a query, "
#~ "a client can get request data from"
#~ " the state, for example a balance "
#~ "of his account, a history of "
#~ "transactions, etc."
#~ msgstr ""

#~ msgid "Synchronizer"
#~ msgstr ""

#~ msgid ""
#~ "Is a part of `consensus <#consensus>`__."
#~ " Adds missing blocks to `peers' "
#~ "<#peer>`__ chains (downloads them from "
#~ "other peers)."
#~ msgstr ""

#~ msgid "Torii"
#~ msgstr ""

#~ msgid ""
#~ "⛩. Entry point for `clients "
#~ "<#client>`__. Uses gRPC as a transport."
#~ " In order to interact with Iroha "
#~ "anyone can use gRPC endpoints, described"
#~ " in `Commands <../api/commands.html>`__ and "
#~ "`Queries <../api/queries.html>`__ sections, or "
#~ "use `client libraries <../guides/libraries.html>`__."
#~ msgstr ""

#~ msgid ""
#~ "An ordered set of `commands "
#~ "<#command>`__, which is applied to the"
#~ " ledger atomically. Any nonvalid command"
#~ " within a transaction leads to "
#~ "rejection of the whole transaction "
#~ "during the validation process."
#~ msgstr ""

#~ msgid "Validator"
#~ msgstr ""

#~ msgid "There are two kinds of validation - stateless and stateful."
#~ msgstr ""

#~ msgid "Stateless Validation"
#~ msgstr ""

#~ msgid ""
#~ "Performed in `Torii <#torii>`__. Checks "
#~ "if an object is well-formed, "
#~ "including the signatures."
#~ msgstr ""

#~ msgid "Stateful Validation"
#~ msgstr ""

#~ msgid ""
#~ "Performed in `Verified Proposal Creator "
#~ "<#verified-proposal-creator>`__. Validates "
#~ "against `World State View <#world-"
#~ "state-view>`__."
#~ msgstr ""

#~ msgid "Verified Proposal Creator"
#~ msgstr ""

#~ msgid ""
#~ "Internal Iroha component that performs "
#~ "`stateful validation <#stateful-validation>`_ "
#~ "of `transactions <#transaction>`__ contained "
#~ "in received `proposal <#proposal>`__. On "
#~ "the basis of transactions that have "
#~ "been passed stateful validation **verified "
#~ "proposal** will be created and passed"
#~ " to `Block Creator <#block-creator>`__. "
#~ "All the transactions that have not "
#~ "passed stateful validation will be "
#~ "dropped and not included in a "
#~ "verified proposal."
#~ msgstr ""

#~ msgid "World State View"
#~ msgstr ""

#~ msgid ""
#~ "WSV reflects the current state of "
#~ "the system, can be considered as a"
#~ " snapshot. For example, WSV holds "
#~ "information about an amount of `assets"
#~ " <#asset>`__ that an `account <#account>`__"
#~ " has at the moment but does not"
#~ " contain any info history of "
#~ "`transaction <#transaction>`__ flow."
#~ msgstr ""

#~ msgid "https://en.bitcoin.it/wiki/Block"
#~ msgstr ""

#~ msgid ""
#~ "Docs are constantly updated and this "
#~ "section is going to be improved. "
#~ "Check glossary page while contents are"
#~ " elaborated."
#~ msgstr ""

#~ msgid "Client Libraries"
#~ msgstr ""

#~ msgid ""
#~ "Contents are missing for now. Please "
#~ "check deploy/ansible folder and README.md "
#~ "file in it."
#~ msgstr ""

#~ msgid "2018-03-30"
#~ msgstr ""

#~ msgid "Simple deployment and maintenance"
#~ msgstr ""

#~ msgid "Variety of libraries for developers"
#~ msgstr ""

#~ msgid "Role-based access control"
#~ msgstr ""

#~ msgid "Modular design, driven by command–query separation principle"
#~ msgstr ""

#~ msgid "Assets and identity management"
#~ msgstr ""

#~ msgid "In our quality model, we focus on and continuously improve:"
#~ msgstr ""

#~ msgid "Reliability (fault tolerance, recoverability)"
#~ msgstr ""

#~ msgid ""
#~ "Performance Efficiency (in particular time-"
#~ "behavior and resource utilization)"
#~ msgstr ""

#~ msgid ""
#~ "Usability (learnability, user error "
#~ "protection, appropriateness recognisability)"
#~ msgstr ""

#~ msgid "Where can Iroha be used?"
#~ msgstr ""

#~ msgid ""
#~ "Hyperledger Iroha is a general purpose"
#~ " permissioned blockchain system that can"
#~ " be used to manage digital assets,"
#~ " identity, and serialized data. This "
#~ "can be useful for applications such "
#~ "as interbank settlement, central bank "
#~ "digital currencies, payment systems, national"
#~ " IDs, and logistics, among others."
#~ msgstr ""

#~ msgid ""
#~ "For a detailed description please check"
#~ " our `Use Case Scenarios section "
#~ "<http://iroha.readthedocs.io/en/latest/use_cases/>`_."
#~ msgstr ""

#~ msgid ""
#~ "Bitcoin and Ethereum are designed to "
#~ "be permissionless ledgers where anyone "
#~ "can join and access all the data."
#~ " They also have native cryptocurrencies "
#~ "that are required to interact with "
#~ "the systems."
#~ msgstr ""

#~ msgid ""
#~ "In Iroha, there is no native "
#~ "cryptocurrency. Instead, to meet the "
#~ "needs of enterprises, system interaction "
#~ "is permissioned, meaning that only "
#~ "people with requisite access can "
#~ "interact with the system. Additionally, "
#~ "queries are also permissioned, such that"
#~ " access to all the data can be"
#~ " controlled."
#~ msgstr ""

#~ msgid ""
#~ "One major difference from Ethereum, in"
#~ " particular, is that Hyperledger Iroha "
#~ "allows users to perform common "
#~ "functions, such as creating and "
#~ "transferring digital assets, by using "
#~ "prebuilt commands that are in the "
#~ "system. This negates the need to "
#~ "write cumbersome and hard to test "
#~ "smart contracts, enabling developers to "
#~ "complete simple tasks faster and with"
#~ " less risk."
#~ msgstr ""

#~ msgid ""
#~ "Iroha has a novel, Byzantine fault "
#~ "tolerant consensus algorithm (called YAC "
#~ "[#f1]_) that is high-performance and "
#~ "allows for finality of transactions with"
#~ " low latency. Other frameworks either "
#~ "focus more on probabilistic consensus "
#~ "algorithms, such as Nakamoto Consensus, "
#~ "or sacrifice Byzantine fault tolerance."
#~ msgstr ""

#~ msgid ""
#~ "Also, Iroha's built-in commands are "
#~ "a major benefit compared to other "
#~ "platforms, since it is very simple "
#~ "to do common tasks such as create"
#~ " digital assets, register accounts, and "
#~ "transfer assets between accounts. Moreover,"
#~ " it narrows the attack vector, "
#~ "improving overall security of the "
#~ "system, as there are less things "
#~ "to fail."
#~ msgstr ""

#~ msgid ""
#~ "Finally, Iroha is the only ledger "
#~ "that has a robust permission system, "
#~ "allowing permissions to be set for "
#~ "all commands, queries, and joining of"
#~ " the network."
#~ msgstr ""

#~ msgid "Yet Another Consensus"
#~ msgstr ""

#~ msgid ""
#~ "As per the latest review date of"
#~ " these docs, according to `Huawei "
#~ "Caliper <https://github.com/hyperledger/caliper>`_ testing"
#~ " tool, Iroha is capable of processing"
#~ " 45 transactions per second. Theoretically,"
#~ " this is not even close to the"
#~ " limit of the system, and we "
#~ "will continue constant optimizations in "
#~ "order to improve stability and "
#~ "performance."
#~ msgstr ""

#~ msgid ""
#~ "In order to bring the power of "
#~ "blockchain into your application, you "
#~ "should think first of how it is"
#~ " going to interface with Iroha peers."
#~ " A good start is to check `Core"
#~ " Concepts section "
#~ "<http://iroha.readthedocs.io/en/latest/core_concepts/>`_, "
#~ "explaining what exactly is a transaction"
#~ " and query, and how users of "
#~ "your application are supposed to "
#~ "interact with it."
#~ msgstr ""

#~ msgid ""
#~ "We also have several client libraries"
#~ " which provide tools for developers "
#~ "to form building blocks, such as "
#~ "signatures, commands, send messages to "
#~ "Iroha peers and check the status."
#~ msgstr ""

#~ msgid "Android Library"
#~ msgstr ""

#~ msgid ""
#~ "The library, in essence, is a set"
#~ " of Java interfaces and binary "
#~ "libraries compiled for different "
#~ "architectures. Supported architectures are "
#~ "*arm, x86, x86_64*."
#~ msgstr ""

#~ msgid "Where to Get"
#~ msgstr ""

#~ msgid "There are two ways to get Iroha library for Android:"
#~ msgstr ""

#~ msgid ""
#~ "Grab via Gradle (see details in "
#~ "the section `Importing the Library from"
#~ " jcenter`_)"
#~ msgstr ""

#~ msgid "Compile the library on your own."
#~ msgstr ""

#~ msgid "Manual Build"
#~ msgstr ""

#~ msgid "The guide was tested on systems running Ubuntu 16.04 and macOS."
#~ msgstr ""

#~ msgid "Android NDK"
#~ msgstr ""

#~ msgid ""
#~ "Please `download "
#~ "<https://developer.android.com/ndk/downloads/index.html>`__ and"
#~ " unpack NDK to any suitable folder."
#~ msgstr ""

#~ msgid "Automake, Bison, Cmake"
#~ msgstr ""

#~ msgid ""
#~ "Please refer to the page `Installing "
#~ "Dependencies <dependencies.html>`__ to get "
#~ "installation recipes for the tools."
#~ msgstr ""

#~ msgid "Building the Library"
#~ msgstr ""

#~ msgid ""
#~ "All you need now is to download"
#~ " `build script "
#~ "<https://github.com/hyperledger/iroha/blob/develop/shared_model/packages/android"
#~ "/android-build.sh>`__ ``android-build.sh`` to "
#~ "any empty folder and launch it "
#~ "there."
#~ msgstr ""

#~ msgid "Launch parameters are listed in the table below."
#~ msgstr ""

#~ msgid "Position"
#~ msgstr ""

#~ msgid "Required"
#~ msgstr ""

#~ msgid "Parameter Name"
#~ msgstr ""

#~ msgid "Possible Values"
#~ msgstr ""

#~ msgid "1"
#~ msgstr ""

#~ msgid "Yes"
#~ msgstr ""

#~ msgid "**Platform Name**"
#~ msgstr ""

#~ msgid "Name of the target platform for binary part of the library."
#~ msgstr ""

#~ msgid "``arm64-v8a``, ``armeabi-v7a``, ``armeabi``, ``x86``, ``x86_64``"
#~ msgstr ""

#~ msgid "**Android API Level**"
#~ msgstr ""

#~ msgid ""
#~ "API level supported by your NDK. "
#~ "See the link under the table for"
#~ " details."
#~ msgstr ""

#~ msgid "``27`` for android-ndk-r16b"
#~ msgstr ""

#~ msgid "3"
#~ msgstr ""

#~ msgid "**Android NDK Path**"
#~ msgstr ""

#~ msgid ""
#~ "Full path to unpacked NDK. Please "
#~ "ensure that path does not contain "
#~ "spaces."
#~ msgstr ""

#~ msgid "``/home/user/lib/android-ndk-r16b``"
#~ msgstr ""

#~ msgid "4"
#~ msgstr ""

#~ msgid "**Java Package Name**"
#~ msgstr ""

#~ msgid ""
#~ "Package name that will be used for"
#~ " Java interfaces generation. Note that "
#~ "the binary also depends on chosen "
#~ "package name."
#~ msgstr ""

#~ msgid "``jp.co.soramitsu.iroha.android``"
#~ msgstr ""

#~ msgid "No"
#~ msgstr ""

#~ msgid "**Build Type**"
#~ msgstr ""

#~ msgid ""
#~ "Defines build mode of binary part "
#~ "of the library. ``Release`` is the "
#~ "default option."
#~ msgstr ""

#~ msgid "``Debug`` or ``Release``"
#~ msgstr ""

#~ msgid ""
#~ "`Android API levels "
#~ "<https://developer.android.com/guide/topics/manifest/uses-"
#~ "sdk-element.html#ApiLevels>`__"
#~ msgstr ""

#~ msgid ""
#~ "Please use the same root part of"
#~ " Java package name for library build"
#~ " as you use for your Android "
#~ "project. For example, your project is"
#~ " located in a package called "
#~ "``com.mycompany.androidapp``, so please consider "
#~ "to build the library in a package,"
#~ " which name starts with "
#~ "``com.mycompany.androidapp`` (e.g. "
#~ "``com.mycompany.androidapp.iroha``)."
#~ msgstr ""

#~ msgid "A couple of launch commands examples:"
#~ msgstr ""

#~ msgid ""
#~ "Build artefacts will be collected in "
#~ "``lib`` directory near the script "
#~ "``android-build.sh``. There will be two "
#~ "files - an archive ``bindings.zip`` and"
#~ " ``libirohajava.so``."
#~ msgstr ""

#~ msgid "How to Use/Import"
#~ msgstr ""

#~ msgid "Importing the Library from jcenter"
#~ msgstr ""

#~ msgid ""
#~ "The easiest way to use Irohalib "
#~ "for Android is to import the "
#~ "library dependency from `jcenter "
#~ "<https://bintray.com/bulatmukhutdinov/maven/iroha-android-"
#~ "bindings>`__."
#~ msgstr ""

#~ msgid "All you need to do is a simple set of four steps:"
#~ msgstr ""

#~ msgid "Add to your ``build.gradle`` file the following line:"
#~ msgstr ""

#~ msgid ""
#~ "Copy the latest version of ``*.proto``"
#~ " files from ``develop`` branch of "
#~ "Iroha `repository "
#~ "<https://github.com/hyperledger/iroha/tree/develop/schema>`__ "
#~ "into ``app/src/main/proto/`` folder inside "
#~ "your project in Android Studio."
#~ msgstr ""

#~ msgid "The resulting directory structure should look like as follows:"
#~ msgstr ""

#~ msgid ""
#~ "Create additional directories "
#~ "``app/src/main/proto/google/protobuf/`` and place "
#~ "there a file called ``empty.proto`` with"
#~ " the following contents:"
#~ msgstr ""

#~ msgid ""
#~ "Add ``protobuf`` and ``grpc`` dependecies "
#~ "and protobuf configuration block into "
#~ "your ``build.gradle`` file."
#~ msgstr ""

#~ msgid "How to Use Manually Built Library"
#~ msgstr ""

#~ msgid ""
#~ "Create directory structure inside your "
#~ "Android project according to the package"
#~ " name of build library. Put there "
#~ "all the ``.java`` files from "
#~ "``bindings.zip`` archive. For example, the "
#~ "path could be "
#~ "``app/src/main/java/com/mycompany/iroha`` if you "
#~ "built the library with ``com.mycompany.iroha``"
#~ " package name."
#~ msgstr ""

#~ msgid ""
#~ "Create directory ``app/src/main/jniLibs/<platform>`` "
#~ "where ``<platform>`` is the name of "
#~ "target platform (e.g. ``arm64-v8a``). Put "
#~ "there ``libirohajava.so``. Repeat this step"
#~ " for all required platforms (in this"
#~ " case you need to build the "
#~ "library for each platform)."
#~ msgstr ""

#~ msgid ""
#~ "Repeat steps 2-4 from the previous "
#~ "section `Importing the Library from "
#~ "jcenter`_."
#~ msgstr ""

#~ msgid "Example Code"
#~ msgstr ""

#~ msgid ""
#~ "Explore ``bindings`` branch of `iroha-"
#~ "android <https://github.com/hyperledger/iroha-"
#~ "android/tree/bindings>`__ repository to get "
#~ "source code and view sample application."
#~ msgstr ""

#~ msgid "Node.js Library"
#~ msgstr ""

#~ msgid ""
#~ "Please note that Node.js library is "
#~ "under heavy testing now and problems "
#~ "`might` occur. Don't hesitate to report"
#~ " them to us."
#~ msgstr ""

#~ msgid ""
#~ "There are two main ways of "
#~ "obtaining the Node.js library. If you"
#~ " are a happy macOS or Linux "
#~ "user, you can install it `through "
#~ "NPM <#installing-through-npm>`_. If your"
#~ " system is not yet supported or "
#~ "you want to try the latest "
#~ "version, you can `build this library "
#~ "manually <#building-manually>`_."
#~ msgstr ""

#~ msgid "Node.js (>=7) (you can try using lower versions though)."
#~ msgstr ""

#~ msgid "Installing Through NPM"
#~ msgstr ""

#~ msgid ""
#~ "If you are a happy macOS or "
#~ "Linux user, you can install the "
#~ "library from `NPM repository "
#~ "<https://www.npmjs.com/package/iroha-lib>`_ using "
#~ "NPM"
#~ msgstr ""

#~ msgid "Now you can import it in your project"
#~ msgstr ""

#~ msgid "Building Manually"
#~ msgstr ""

#~ msgid ""
#~ "You need this section if you want"
#~ " to build iroha-lib manually for "
#~ "example if your architecture/OS is not"
#~ " supported yet."
#~ msgstr ""

#~ msgid "CMake (>=3.8.2)"
#~ msgstr ""

#~ msgid "Protobuf (>=3.5.1)"
#~ msgstr ""

#~ msgid "Boost (>=1.65.1)"
#~ msgstr ""

#~ msgid "macOS users can install dependencies with following commands:"
#~ msgstr ""

#~ msgid ""
#~ "If you have SWIG already installed, "
#~ "you **MUST** install patched 3.0.12 "
#~ "version instead using `this patch <https"
#~ "://patch-"
#~ "diff.githubusercontent.com/raw/swig/swig/pull/968.patch>`_. The"
#~ " current version of SWIG doesn't "
#~ "support Node.js versions higher than 6."
#~ " Also you can just delete the "
#~ "global installed SWIG and iroha will "
#~ "pull and build it automatically."
#~ msgstr ""

#~ msgid "Go to the NPM package directory and start the build process"
#~ msgstr ""

#~ msgid "That's all. You can use the library now."
#~ msgstr ""

#~ msgid ""
#~ "Explore ``example/node/index.js`` file to get"
#~ " an idea of how to work with"
#~ " a library."
#~ msgstr ""

#~ msgid ""
#~ "To start the example, you need to"
#~ " install all its dependencies (basically"
#~ " ``iroha-lib``)"
#~ msgstr ""

#~ msgid ""
#~ "if you have built the library "
#~ "manually, please change import paths to"
#~ " ``path-to-iroha/shared_model/packages/javascript`` "
#~ "in index.js"
#~ msgstr ""

#~ msgid "Python Library"
#~ msgstr ""

#~ msgid ""
#~ "There are two ways to get Iroha"
#~ " library for Python: via pip and "
#~ "manual compilation from source code. The"
#~ " installation via pip do the same "
#~ "steps as manual compilation so for "
#~ "both of them you need to install"
#~ " all of the prerequisites."
#~ msgstr ""

#~ msgid "CMake, git, g++, boost, swig, protobuf, python"
#~ msgstr ""

#~ msgid "Install Iroha Python Libraries"
#~ msgstr ""

#~ msgid "Via PIP"
#~ msgstr ""

#~ msgid "For the latest version"
#~ msgstr ""

#~ msgid "Source code"
#~ msgstr ""

#~ msgid ""
#~ "For the latest version checkout to "
#~ "develop branch by adding *-b develop*"
#~ " parameter."
#~ msgstr ""

#~ msgid ""
#~ "After this you can find Iroha "
#~ "python library in "
#~ "**iroha/build/shared_model/bindings** folder, where "
#~ "you have previously cloned repository."
#~ msgstr ""

#~ msgid "Compile Protobuf Modules of Iroha from Schema Files"
#~ msgstr ""

#~ msgid ""
#~ "Iroha communicates with users through "
#~ "protobuf messages. In order to send "
#~ "transactions and queries to Iroha node"
#~ " you need to get python module "
#~ "for generating protobuf messages. First "
#~ "of all you need to clone schema"
#~ " folder of Iroha repository. If you"
#~ " have already cloned Iroha repository "
#~ "in the previous step, just use "
#~ "schema folder from there."
#~ msgstr ""

#~ msgid "protobuf, pip"
#~ msgstr ""

#~ msgid "Building Protobuf Files"
#~ msgstr ""

#~ msgid ""
#~ "Protobuf files can be found in "
#~ "**iroha-schema** folder ('\\*_pb2\\*.py' files)"
#~ msgstr ""

#~ msgid "In order to specify Iroha libraries location:"
#~ msgstr ""

#~ msgid "Import Iroha and all of the protobuf modules that you need:"
#~ msgstr ""

#~ msgid ""
#~ "Work with byte arrays is different "
#~ "in Python 2 and Python 3. Due "
#~ "to this fact, the work with hashes"
#~ " and blobs is different in the "
#~ "examples. Given examples work fine with"
#~ " both versions of Python."
#~ msgstr ""

#~ msgid "Import Iroha and schema classes, generated from Iroha protobuf:"
#~ msgstr ""

#~ msgid "Get Iroha objects:"
#~ msgstr ""

#~ msgid "Read public and private keys:"
#~ msgstr ""

#~ msgid "Print transaction status with synchronous simple call:"
#~ msgstr ""

#~ msgid "Or streaming call:"
#~ msgstr ""

#~ msgid "Send transactions to Iroha:"
#~ msgstr ""

#~ msgid "Send query to Iroha and receive a responce:"
#~ msgstr ""

#~ msgid "Create domain and asset:"
#~ msgstr ""

#~ msgid "Create asset quantity:"
#~ msgstr ""

#~ msgid "Create account:"
#~ msgstr ""

#~ msgid "Send asset:"
#~ msgstr ""

#~ msgid "Get asset info:"
#~ msgstr ""

#~ msgid "Get account asset:"
#~ msgstr ""

#~ msgid "Building Iroha"
#~ msgstr ""

#~ msgid ""
#~ "In this guide we will learn how"
#~ " to install all dependencies, required "
#~ "to build Iroha and how to build"
#~ " it."
#~ msgstr ""

#~ msgid "Preparing the Environment"
#~ msgstr ""

#~ msgid ""
#~ "In order to successfully build Iroha,"
#~ " we need to configure the "
#~ "environment. There are several ways to"
#~ " do it and we will describe all"
#~ " of them."
#~ msgstr ""

#~ msgid ""
#~ "Currently, we support Unix-like systems"
#~ " (we are basically targeting popular "
#~ "Linux distros and macOS). If you "
#~ "happen to have Windows or you "
#~ "don't want to spend time installing "
#~ "all dependencies you might want to "
#~ "consider using Docker environment. Also, "
#~ "Windows users might consider using `WSL"
#~ " <https://en.wikipedia.org/wiki/Windows_Subsystem_for_Linux>`_"
#~ msgstr ""

#~ msgid ""
#~ "Having troubles? Check FAQ section or"
#~ " communicate to us directly, in case"
#~ " you were stuck on something. We "
#~ "don't expect this to happen, but "
#~ "some issues with an environment are "
#~ "possible."
#~ msgstr ""

#~ msgid ""
#~ "You don't need Docker to run "
#~ "Iroha, it is just one of the "
#~ "possible choices."
#~ msgstr ""

#~ msgid ""
#~ "First of all, you need to install"
#~ " ``docker`` and ``docker-compose``. You "
#~ "can read how to install it on "
#~ "a `Docker's website <https://www.docker.com"
#~ "/community-edition/>`_"
#~ msgstr ""

#~ msgid "Please, use the latest available docker daemon and docker-compose."
#~ msgstr ""

#~ msgid ""
#~ "Then you should clone the `Iroha "
#~ "repository <https://github.com/hyperledger/iroha>`_ to "
#~ "the directory of your choice."
#~ msgstr ""

#~ msgid ""
#~ "After it, you need to run the "
#~ "development environment. Run the ``scripts"
#~ "/run-iroha-dev.sh`` script:"
#~ msgstr ""

#~ msgid ""
#~ "Please make sure that Docker is "
#~ "running before executing the script. "
#~ "macOS users could find a Docker "
#~ "icon in system tray, Linux user "
#~ "could use ``systemctl start docker``"
#~ msgstr ""

#~ msgid "After you execute this script, following things happen:"
#~ msgstr ""

#~ msgid ""
#~ "1. The script checks if you don't"
#~ " have containers with Iroha already "
#~ "running. Successful completion finishes with"
#~ " the new container shell. 2. The "
#~ "script will download ``iroha-docker-"
#~ "develop`` and ``postgres`` images. ``iroha-"
#~ "docker-develop`` image contains all "
#~ "development dependencies and is based on"
#~ " top of ``ubuntu:16.04``. ``postgres`` "
#~ "image is required for starting and "
#~ "running Iroha. 3. Two containers are "
#~ "created and launched. 4. The user "
#~ "is attached to the interactive "
#~ "environment for development and testing "
#~ "with ``iroha`` folder mounted from the"
#~ " host machine. Iroha folder is "
#~ "mounted to ``/opt/iroha`` in Docker "
#~ "container."
#~ msgstr ""

#~ msgid ""
#~ "Now your are ready to build Iroha!"
#~ " Please go to `Building Iroha` "
#~ "section."
#~ msgstr ""

#~ msgid "Linux"
#~ msgstr ""

#~ msgid "Boost"
#~ msgstr ""

#~ msgid ""
#~ "Iroha requires Boost of at least "
#~ "1.65 version. To install Boost libraries"
#~ " (``libboost-all-dev``), use `current "
#~ "release <http://www.boost.org/users/download/>`_ from "
#~ "Boost webpage. The only dependencies are"
#~ " system and filesystem, so use "
#~ "``./bootstrap.sh --with-libraries=system,filesystem`` "
#~ "when you are building the project."
#~ msgstr ""

#~ msgid "Other Dependencies"
#~ msgstr ""

#~ msgid "To build Iroha, you need following packages:"
#~ msgstr ""

#~ msgid ""
#~ "``build-essential`` ``automake`` ``libtool`` "
#~ "``libssl-dev`` ``zlib1g-dev`` ``libc6-dbg`` "
#~ "``golang`` ``git`` ``tar`` ``gzip`` ``ca-"
#~ "certificates`` ``wget`` ``curl`` ``file`` "
#~ "``unzip`` ``python`` ``cmake``"
#~ msgstr ""

#~ msgid "Use this code to install dependencies on Debian-based Linux distro."
#~ msgstr ""

#~ msgid ""
#~ "If you are willing to actively "
#~ "develop Iroha and to build shared "
#~ "libraries, please consider installing the "
#~ "`latest release <https://cmake.org/download/>`_ of"
#~ " CMake."
#~ msgstr ""

#~ msgid "macOS"
#~ msgstr ""

#~ msgid ""
#~ "If you want to build it from "
#~ "scratch and actively develop it, please"
#~ " use this code to install all "
#~ "dependencies with Homebrew."
#~ msgstr ""

#~ msgid "To install the Homebrew itself please run"
#~ msgstr ""

#~ msgid ""
#~ "``ruby -e \"$(curl -fsSL "
#~ "https://raw.githubusercontent.com/homebrew/install/master/install)\"``"
#~ msgstr ""

#~ msgid "Cloning the Repository"
#~ msgstr ""

#~ msgid ""
#~ "Clone the `Iroha repository "
#~ "<https://github.com/hyperledger/iroha>`_ to the "
#~ "directory of your choice."
#~ msgstr ""

#~ msgid ""
#~ "If you have installed the prerequisites"
#~ " with Docker, you don't need to "
#~ "clone Iroha again, because when you "
#~ "run ``run-iroha-dev.sh`` it attaches "
#~ "to Iroha source code folder. Feel "
#~ "free to edit source code files "
#~ "with your host environment and build "
#~ "it within docker container."
#~ msgstr ""

#~ msgid "To build Iroha, use those commands"
#~ msgstr ""

#~ msgid ""
#~ "Alternatively, you can use these "
#~ "shorthand parameters (they are not "
#~ "documented though)"
#~ msgstr ""

#~ msgid ""
#~ "On macOS ``$(nproc)`` variable does not"
#~ " work. Check the number of logical"
#~ " cores with ``sysctl -n hw.ncpu`` and"
#~ " put it explicitly in the command "
#~ "above, e.g. ``cmake --build build -- "
#~ "-j4``"
#~ msgstr ""

#~ msgid "CMake Parameters"
#~ msgstr ""

#~ msgid ""
#~ "We use CMake to build platform-"
#~ "dependent build files. It has numerous"
#~ " flags for configuring the final "
#~ "build. Note that besides the listed "
#~ "parameters cmake's variables can be "
#~ "useful as well. Also as long as"
#~ " this page can be deprecated (or "
#~ "just not complete) you can browse "
#~ "custom flags via ``cmake -L``, "
#~ "``cmake-gui``, or ``ccmake``."
#~ msgstr ""

#~ msgid ""
#~ "You can specify parameters at the "
#~ "cmake configuring stage (e.g cmake "
#~ "-DTESTING=ON)."
#~ msgstr ""

#~ msgid "Main Parameters"
#~ msgstr ""

#~ msgid "Possible values"
#~ msgstr ""

#~ msgid "Default"
#~ msgstr ""

#~ msgid "TESTING"
#~ msgstr ""

#~ msgid "ON/OFF"
#~ msgstr ""

#~ msgid "ON"
#~ msgstr ""

#~ msgid "Enables or disables build of the tests"
#~ msgstr ""

#~ msgid "BENCHMARKING"
#~ msgstr ""

#~ msgid "OFF"
#~ msgstr ""

#~ msgid "Enables or disables build of the Google Benchmarks library"
#~ msgstr ""

#~ msgid "COVERAGE"
#~ msgstr ""

#~ msgid "Enables or disables lcov setting for code coverage generation"
#~ msgstr ""

#~ msgid "SWIG_PYTHON"
#~ msgstr ""

#~ msgid "Enables of disables the library building and Python bindings"
#~ msgstr ""

#~ msgid "SWIG_JAVA"
#~ msgstr ""

#~ msgid "Enables of disables the library building and Java bindings"
#~ msgstr ""

#~ msgid "Packaging Specific Parameters"
#~ msgstr ""

#~ msgid "ENABLE_LIBS_PACKAGING"
#~ msgstr ""

#~ msgid "Enables or disables all types of packaging"
#~ msgstr ""

#~ msgid "PACKAGE_ZIP"
#~ msgstr ""

#~ msgid "Enables or disables zip packaging"
#~ msgstr ""

#~ msgid "PACKAGE_TGZ"
#~ msgstr ""

#~ msgid "Enables or disables tar.gz packaging"
#~ msgstr ""

#~ msgid "PACKAGE_RPM"
#~ msgstr ""

#~ msgid "Enables or disables rpm packaging"
#~ msgstr ""

#~ msgid "PACKAGE_DEB"
#~ msgstr ""

#~ msgid "Enables or disables deb packaging"
#~ msgstr ""

#~ msgid "Running Tests (optional)"
#~ msgstr ""

#~ msgid ""
#~ "After building Iroha, it is a good"
#~ " idea to run tests to check the"
#~ " operability of the daemon. You can"
#~ " run tests with this code:"
#~ msgstr ""

#~ msgid "Alternatively, you can run following command in the ``build`` folder"
#~ msgstr ""

#~ msgid ""
#~ "Some of the tests will fail "
#~ "without PostgreSQL storage running, so "
#~ "if you are not using ``scripts/run-"
#~ "iroha-dev.sh`` script please run Docker"
#~ " container or create a local "
#~ "connection with following parameters:"
#~ msgstr ""

#~ msgid "Installing Dependencies"
#~ msgstr ""

#~ msgid ""
#~ "This page contains references and guides"
#~ " about installation of various tools "
#~ "you may need during build of "
#~ "different targets of Iroha project."
#~ msgstr ""

#~ msgid ""
#~ "Please note that most likely you "
#~ "do not need to install all the "
#~ "listed tools. Some of them are "
#~ "required only for building specific "
#~ "versions of Iroha Client Library."
#~ msgstr ""

#~ msgid "Automake"
#~ msgstr ""

#~ msgid "Installation on Ubuntu"
#~ msgstr ""

#~ msgid "Bison"
#~ msgstr ""

#~ msgid "CMake"
#~ msgstr ""

#~ msgid ""
#~ "Minimum required version is 3.8, but "
#~ "we recommend to install the latest "
#~ "available version (3.10.3 at the "
#~ "moment)."
#~ msgstr ""

#~ msgid ""
#~ "Since Ubuntu repositories contain unsuitable"
#~ " version of CMake, you need to "
#~ "install the new one manually. Here "
#~ "is how to build and install CMake"
#~ " from sources."
#~ msgstr ""

#~ msgid "Installation on macOS"
#~ msgstr ""

#~ msgid "Git"
#~ msgstr ""

#~ msgid "Python"
#~ msgstr ""

#~ msgid "For Python 2:"
#~ msgstr ""

#~ msgid "For Python 3:"
#~ msgstr ""

#~ msgid "PIP"
#~ msgstr ""

#~ msgid "SWIG"
#~ msgstr ""

#~ msgid "Protobuf"
#~ msgstr ""

