
msgid ""
msgstr ""
"Project-Id-Version: Hyperledger Iroha Documentation\n"
"Report-Msgid-Bugs-To: EMAIL@ADDRESS\n"
"POT-Creation-Date: 2018-12-16 20:34+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ko\n"
"Language-Team: ko <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.3\n"

#: ../iroha/docs/source/guides/libraries/nodejs.rst:2
msgid "Node.js Library"
msgstr "Node.js 라이브러리"

#: ../iroha/docs/source/guides/libraries/nodejs.rst:3
msgid ""
"Please note that Node.js library is under heavy testing now and problems "
"`might` occur. Don't hesitate to report them to us."
msgstr ""

#: ../iroha/docs/source/guides/libraries/nodejs.rst:6
msgid ""
"There are two main ways of obtaining the Node.js library. If you are a "
"happy macOS or Linux user, you can install it `through NPM <#installing-"
"through-npm>`_. If your system is not yet supported or you want to try "
"the latest version, you can `build this library manually <#building-"
"manually>`_."
msgstr ""

#: ../iroha/docs/source/guides/libraries/nodejs.rst:12
#: ../iroha/docs/source/guides/libraries/nodejs.rst:37
#: ../iroha/docs/source/guides/libraries/nodejs.rst:80
#, fuzzy
msgid "Prerequisites"
msgstr "요구 사항"

#: ../iroha/docs/source/guides/libraries/nodejs.rst:14
msgid "Node.js (>=7) (you can try using lower versions though)."
msgstr ""

#: ../iroha/docs/source/guides/libraries/nodejs.rst:17
msgid "Installing Through NPM"
msgstr ""

#: ../iroha/docs/source/guides/libraries/nodejs.rst:18
msgid ""
"If you are a happy macOS or Linux user, you can install the library from "
"`NPM repository <https://www.npmjs.com/package/iroha-lib>`_ using NPM"
msgstr ""

#: ../iroha/docs/source/guides/libraries/nodejs.rst:25
msgid "Now you can import it in your project"
msgstr ""

#: ../iroha/docs/source/guides/libraries/nodejs.rst:32
msgid "Building Manually"
msgstr ""

#: ../iroha/docs/source/guides/libraries/nodejs.rst:33
msgid ""
"You need this section if you want to build iroha-lib manually for example"
" if your architecture/OS is not supported yet."
msgstr ""

#: ../iroha/docs/source/guides/libraries/nodejs.rst:38
msgid "CMake (>=3.8.2)"
msgstr "CMake (>=3.8.2)"

#: ../iroha/docs/source/guides/libraries/nodejs.rst:39
msgid "Protobuf (>=3.5.1)"
msgstr "Protobuf (>=3.5.1)"

#: ../iroha/docs/source/guides/libraries/nodejs.rst:40
msgid "Boost (>=1.65.1)"
msgstr "Boost (>=1.65.1)"

#: ../iroha/docs/source/guides/libraries/nodejs.rst:42
msgid "macOS users can install dependencies with following commands:"
msgstr ""

#: ../iroha/docs/source/guides/libraries/nodejs.rst:50
msgid ""
"If you have SWIG already installed, you **MUST** install patched 3.0.12 "
"version instead using `this patch <https://patch-"
"diff.githubusercontent.com/raw/swig/swig/pull/968.patch>`_. The current "
"version of SWIG doesn't support Node.js versions higher than 6. Also you "
"can just delete the global installed SWIG and iroha will pull and build "
"it automatically."
msgstr ""

#: ../iroha/docs/source/guides/libraries/nodejs.rst:58
msgid "Build Process"
msgstr ""

#: ../iroha/docs/source/guides/libraries/nodejs.rst:59
msgid "Clone Iroha repository"
msgstr ""

#: ../iroha/docs/source/guides/libraries/nodejs.rst:65
msgid "Go to the NPM package directory and start the build process"
msgstr ""

#: ../iroha/docs/source/guides/libraries/nodejs.rst:72
msgid "That's all. You can use the library now."
msgstr ""

#: ../iroha/docs/source/guides/libraries/nodejs.rst:75
msgid "Example code"
msgstr "예시 코드"

#: ../iroha/docs/source/guides/libraries/nodejs.rst:76
msgid ""
"Explore ``example/node/index.js`` file to get an idea of how to work with"
" a library."
msgstr ""

#: ../iroha/docs/source/guides/libraries/nodejs.rst:81
msgid ""
"To run this example, you need an Iroha node up and running. Please check "
"out :ref:`getting-started` if you want to learn how to start it."
msgstr ""

#: ../iroha/docs/source/guides/libraries/nodejs.rst:85
msgid "Running the Example"
msgstr "예제 실행하기"

#: ../iroha/docs/source/guides/libraries/nodejs.rst:86
msgid ""
"To start the example, you need to install all its dependencies (basically"
" ``iroha-lib``)"
msgstr ""

#: ../iroha/docs/source/guides/libraries/nodejs.rst:93
msgid ""
"if you have built the library manually, please change import paths to "
"``path-to-iroha/shared_model/packages/javascript`` in index.js"
msgstr ""

#: ../iroha/docs/source/guides/libraries/nodejs.rst:96
msgid "Now, to run this example please write:"
msgstr ""

#~ msgid "Configuration"
#~ msgstr "설정"

#~ msgid ""
#~ "In this section we will understand "
#~ "how to configure Iroha. Let's take "
#~ "a look at ``example/config.sample``"
#~ msgstr "이 섹션에서는 Iroha를 설정하는 방법에 대해 설명합니다. 우선 ``example/config.sample``을 봅시다."

#~ msgid ""
#~ "As you can see, configuration file "
#~ "is a valid ``json`` structure. Let's "
#~ "go line-by-line and understand "
#~ "what every parameter means."
#~ msgstr ""
#~ "위에서 확인할 수 있듯이, 설정 파일은 ``json`` "
#~ "파일입니다. 한 줄 한 줄 확인해보면서 모든 "
#~ "파라미터들이 무엇을 의미하는지 알아봅시다."

#~ msgid "Deployment-specific parameters"
#~ msgstr "배포(Deployment)관련 파라미터"

#~ msgid "``block_store_path`` sets path to the folder where blocks are stored."
#~ msgstr "``block_store_path``은 블록을 저장할 폴더의 경로를 설정합니다."

#~ msgid ""
#~ "``torii_port`` sets the port for "
#~ "external communications. Queries and "
#~ "transactions are sent here."
#~ msgstr "``torii_port``는 외부 통신을 위한 포트를 설정합니다. 쿼리와 트랜젝션은 여기를 통해 전송됩니다."

#~ msgid ""
#~ "``internal_port`` sets the port for "
#~ "internal communications: ordering service, "
#~ "consensus and block loader."
#~ msgstr ""
#~ "``internal_port``는 오더링 서비스(Ordering Service)나 "
#~ "합의(Consensus), 블록 로더(Block Loader)와 같은 "
#~ "내부 통신을 위한 포트를 설정합니다."

#~ msgid ""
#~ "``pg_opt`` is used for setting "
#~ "credentials of PostgreSQL: hostname, port, "
#~ "username and password."
#~ msgstr ""
#~ "``pg_opt``는 PostgreSQL의 자격증명(Credentials)를 설정하는 "
#~ "데 사용됩니다. 호스트 이름, 포트, 유저 이름, "
#~ "패스워드를 설정할 수 있습니다."

#~ msgid "Environment-specific parameters"
#~ msgstr "환경(Environment) 관련 파라미터"

#~ msgid ""
#~ "``max_proposal_size`` is the maximum amount"
#~ " of transactions that can be in "
#~ "one proposal, and as a result in"
#~ " a single block as well. So, by"
#~ " changing this value you define the"
#~ " size of potential block. For a "
#~ "starter you can stick to ``10``. "
#~ "However, we recommend to increase this"
#~ " number if you have a lot of"
#~ " transactions per second."
#~ msgstr ""
#~ "``max_proposal_size``는 한 프로포절에 포함될 수 있는"
#~ " 트랜젝션의 수의 최대값을 설정합니다. 이는 하나의 "
#~ "블록에 들어갈 수 있는 트랜젝션의 수의 최대값을 "
#~ "의미하기도 합니다. 이 값을 바꿈으로써 블록의 크기를 "
#~ "설정할 수 있습니다. 처음에는 ``10``을 사용해도 되지만"
#~ " 초당 트랜젝션의 수를 늘리기 위해서는 이 값을 "
#~ "크게 하는 것을 추천합니다."

#~ msgid ""
#~ "``proposal_delay`` is a maximum waiting "
#~ "time in milliseconds before emitting a"
#~ " new proposal. Proposal is emitted if"
#~ " the ``max_proposal_size`` is reached or"
#~ " ``proposal_delay`` milliseconds had passed. "
#~ "You can start with ``5000`` and "
#~ "increase this number if you have a"
#~ " lot of transactions per second since"
#~ " it is likely that with an "
#~ "intense load (over 100 transactions per"
#~ " second) and low value of "
#~ "``proposal_delay`` there will be many "
#~ "proposals of small size."
#~ msgstr ""
#~ "``proposal_delay``는 새로운 프로포절을 내보내기까지 밀리세컨드 "
#~ "단위의 최대 대기 시간을 의미합니다. 프로포절은 "
#~ "``max_proposal_size`` ````"

#~ msgid ""
#~ "``vote_delay`` is a waiting time in "
#~ "milliseconds before sending vote to the"
#~ " next peer. Optimal value depends "
#~ "heavily on the amount of Iroha "
#~ "peers in the network (higher amount "
#~ "of nodes requires longer ``vote_delay``). "
#~ "We recommend to start with 100-1000 "
#~ "milliseconds."
#~ msgstr ""
#~ "``vote_delay``는 다음 피어에게 투표를 보내기까지의 밀리세컨드"
#~ " 단위의 대기시간입니다. 이 값은 네트워크 내의 "
#~ "Iroha 피어의 수에 따라 결정하는 것이 좋습니다 "
#~ "(노드의 수가 많아질수록 더 긴 ``vote_delay``가 "
#~ "필요합니다). 100-1000 밀리 세컨드로 시작하는 것을 "
#~ "추천합니다."

#~ msgid ""
#~ "``load_delay`` is a waiting time in "
#~ "milliseconds before loading committed block"
#~ " from next peer. We recommend setting"
#~ " this number the same value as "
#~ "``proposal_delay`` or even higher."
#~ msgstr ""
#~ "``load_delay``는 다음 피어로부터 커밋된 블록을 로딩하기까지"
#~ " 밀리세컨드 단위의 대기 시간입니다. 이 값을 "
#~ "``proposal_delay``값과 같거나 더 크게 설정하는 것을"
#~ " 추천합니다."

#~ msgid "Commands"
#~ msgstr "커맨드"

#~ msgid "Add asset quantity"
#~ msgstr "에셋 수량 늘리기"

#~ msgid "Add peer"
#~ msgstr "피어 추가하기"

#~ msgid "Add signatory"
#~ msgstr "서명 추하기"

#~ msgid "Append role"
#~ msgstr "역할 추가하기"

#~ msgid "Create account"
#~ msgstr "계정 생성하기"

#~ msgid "Create asset"
#~ msgstr "에셋 생성하기"

#~ msgid "Create domain"
#~ msgstr "도메인 생성하기"

#~ msgid "Create role"
#~ msgstr "역할 생성하기"

#~ msgid "Detach role"
#~ msgstr "역할 제거하기"

#~ msgid "Grant permission"
#~ msgstr "권한(Permission) 부여하기"

#~ msgid "Revoke permission"
#~ msgstr "권한(Permission) 제거하기"

#~ msgid "Set account detail"
#~ msgstr "계정 정보 설정하기"

#~ msgid "Set account quorum"
#~ msgstr "계정 정족수(quorum) 설정하기"

#~ msgid "Subtract asset quantity"
#~ msgstr "에셋 수량 줄이기"

#~ msgid "Transfer asset"
#~ msgstr "에셋 보내기"

#~ msgid "С++ library"
#~ msgstr "C++ 라이브러리"

#~ msgid ""
#~ "This section only contains code "
#~ "reference (autogenerated docs are possible "
#~ "with a description of arguments and "
#~ "return values)"
#~ msgstr "이 섹션은 코드 레퍼런스만 포함하고 있습니다.(자동으로 생성된 문서는 인수와 리턴값에 대한 설명이 있습니다)"

#~ msgid "Iroha API reference"
#~ msgstr "Iroha API 레퍼런스"

#~ msgid ""
#~ "In API section we will take a "
#~ "look at building blocks of an "
#~ "application interacting with Iroha. We "
#~ "will overview commands and queries that"
#~ " the system have, and the set "
#~ "of client libraries encompassing transport "
#~ "and application layer logic."
#~ msgstr ""
#~ "이 API 섹션에서 Iroha와 상호작용하는 어플리케이션의 "
#~ "블록을 만드는 과정을 살펴볼 것입니다. 명령어와 쿼리를 "
#~ "간략하게 살펴본 후 전송 레이어와 어플리케이션 레이어를 "
#~ "포함하는 클라이언트 라이브러리에 대해 알아볼 것입니다."

#~ msgid "Table of contents"
#~ msgstr "목차"

#~ msgid "Java library"
#~ msgstr "자바 라이브러리"

#~ msgid "NodeJS library"
#~ msgstr "NodeJS 라이브러리"

#~ msgid "Objective-C library"
#~ msgstr "Objective-C 라이브러리"

#~ msgid "Python library"
#~ msgstr "파이썬 라이브러리"

#~ msgid "Queries"
#~ msgstr "쿼리"

#~ msgid "Get account"
#~ msgstr "계정 조회하기"

#~ msgid "Get signatories"
#~ msgstr "서명자 얻기"

#~ msgid "Get transactions"
#~ msgstr "트랜젝션 얻기"

#~ msgid "Get account transactions"
#~ msgstr "계정의 트랜젝션 얻기"

#~ msgid "Get account asset transactions"
#~ msgstr "계정의 에셋의 트랜젝션 얻기"

#~ msgid "Get account assets"
#~ msgstr "계정 에셋 얻기"

#~ msgid "Get asset info"
#~ msgstr "에셋 정보 얻기"

#~ msgid "Get roles"
#~ msgstr "역할 얻기"

#~ msgid "Get role permissions"
#~ msgstr "역할 권한 얻기"

#~ msgid "Swift library"
#~ msgstr "Swift 라이브러리"

#~ msgid "Contribution"
#~ msgstr "기여"

#~ msgid "Code of conduct"
#~ msgstr "행동강령"

#~ msgid "Process"
#~ msgstr "프로세스"

#~ msgid "Communication"
#~ msgstr "커뮤니케이션"

#~ msgid "Issue tracker"
#~ msgstr "이슈 트래커"

#~ msgid "A term"
#~ msgstr ""

#~ msgid "B term"
#~ msgstr ""

#~ msgid "C term"
#~ msgstr ""

#~ msgid "Remaining parts (WSV, etc.)"
#~ msgstr "남은 부분(WSV 외)"

#~ msgid "Core concepts"
#~ msgstr "주요 개념"

#~ msgid ""
#~ "Why Iroha runs in a network? How"
#~ " to understand the objects inside and"
#~ " outside the system? How peers in "
#~ "the network collaborate and decide which"
#~ " data to put into the blockchain? "
#~ "We will look through the basics of"
#~ " Iroha in this section."
#~ msgstr ""
#~ "왜 Iroha는 네트워크에서 실행되고 있을까요? 시스템 내외의"
#~ " 여러 객체를 어떻게 이해해야 할까요? 네트워크의 "
#~ "피어들은 어떻게 작동하며 어떤 데이터를 `블록체인`에 넣을지"
#~ " 결정할까요? 이 섹션에서는 Iroha의 기초적인 개념에 "
#~ "대해 살펴보고자 합니다."

#~ msgid "Is having an account in Iroha means being a user?"
#~ msgstr "Iroha 상에서 계정(Account)를 가지고 있다는 것이 유저가 된다는 것을 의미하나요?"

#~ msgid "Are there differences compared to client-server systems?"
#~ msgstr "클라이언트-서버 시스템과 비교할 때 차이점이 있을까요?"

#~ msgid "Assets, domains and other internal objects"
#~ msgstr "에셋, 도메인, 다른 내부 객체들"

#~ msgid "Does everyone have to maintain their own peer?"
#~ msgstr "모든 사람이 각자의 피어들을 관리해야 합니까?"

#~ msgid "How peers communicate with each other?"
#~ msgstr "피어들은 서로 어떻게 통신할까요?"

#~ msgid "ER model"
#~ msgstr "ER 모델"

#~ msgid "Transaction"
#~ msgstr "트랜젝션"

#~ msgid "Transaction statuses"
#~ msgstr "트랜젝션 상태"

#~ msgid "Query"
#~ msgstr "쿼리"

#~ msgid "Validation"
#~ msgstr "검증"

#~ msgid "Stateless"
#~ msgstr "Stateless"

#~ msgid "Stateful"
#~ msgstr "Stateful"

#~ msgid "Glossary"
#~ msgstr "용어 사전"

#~ msgid "Getting Started"
#~ msgstr "시작하기"

#~ msgid ""
#~ "In this guide, we will create a"
#~ " very basic Iroha network, launch it,"
#~ " create a couple of transactions, and"
#~ " check the data written in the "
#~ "ledger. To keep things simple, we "
#~ "will use Docker."
#~ msgstr ""
#~ "이 가이드에서는 간단한 Iroha 네트워크를 만들고 실행시키며"
#~ " 몇 개의 트랜젝션을 만들어 볼 것입니다. 또한 "
#~ "원장(Ledger)에 쓰인 데이터를 확인해볼 것입니다. 가이드 "
#~ "진행을 쉽게 하기 위해 Docker를 사용할 것입니다."

#~ msgid ""
#~ "Ledger is the synonym for a "
#~ "blockchain, and Hyperledger Iroha is "
#~ "known also as Distributed Ledger "
#~ "Technology — which in essence is "
#~ "the same as \"blockchain framework\". "
#~ "You can check the rest of "
#~ "terminology used in the Glossary "
#~ "section."
#~ msgstr ""
#~ "원장은 블록체인과 동일한 의미를 가지고 있으며 "
#~ "Hyperledger Iroha는 분산원장기술(Distributed Ledger "
#~ "Technology)로도 알려져 있습니다. 이는 본질적으로 `블록체인"
#~ " 프레임워크`와 동일한 의미입니다. 용어사전 섹션에서 나머지 "
#~ "용어에 대해 확인할 수 있습니다."

#~ msgid ""
#~ "For this guide, you need a "
#~ "computer running Unix-like system with"
#~ " ``docker`` installed. You can read "
#~ "how to install it on a `Docker's"
#~ " website <https://www.docker.com/community-edition/>`_."
#~ msgstr ""
#~ "이 가이드를 따라하기 위해서는 컴퓨터에 Unix 계열의 "
#~ "시스템에 ``docker``가 설치되어 있어야 합니다. docker를"
#~ " 설치하는 방법은 `Docker 웹사이트 "
#~ "<https://www.docker.com/community-edition/>` 를 참고하시면"
#~ " 됩니다."

#~ msgid ""
#~ "Please note that you can use Iroha"
#~ " without ``docker`` as well. You can"
#~ " read about it in other parts "
#~ "of documentation."
#~ msgstr ""
#~ "``docker``를 쓰지 않고 Iroha를 사용할 수 "
#~ "있습니다. 이에 대한 자세한 사항은 문서의 다른 "
#~ "섹션을 참고하시면 됩니다."

#~ msgid "Starting Iroha Node"
#~ msgstr "Iroha 노드 시작하기"

#~ msgid "Creating a Docker Network"
#~ msgstr "도커 네트워크 생성하기"

#~ msgid ""
#~ "To operate, Iroha requires a "
#~ "``PostgreSQL`` database. Let's start with "
#~ "creating a Docker network, so containers"
#~ " for Postgres and Iroha can run "
#~ "on the same virtual network and "
#~ "successfully communicate. In this guide "
#~ "we will call it ``iroha-network``, "
#~ "but you can use any name. In "
#~ "your terminal write following command:"
#~ msgstr ""
#~ "Iroha는 ``PostgreSQL`` 데이터베이스를 필요로 합니다. "
#~ "우선 도커 네트워크를 생성하여 Postgres와 Iroha가 "
#~ "같은 가상 네트워크에서 실행되어 성공적으로 통신할 수 "
#~ "있게 합니다. 이 가이드에서는 방금 생성한 가상 "
#~ "네트워크를 ``Iroha-network``라고 부를 것이지만 원하는"
#~ " 이름으로 설정해도 됩니다. 터미널을 열어 다음 커맨드를"
#~ " 입력하세요."

#~ msgid "Starting PostgreSQL Container"
#~ msgstr "PostgreSQL 컨테이너 시작하기"

#~ msgid ""
#~ "Now we need to run ``PostgreSQL`` "
#~ "in a container, attach it to the"
#~ " network you have created before, and"
#~ " expose ports for communication:"
#~ msgstr ""
#~ "이제 컨테이너 안에서 ``PostgreSQL``을 실행하고 이를 "
#~ "방금 생성한 네트워크에 할당(attach)하고 통신을 위한 "
#~ "포트를 열어야 합니다."

#~ msgid ""
#~ "If you already have Postgres running "
#~ "on a host system on default port"
#~ " (5432), then you should pick another"
#~ " free port that will be occupied. "
#~ "For example, 5433: ``-p 5433:5432 \\``"
#~ msgstr ""
#~ "만약 Postgres가 호스트의 디폴트 포트(5432)에서 이미 "
#~ "실행되고 있다면 , 다른 포트를 선택해야 합니다. "
#~ "예를 들면, 5433:``-p 5433:5432 \\``"

#~ msgid "Creating Blockstore"
#~ msgstr "블록스토어 만들기"

#~ msgid ""
#~ "Before we run Iroha container, we "
#~ "should create persistent volume to store"
#~ " files, storing blocks for the chain."
#~ " It is done via the following "
#~ "command:"
#~ msgstr "Iroha 컨테이너를 실행하기 전에 아래의 명령어를 통해 블록을 저장할 데이터 볼륨을 만들어야 합니다."

#~ msgid "Configuring Iroha Network"
#~ msgstr "Iroha 네트워크 구성하기"

#~ msgid ""
#~ "To keep things simple, in this "
#~ "guide we will create a network "
#~ "containing only one node. To understand"
#~ " how to run several peers, follow "
#~ "this guide."
#~ msgstr ""
#~ "설명을 쉽게 하기 위해 이 가이드에서는 노드가 "
#~ "하나인 네트워크를 생성할 것입니다. 여러 노드가 작동하는"
#~ " 네트워크에 대해서 이해하려면 이 가이드를 따라하세요."

#~ msgid ""
#~ "Now we need to configure our Iroha"
#~ " network. This includes creating a "
#~ "configuration file, generating keypairs for"
#~ " a users, writing a list of "
#~ "peers and creating a genesis block. "
#~ "However, we have prepared an example "
#~ "configuration for this guide, so you "
#~ "can start playing with Iroha faster. "
#~ "In order to get those files, you"
#~ " need to clone the `Iroha repository"
#~ " <github.com/hyperledger/iroha>`_ from Github."
#~ msgstr ""
#~ "이제 Iroha 네트워크를 설정해야 합니다. 설정은 설정"
#~ " 파일 만들기외 유저의 키쌍 생성, 피어 리스트 "
#~ "작성, 제네시스 블록 생성 등의 작업을 포함합니다. "
#~ "하지만 이 가이드를 위한 설정 파일이 미리 "
#~ "준비되어있기 때문에 Iroha를 가지고 빨리 재미있는 것을"
#~ " 해볼 수 있습니다. 미리 준비된 설정 파일을 "
#~ "다운로드 받기 위해서는 깃허브에서 `Iroha repository "
#~ "<github.com/hyperledger/iroha>`를 클론해야 합니다."

#~ msgid ""
#~ "``--depth-1`` option allows us to "
#~ "download only latest commit and save "
#~ "some time and bandwidth. If you "
#~ "want to get a full commit history,"
#~ " you can omit this option."
#~ msgstr ""
#~ "``--depth-1`` 옵션은 가장 최근 커밋만을 다운받을 "
#~ "수 있게 해주어 시간과 대역폭을 절약할 수 "
#~ "있습니다. 만약 전체 커밋 히스토리를 다운받고 싶다면 "
#~ "이 옵션을 제외하면 됩니다."

#~ msgid "Starting Iroha Container"
#~ msgstr "Iroha 컨테이너 시작하기"

#~ msgid ""
#~ "We are ready to launch our Iroha"
#~ " container. Let's do it with the "
#~ "following command"
#~ msgstr "Iroha 컨테이너를 시작할 준비가 다 되었습니다. 아래 커맨드를 입력해보세요."

#~ msgid "Let's look in detail what this command does:"
#~ msgstr "이 커맨드가 무엇을 하는지 자세히 살펴봅시다:"

#~ msgid ""
#~ "``docker run -it --name iroha \\`` "
#~ "attaches you to docker container called"
#~ " ``iroha``"
#~ msgstr ""
#~ "``docker run -it --name iroha \\`` "
#~ "명령은 ``iroha``란 이름을 가지는 도커 컨테이너에 "
#~ "진입할 수 있게합니다."

#~ msgid ""
#~ "with ``$(pwd)/iroha/example:/opt/iroha_data \\`` we"
#~ " add a folder containing our prepared"
#~ " configuration to a docker container "
#~ "into ``/opt/iroha_data``."
#~ msgstr ""
#~ "``$(pwd)/iroha/example:/opt/iroha_data \\`` 명령으로 우리는"
#~ " 사전에 필요한 설정들이 들어있는 폴더를 도커 컨테이너"
#~ " 안의 ``/opt/iroha_data`` 폴더로 지정 시켰습니다."

#~ msgid ""
#~ "``-v blockstore:/tmp/block_store \\`` adds a"
#~ " persistent block storage which we "
#~ "created before to a container, so "
#~ "our blocks won't be lost after we"
#~ " stop the container"
#~ msgstr ""
#~ "``-v blockstore:/tmp/block_store \\`` 명령으로 블록"
#~ " 저장소가 지속성을 가지게 만들었습니다. 우리의 블록 "
#~ "데이터들은 컨테이너가 정지(stop) 된 이후에도 남아있을 "
#~ "겁니다."

#~ msgid ""
#~ "``--network=iroha-network \\`` adds our "
#~ "container to previously created ``iroha-"
#~ "network``, so Iroha and Postgres could"
#~ " see each other."
#~ msgstr ""
#~ "``--network=iroha-network \\`` 명령으로 전에 "
#~ "만들었던 ``iroha-network`` 에 컨테이너를 추가합니다."
#~ " 이를 통해 Iroha 와 Postgres 가 서로"
#~ " 연결되게 만들었습니다."

#~ msgid ""
#~ "``--entrypoint=/bin/bash \\`` Because ``hyperledger"
#~ "/iroha-docker`` has the custom script "
#~ "which runs after starting the container,"
#~ " we want to override it so we"
#~ " can start Iroha Daemon manually."
#~ msgstr ""
#~ "``--entrypoint=/bin/bash \\`` 명령은 ``hyperledger"
#~ "/iroha-docker`` 컨테이너가 실행된 직후 자동으로 특정"
#~ " 스크립트를 실행하게 만든 설정을 덮어씌워 우리가 "
#~ "수동으로 Iroha 데몬(Daemon) 을 실행할 수 있게"
#~ " 하기 위함입니다."

#~ msgid ""
#~ "``hyperledger/iroha-docker:develop`` is the "
#~ "image which has the ``develop`` branch."
#~ msgstr "``hyperledger/iroha-docker:develop`` 은 ``develop(개발 버전)`` 브렌치의 이미지 입니다."

#~ msgid "Launching Iroha Daemon"
#~ msgstr "Iroha 데몬 실행하기"

#~ msgid ""
#~ "Now you are in the interactive "
#~ "shell of Iroha's container. To actually"
#~ " run Iroha, we need to launch "
#~ "Iroha daemon – ``irohad``."
#~ msgstr ""
#~ "자 이제 Iroha 컨테이너 환경안에서 쉘을 띄웠습니다."
#~ " 실제로 Iroha 를 실행하기 위해선 우리는 Iroha"
#~ " 데몬을 실행시켜야 합니다 – ``irohad``."

#~ msgid ""
#~ "In the usual situation, you need "
#~ "to provide a config file, generate "
#~ "genesis block and keypair. However, as"
#~ " a part of this guide, we "
#~ "provide an example configuration for "
#~ "you. Please do not use these "
#~ "settings in a production. You can "
#~ "read more about configuration here."
#~ msgstr ""
#~ "원래 보통의 경우라면, 당신은 설정 파일을 작성하고, "
#~ "초기 블록(genesis block) 이나 키쌍(keypair) 등을"
#~ " 생성해야 하겠지만, 이 가이드를 진행하기 위에 우리는"
#~ " 미리 이런 설정들을 준비해두었습니다. 따라서 이 "
#~ "설정들은 실제 운영시에는 사용하지 마십시오. 추후에 이 "
#~ "설정들에 대한 내용을 찾아볼 수 있을 것입니다."

#~ msgid ""
#~ "Congratulations! You have an Iroha node"
#~ " up and running! In the next "
#~ "section, we will test it by "
#~ "sending some transactions."
#~ msgstr ""
#~ "축하합니다! Iroha 노드(node)가 문제없이 잘 구동되었네요."
#~ " 이 다음 섹션에서는 트랜잭션들을 전송하고 테스트 해볼"
#~ " 겁니다."

#~ msgid ""
#~ "You can get more information about "
#~ "``irohad`` and its launch options in "
#~ "this section"
#~ msgstr "이 섹션에서 ``irohad``에 대한 더 자세한 설명과 실행 옵션에 대해 알 수 있습니다."

#~ msgid "Interacting with Iroha Network"
#~ msgstr "Iroha 네트워크와 상호작용 하기"

#~ msgid ""
#~ "You can interact with Iroha using "
#~ "various ways. You can use our "
#~ "client libraries to write code in "
#~ "various programming languages (e.g. Java, "
#~ "Python, Javascript, Swift) which communicates"
#~ " with Iroha. Alternatively, you can "
#~ "use ``iroha-cli`` – our command-"
#~ "line tool for interacting with Iroha."
#~ " As a part of this guide, let's"
#~ " get familiar with ``iroha-cli``"
#~ msgstr ""
#~ "Iroha와 다양한 방법으로 상호작용할 수 있습니다. 다양한"
#~ " 언어(Java, Python, Javascript, Swift 등)로 "
#~ "Iroha와 상호작용할 수 있는 코드를 작성하기 위해 "
#~ "클라이언트 라이브러리를 이용할 수 있습니다. 아니면, "
#~ "Iroha와 상호작용할 수 있는 커맨드라인 툴인 "
#~ "``iroha-cli``를 이용할 수도 있습니다."

#~ msgid ""
#~ "Despite that ``iroha-cli`` is arguably"
#~ " the simplest way to start working"
#~ " with Iroha, ``iroha-cli`` was "
#~ "engineered very fast and lacks tests,"
#~ " so user experience might not be "
#~ "the best. For example, the order "
#~ "of menu items can differ from that"
#~ " you see in this guide. In the"
#~ " future, we will deliver a better "
#~ "version and appreciate contributions."
#~ msgstr "``iroha-cli``가 Iroha와 상호작용할 수 있는 가장 간단한 방법이지만 UI"

#~ msgid ""
#~ "Open a new terminal (note that "
#~ "Iroha container and ``irohad`` should be"
#~ " up and running) and attach to "
#~ "an ``iroha`` docker container:"
#~ msgstr ""
#~ "새로운 터미널을 여시고(Iroha 컨테이너와 ``irohad``는 "
#~ "실행되고 있어야 합니다.) ``iroha``도커 컨테이너에 접속합니다."

#~ msgid ""
#~ "Now you are in the interactive "
#~ "shell of Iroha's container again. We "
#~ "need to launch ``iroha-cli`` and "
#~ "pass an account name of the "
#~ "desired user. In our example, the "
#~ "account ``admin`` is already created in"
#~ " a ``test`` domain. Let's use this"
#~ " account to work with Iroha."
#~ msgstr ""
#~ "이제 Iroha 컨테이너의 대화형 쉘에 다시 들어와있습니다."
#~ " ``iroha-cli``를 실행하여 받는 사람의 계정 "
#~ "이름을 넘겨야 합니다. 이번 예시에서는 계정 이름 "
#~ "``admin``이 ``test``도메인 내부에 이미 생성되어 있습니다."
#~ " 이 계정을 이용해 Iroha를 작동시켜보겠습니다."

#~ msgid ""
#~ "Full account name has a ``@`` "
#~ "symbol between name and domain. Note "
#~ "that the keypair has the same "
#~ "name."
#~ msgstr "계정의 풀네임은 이름과 도메인 사이에  ``@`` 기호를 가지고 있습니다. 키쌍은 항상 같은 이름을 가진다는 것을 기억하세요."

#~ msgid "Creating the First Transaction"
#~ msgstr "첫 번째 트랜젝션 생성하기"

#~ msgid ""
#~ "You can see the interface of "
#~ "``iroha-cli`` now. Let's create a new"
#~ " asset, add some asset to the "
#~ "admin account and transfer it to "
#~ "other account. To achieve this, please"
#~ " choose option ``1. New transaction "
#~ "(tx)`` by writing ``tx`` or ``1`` "
#~ "to a console."
#~ msgstr ""
#~ "이제 ``iroha-cli``의 인터페이스를 볼 수 있습니다."
#~ " 새로운 에셋을 생성하고 관리자 계정에 에셋을 추가한"
#~ " 후 추가한 에셋을 다른 계정으로 보내보도록 하겠습니다."
#~ " 이를 위해 ``tx`` 또는 ``1``을 콘솔에 "
#~ "입력하여 ``1. New transaction (tx)`` 옵션을 "
#~ "선택하도록 하겠습니다."

#~ msgid ""
#~ "Now you can see a list of "
#~ "available commands. Let's try creating a"
#~ " new asset. Select ``14. Create Asset"
#~ " (crt_ast)``. Now enter a name for"
#~ " your asset, for example ``coolcoin``. "
#~ "Next, enter a Domain ID. In our"
#~ " example we already have a domain "
#~ "``test``, so let's use it. Then we"
#~ " need to enter an asset precision "
#~ "– the amount of numbers in a "
#~ "fractional part. Let's set precision to"
#~ " ``2``."
#~ msgstr ""
#~ "이제 사용 가능한 커맨드의 리스트를 볼 수 "
#~ "있습니다. 먼저, 새로운 에셋을 생성하도록 하겠습니다. "
#~ "``14. Create Asset (crt_ast)``를 선택하세요. "
#~ "이제 에셋의 이름을 입력해주세요. 예를 들면 "
#~ "``coolcoin``과 같은 이름 말이죠. 그 다음 도메인"
#~ " ID를 입력해주세요. 이번 예제에서는 ``test``라는 도메인이"
#~ " 이미 생성되어 있기 때문에 그걸 사용할 것입니다."
#~ " 그 다음 에셋의 정밀도 - 사용할 소수점 "
#~ "아래 자릿수 - 를 설정해야 합니다. 여기서는 "
#~ "정밀도를 ``2``로 설정해봅시다."

#~ msgid ""
#~ "Congratulations, you have created your "
#~ "first command and added it to a"
#~ " transaction! You can either send it"
#~ " to Iroha or add some more "
#~ "commands ``1. Add one more command "
#~ "to the transaction (add)``. Let's add"
#~ " more commands, so we can do "
#~ "everything in one shot. Type ``add``."
#~ msgstr ""
#~ "축하합니다! 첫 커맨드를 생성하여 트랜젝션에 추가하였습니다. "
#~ "이제 당신은 트랜젝션를 Iroha에 보내거나 더 많은 "
#~ "커맨드를 추가할 수 있습니다.  ``1. Add one "
#~ "more command to the transaction (add)``"
#~ " 한 번에 여러 작업을 할 수 있도록 더"
#~ " 많은 커맨드를 트랜젝션에 추가해봅시다. ``add``를 "
#~ "추가해보세요."

#~ msgid ""
#~ "Now try adding some ``coolcoins`` to "
#~ "our account. Select ``16. Add Asset "
#~ "Quantity (add_ast_qty)``, enter Account ID "
#~ "– ``admin@test``, asset ID – "
#~ "``coolcoin#test``, integer part and precision."
#~ " For example, to add 200.50 "
#~ "``coolcoins``, we need to enter integer"
#~ " part as ``20050`` and precision as"
#~ " ``2``, so it becomes ``200.50``."
#~ msgstr ""
#~ "이제 ``coolcoins``을 우리의 계정의 좀 더 "
#~ "추가해봅시다. ``16. Add Asset Quantity "
#~ "(add_ast_qty)``을 선택한 후 계정 ID(``admin@test``)와"
#~ "  에셋 ID(``coolcoin#test``), 정수 부분과 정밀도를 "
#~ "입력해주세요. 예를 들어 200.50의 ``coolcoins``을 "
#~ "추가하기 위해서는, 정수 부분으로 ``20050``를, 정밀도로 "
#~ "``2``을 입력하면 됩니다."

#~ msgid "Full asset name has a ``#`` symbol between name and domain."
#~ msgstr "에셋의 풀네임은 이름과 도메인 사이에 ``#``기호가 있습니다."

#~ msgid ""
#~ "Let's transfer 100.50 ``coolcoins`` from "
#~ "``admin@test`` to ``test@test`` by adding "
#~ "one more command and choosing ``5. "
#~ "Transfer Assets (tran_ast)``. Enter Source "
#~ "Account and Destination Account, in our"
#~ " case ``admin@test`` and ``test@test``, "
#~ "Asset ID (``coolcoin#test``), integer part "
#~ "and precision (``10050`` and ``2`` "
#~ "accordingly)."
#~ msgstr ""
#~ "하나의 커맨드를 더 추가하고 ``5. Transfer "
#~ "Assets (tran_ast)``을 선택하여 100.50의 "
#~ "``coolcoins``을 ``admin@test``에서 ``test@test``로 "
#~ "보내보겠습니다. 보내는 계정과 받을 계정을 입력해주세요. 이번"
#~ " 예시의 경우 보내는 계정은 ``admin@test``이고 받는"
#~ " 계정은 ``test@test``입니다. 그리고 에셋 ID "
#~ "(``coolcoin#test``), 정수 부분(``10050``)과 정밀도( "
#~ "``2``)를 입력하시면 됩니다."

#~ msgid ""
#~ "Now we need to send our "
#~ "transaction to Iroha peer (``2. Send "
#~ "to Iroha peer (send)``). Enter peer "
#~ "address (in our case ``localhost``) and"
#~ " port (``50051``). Congratulations, your "
#~ "transaction is submitted and you can "
#~ "see your transaction hash. You can "
#~ "use it to check transaction's status."
#~ msgstr ""
#~ "이제 우리가 만든 트랜젝션을 Iroha피어로 보내야 합니다"
#~ " (``2. Send to Iroha peer (send)``)."
#~ " 피어의 주소(여기서는 ``localhost``)와 포트(``50051``)를 "
#~ "입력하세요. 축하합니다, 트랜젝션이 전송되었으며 전송 결과로 "
#~ "트랜젝션의 해시값을 확인할 수 있습니다. 이 해시값으로 "
#~ "트랜젝션의 상태를 확인하는데도 사용할 수 있습니다."

#~ msgid ""
#~ "Go back to a terminal where "
#~ "``irohad`` is running. You can see "
#~ "logs of your transaction."
#~ msgstr "``irohad``가 실행되고 있는 터미널로 돌아가세요. 방금 보낸 트랜젝션에 대한 로그를 확인할 수 있습니다."

#~ msgid "Congratulations! You have submitted your first transaction to Iroha."
#~ msgstr "축하합니다! 당신이 첫 트랜젝션을 Iroha에 보냈습니다."

#~ msgid "Creating the First Query"
#~ msgstr "첫번째 쿼리 만들기"

#~ msgid ""
#~ "Now let's check if ``coolcoins`` were"
#~ " successfully transferred from ``admin@test`` "
#~ "to ``test@test``. Choose ``2. New query"
#~ " (qry)``. ``7. Get Account's Assets "
#~ "(get_acc_ast)`` can help you to check"
#~ " if ``test@test`` now has ``coolcoin``. "
#~ "Form a query in a similar way "
#~ "you did with commands you did with"
#~ " commands and ``1. Send to Iroha "
#~ "peer (send)``. Now you can see "
#~ "information about how many ``coolcoin`` "
#~ "does ``test@test`` have. It will look"
#~ " similar to this:"
#~ msgstr ""
#~ "이제 ``coolcoins``가 ``admin@test``에서 ``test@test``로"
#~ " 성공적으로 보내졌는지 확인해보겠습니다. ``2. New query"
#~ " (qry)``을 선택하세요. ``7. Get Account's "
#~ "Assets (get_acc_ast)``을 통해 ``test@test``계정이 "
#~ "``coolcoin``을 가지고 있는지 확인할 수 있습니다. "
#~ "Form a query in a similar way "
#~ "you did with commands you did with"
#~ " commands and ``1. Send to Iroha "
#~ "peer (send)``. 이제 당신은 ``test@test``계정이 "
#~ "얼마나 많은 ``coolcoin``을 갖고 있는지 확인할 수"
#~ " 있습니다. 결과는 아래와 비슷할 것입니다: "

#~ msgid ""
#~ "Congratulations! You have submitted your "
#~ "first query to Iroha and got a "
#~ "response!"
#~ msgstr "축하합니다! 당신은 드디어 Iroha 에 첫번째 쿼리를 제출하고 이에 대한 응답도 받았습니다."

#~ msgid ""
#~ "To get information about all available"
#~ " commands and queries please check "
#~ "our API section."
#~ msgstr "사용가능한 모든 커맨드나 쿼리에 대한 내용들은 본 문서의 API 절을 참고하세요."

#~ msgid "Being Badass"
#~ msgstr "악의적 노드 만들어보기"

#~ msgid ""
#~ "Let's try being badass and cheat "
#~ "Iroha. For example, let's transfer more"
#~ " ``coolcoins`` than ``admin@test`` has. Try"
#~ " to transfer 100000.00 ``coolcoins`` from"
#~ " ``admin@test`` to ``test@test``. Again, "
#~ "proceed to ``1. New transaction (tx)``,"
#~ " ``5. Transfer Assets (tran_ast)``, enter"
#~ " Source Account and Destination Account,"
#~ " in our case ``admin@test`` and "
#~ "``test@test``, Asset ID (``coolcoin#test``), "
#~ "integer part and precision (``10000000`` "
#~ "and ``2`` accordingly). Send a "
#~ "transaction to Iroha peer as you "
#~ "did before. Well, it says"
#~ msgstr ""
#~ "이번에는 Iroha를 속여봅시다. 예를 들어, ``admin@test``"
#~ " 가 가진 ``coolcoins``보다 많은 양을 보낸다고 "
#~ "합시다. 실험을 위해 100000.00 ``coolcoins``을 "
#~ "``admin@test``에서 ``test@test``로 보내봅시다. 위 섹션에서"
#~ " 했던 방법과 동일하게, ``1. New transaction"
#~ " (tx)``을 하고, ``5. Transfer Assets "
#~ "(tran_ast)``을 선택한 후, 보낼 계정과 받을 계정,"
#~ " 여기서는 ``admin@test``와 ``test@test``, 에셋 ID"
#~ " (``coolcoin#test``), 정수 부분과 정밀도(각각 "
#~ "``10000000``와``2``). 그 다음 트랜젝션을 Iroha에 "
#~ "보내보세요. 그 결과는 아래와 같습니다:"

#~ msgid ""
#~ "`Your transaction was accepted for "
#~ "processing`. Does it mean that we "
#~ "had successfully cheated Iroha? Let's "
#~ "try to see transaction's status. Choose"
#~ " ``3. New transaction status request "
#~ "(st)`` and enter transaction's hash "
#~ "which you can get in the console"
#~ " after the previous command. Let's "
#~ "send it to Iroha. It replies with:"
#~ msgstr ""
#~ "`Your transaction was accepted for "
#~ "processing`. 이 말이 트랜젝션이 성공적으로 실행되었다는 "
#~ "것을 의미할까요? 트랜젝션의 상태를 확인해 봅시다. ``3."
#~ " New transaction status request (st)``을 "
#~ "선택한 후 이전 커맨드를 통해 얻은 트랜젝션의 "
#~ "해시값을 입력하세요. 그 다음 Iroha에 보내세요. 이에"
#~ " 대한 응답은 다음과 같습니다:"

#~ msgid ""
#~ "Apparently no. Our transaction was not"
#~ " accepted because it did not pass "
#~ "stateful validation and ``coolcoins`` were "
#~ "not transferred. You can check the "
#~ "status of ``admin@test`` and ``test@test`` "
#~ "with queries to be sure (like we"
#~ " did earlier)."
#~ msgstr ""
#~ "분명히 아니라고 되어 있습니다. 우리가 만든 트랜젝션은 "
#~ "받아들여지지 않았습니다. stateful 검증을 통과하지 못했기 "
#~ "때문에 ``coolcoins``이 보내지지 않은 것입니다. 확실히 "
#~ "하기 위해 ``admin@test``와 ``test@test``의 상태도 "
#~ "앞서 했던 방식으로 쿼리를 보내 확인할 수 "
#~ "있습니다."

#~ msgid "Deploying Iroha"
#~ msgstr "Iroha 배포하기"

#~ msgid ""
#~ "Hyperledger Iroha can be deployed in "
#~ "different ways, depending on the "
#~ "perspective and the purpose. There can"
#~ " be either a single node deployed,"
#~ " or multiple nodes running in several"
#~ " containers on a local machine or "
#~ "spread across the network — so "
#~ "pick any case you need. This page"
#~ " describes different scenarios and is "
#~ "intended to act as a how-to "
#~ "guide for users, primarily trying out"
#~ " Iroha for the first time."
#~ msgstr ""
#~ "Hyperledger Iroha는 목적에 따라 다양한 방법으로 "
#~ "배포될 수 있습니다. 하나의 노드만을 배포하거나 하나의 "
#~ "로컬 머신의 여러 컨테이너에 여러 노드를 배포할 "
#~ "수도 있으며 여러 대의 머신에 배포할 수도 "
#~ "있습니다. 원하는 방식을 선택하세요. 이 페이지에서는 다양한"
#~ " 배포 시나리오에 대해 설명하며 Iroha를 처음 "
#~ "시도하는 사람들의 how-to 가이드와 같은 역할을 "
#~ "할 것입니다. "

#~ msgid "Running single instance"
#~ msgstr "하나의 인스턴스만 실행하기"

#~ msgid ""
#~ "Generally, people want to run Iroha "
#~ "locally in order to try out the"
#~ " API and explore the capabilities. "
#~ "This can be done in local or "
#~ "container environment (Docker). We will "
#~ "explore both possible cases, but in "
#~ "order to simplify peer components "
#~ "deployment, *it is advised to have "
#~ "Docker installed on your machine*."
#~ msgstr ""
#~ "일반적으로 사람들은 Iroha의 API와 성능을 확인하기 위해"
#~ " 로컬로 Iroha를 실행하기 원할 것입니다. 이는 로컬"
#~ " 또는 도커 컨테이너 환경에서 할 수 있습니다. "
#~ "우리는 이 두 가지 경우를 모두 살펴볼 것입니다."
#~ " 하지만 피어의 배포을 간단하게 하기 위해 *도커를"
#~ " 설치하여 Iroha를 실행해 보는 것을 권장합니다.*"

#~ msgid "Local environment"
#~ msgstr "로컬 환경"

#~ msgid ""
#~ "By local environment, it is meant "
#~ "to have daemon process and Postgres "
#~ "deployed without any containers. This "
#~ "might be helpful in cases when "
#~ "messing up with Docker is not "
#~ "preferred — generally a quick "
#~ "exploration of the features."
#~ msgstr ""
#~ "로컬 환경에서 실행한다는 것은 컨테이너를 사용하지 않고 "
#~ "데몬 프로세스와 Postgre를 배포한다는 것을 의미합니다. "
#~ "도커를 사용하지 않고 빠르게 기능을 알아보는데 유용합니다."

#~ msgid "Run postgres server"
#~ msgstr "postgres 서버 실행"

#~ msgid ""
#~ "In order to run postgres server "
#~ "locally, you should check postgres "
#~ "`website <https://www.postgresql.org/docs/current/static"
#~ "/server-start.html>`__ and follow their "
#~ "description. Generally, postgres server runs"
#~ " automatically when the system starts, "
#~ "but this should be checked in the"
#~ " configuration of the system."
#~ msgstr ""
#~ "Postgre 서버를 로컬에서 실행하기 위해서는 Postgre "
#~ "웹사이트 `website "
#~ "<https://www.postgresql.org/docs/current/static/server-"
#~ "start.html>`__에서 가이드를 따라하시면 됩니다. 일반적으로 "
#~ "Postgre 서버는 시스템이 부트된 후 자동적으로 실행되지만"
#~ " 시스템의 설정 상태를 확인해보셔야 합니다."

#~ msgid "Run iroha daemon (irohad)"
#~ msgstr "iroha 데몬 실행 (irohad)"

#~ msgid ""
#~ "There is a list of preconditions "
#~ "which you should meet before proceeding:"
#~ msgstr "아래에는 진행을 위한 요구 조건들의 리스트가 있습니다:"

#~ msgid "Postgres server is up and running"
#~ msgstr "Postgres 서버가 정상적으로 구동되어야 합니다."

#~ msgid "`irohad` Iroha daemon binary is built and accessible in your system"
#~ msgstr "Iroha 데몬 바이너리인 `irohad`는 빌드되어 있으며 시스템에서 접근 가능해야 합니다."

#~ msgid "The genesis block and configuration files were created"
#~ msgstr "genesis 블럭과 설정파일들이 생성되어 있어야 합니다."

#~ msgid "Config file uses valid postgres connection settings"
#~ msgstr "설정 파일이 valid한 Postgres 연결 세팅을 사용하고 있어야 합니다."

#~ msgid "A keypair for the peer is generated"
#~ msgstr "피어의 키쌍(keypair)이 생성되어 있어야 합니다."

#~ msgid ""
#~ "This is the first time you run "
#~ "the Iroha on this peer and you "
#~ "want to create new chain"
#~ msgstr "이번 피어에서 처음으로 Iroha를 실행하는 중이어야 하며 새로운 체인을 생성하는 것을 목적으로 해야 합니다."

#~ msgid ""
#~ "Have you got something that is not"
#~ " the same as in the list of "
#~ "assumptions? Please, refer to the "
#~ "section below the document, titled as"
#~ " `Dealing with troubles`_."
#~ msgstr "위의 조건들 중 맞지 않는 경우가 있습니까? 그렇다면, `Dealing with troubles`_섹션을 참고해보세요."

#~ msgid ""
#~ "In case of valid assumptions, the "
#~ "only thing that remains is to "
#~ "launch the daemon process with following"
#~ " parameters:"
#~ msgstr "모든 조건들이 충족되었다면 아래 파라미터로 Iroha 데몬 프로세스를 실행하는 일만 남았습니다:"

#~ msgid "Parameter"
#~ msgstr "파라미터"

#~ msgid "Meaning"
#~ msgstr "의미"

#~ msgid "config"
#~ msgstr "설정"

#~ msgid ""
#~ "configuration file, containing postgres "
#~ "connection and values to tune the "
#~ "system"
#~ msgstr "postres 연결 설정과 시스템 조정을 위한 값들이 담긴 설정 파일"

#~ msgid "genesis_block"
#~ msgstr "genesis_block"

#~ msgid "initial block in the ledger"
#~ msgstr "레저의 첫 블록"

#~ msgid "keypair_name"
#~ msgstr "keypair_name"

#~ msgid ""
#~ "private and public key file names "
#~ "without file extension, used by peer "
#~ "to sign the blocks"
#~ msgstr "피어가 블록을 서명하는데 사용한 개인키와 공개키 파일 이름, 확장자 명은 제외"

#~ msgid "An example of shell command, running Iroha daemon is"
#~ msgstr "쉘 커맨드로 Iroha 데몬을 실행하는 예시는 아래와 같습니다."

#~ msgid ""
#~ "If you have stopped the daemon and"
#~ " want to use existing chain — "
#~ "you should not pass the genesis "
#~ "block parameter."
#~ msgstr "만약 데몬이 멈추거나 기존에 존재하는 체인을 이용하고 싶으면 제너시스 블록 파라미터를 넘기지 않으면 됩니다."

#~ msgid "Docker"
#~ msgstr "Docker"

#~ msgid ""
#~ "In order to run Iroha peer as "
#~ "a single instance in Docker, you "
#~ "should pull the image for Iroha "
#~ "first:"
#~ msgstr "Iroha 피어를 도커를 통해 하나의 인스턴스로 실행하기 위해서는 Iroha 도커 미이지를 풀(Pull) 받아야 합니다."

#~ msgid ""
#~ "Use *latest* tag for latest stable "
#~ "release, and *develop* for latest "
#~ "development version"
#~ msgstr ""
#~ "최신의 stable 릴리즈를 원하시면 *latest* 태그를 "
#~ "이용하시고, 최신 개발 버전을 원하시면 *develop* "
#~ "태그를 이용해보세요."

#~ msgid ""
#~ "Then, you have to create an "
#~ "enviroment for the image to run "
#~ "without problems:"
#~ msgstr "그 다음에는 문제없이 실행하기 위해 이미지를 위한 환경을 만들어야 합니다."

#~ msgid "Create docker network"
#~ msgstr "docker 네트워크 생성"

#~ msgid ""
#~ "Containers for Postgres and Iroha should"
#~ " run in the same virtual network, "
#~ "in order to be available to each"
#~ " other. Create a network, by typing"
#~ " following command (you can use any"
#~ " name for the network, but in "
#~ "the example, we use *iroha-network* "
#~ "name):"
#~ msgstr ""
#~ "Postgres와 Iroha의 컨테이너는 같은 가상 네트워크 "
#~ "내에서 실행되어야 합니다.  아래 커맨드를 통해 네트워크를"
#~ " 생성하세요(네트워크 이름은 어떤 이름이어도 상관 없습니다. "
#~ "여기서는 *iroha-network*라는 이름을 사용하도록 "
#~ "하겠습니다.)."

#~ msgid "Run Postgresql in a container"
#~ msgstr "Postgresql 을 컨테이너 환경에서 실행"

#~ msgid ""
#~ "Similarly, run postgres server, attaching "
#~ "it to the network you have created"
#~ " before, and exposing ports for "
#~ "communication:"
#~ msgstr "마찬가지로, 방금 생성한 네트워크에 attach하고 포트를 열어 Postgres 서버를 실행하세요:"

#~ msgid "Create volume for block storage"
#~ msgstr "블록 저장공간(block storage)을 위한 볼륨(volume) 생성"

#~ msgid ""
#~ "Before we run iroha daemon in the"
#~ " container, we should create persistent "
#~ "volume to store files, storing blocks"
#~ " for the chain. It is done via"
#~ " the following command:"
#~ msgstr ""
#~ "Iroha 데몬을 컨테이너에서 실행하기 전에, 체인의 블록들을"
#~ " 저장할 볼륨(또는 데이터 볼륨)을 생성해야 합니다. "
#~ "아래 커맨드를 통해 볼륨을 생성할 수 있습니다."

#~ msgid "Running iroha daemon in docker container"
#~ msgstr "iroha 데몬(daemon)을 컨테이너 환경에서 실행"

#~ msgid ""
#~ "There is a list of assumptions "
#~ "which you should review before "
#~ "proceeding:"
#~ msgstr "아래 내용을 따라하기 전에 확인해야 할 몇 가지 사항이 있습니다:"

#~ msgid "Postgres server is running on the same docker network"
#~ msgstr "Postgres 서버는 같은 도커 네트워크 내에서 실행되고 있어야 합니다."

#~ msgid "There is a folder, containing config file and keypair for a single node"
#~ msgstr "설정 파일과 하나의 노드에 대한 키쌍이 들어있는 폴더가 있어야 합니다."

#~ msgid "If they are met, you can move forward with the following command:"
#~ msgstr "만약 이것이 충족되면 아래 커맨드를 통해 진행하시면 됩니다:"

#~ msgid "Running multiple instances (peer network)"
#~ msgstr "여러 인스턴스를 실행하기(피어 네트워크)"

#~ msgid ""
#~ "In order to set up a peer "
#~ "network, one should follow routines, "
#~ "described in this section. In this "
#~ "version, we support manual deployment "
#~ "and automated by Ansible Playbook. "
#~ "Choose an option, that meets your "
#~ "security criteria and other needs."
#~ msgstr ""
#~ "피어 네트워크를 구축하기 위해서는 이 섹션에서 설명하는 "
#~ "일련의 작업들을 해야 합니다. 이 버전은 직접 "
#~ "배포하는 것과 Ansible Playbook을 통해 자동 "
#~ "배포하는 것 모두를 지원합니다. 당신의 보안 기준과 "
#~ "필요에 맞는 방법을 선택하세요."

#~ msgid "Manually"
#~ msgstr "직접 배포하기"

#~ msgid ""
#~ "By manual deployment, we mean that "
#~ "Iroha peer network is set up "
#~ "without automated assistance. It is "
#~ "similar to the process of running "
#~ "a single local instance, although the"
#~ " difference is the genesis block "
#~ "includes more than a single peer. "
#~ "In order to form a block, which"
#~ " includes more than a single peer,"
#~ " or requires customization for your "
#~ "needs, please take a look at "
#~ "`Dealing with troubles`_ section."
#~ msgstr ""
#~ "직접 배포한다는 것은 배포 자동화 도구 없이 "
#~ "Iroha 피어 네트워크를 구축하는 것을 의미합니다. 이는"
#~ " 제네시스 블록이 2개 이상의 피어를 포함한다는 차이점을"
#~ " 제외하고 하나의 로컬 인스턴스를 실행하는 과정과 "
#~ "유사합니다. 2개 이상의 피어가 포함되거나 더 많은 "
#~ "커스터마이징이 된 블록을 생성하기 위해서는 `Dealing "
#~ "with troubles`_ 섹션을 확인해 보세요."

#~ msgid "Automated"
#~ msgstr "자동"

#~ msgid ""
#~ "Anyone can reuse existing Ansible "
#~ "Playbook in order to create a "
#~ "network of peers running Iroha. "
#~ "Currently, this is a solution for "
#~ "development and testing, in other words,"
#~ " a proof of concept, and cannot "
#~ "be used in production environment, due"
#~ " to some security flaws. For "
#~ "production network, a manual composing "
#~ "of genesis block is required."
#~ msgstr ""
#~ "누구든지 Iroha를 실행하는 피어 네트워크를 구축하기 위해"
#~ " 기존에 존재하는 Ansible Playbook을 재사용할 수"
#~ " 있습니다. 현재, 개발과 테스트(혹은 개념증명, POC)를 "
#~ "위한 방법이며 몇 가지 보안상의 결함 때문에 "
#~ "프로덕션 레벨에서는 사용할 수 없습니다. 프로덕션 레벨의"
#~ " 네트워크를 구축하기 위해서는 직접 제네시스 블록을 "
#~ "구성하는 것이 필요합니다."

#~ msgid "One ore more <virtual> machines with a Linux distributive installed."
#~ msgstr "리눅스가 설치된 하나 이상의 <가상> 머신이 필요합니다."

#~ msgid "SSH access to those machines"
#~ msgstr "그 머신에 SSH 엑세스가 가능해야 합니다."

#~ msgid "Ansible installed on a local machine"
#~ msgstr "Ansible이 로컬 머신에 설치되어 있어야 합니다."

#~ msgid "Step-by-step guide"
#~ msgstr "단계별 가이드"

#~ msgid "Create peers.list file in $IROHA_HOME/deploy/ansible/data"
#~ msgstr "peers.list 파일을 $IROHA_HOME/deploy/ansible/data에 생성합니다."

#~ msgid ""
#~ "Write all peers IP addresses followed"
#~ " by the internal port 10001 (e.g "
#~ "31.192.120.36:10001)"
#~ msgstr "모든 피어들의 IP 주소를 적고 내부 포트 번호인 10001을 적습니다.(예를 들면 31.192.120.36:10001)"

#~ msgid "Open $IROHA_HOME/deploy/ansible/hosts file"
#~ msgstr "$IROHA_HOME/deploy/ansible/hosts 파일을 오픈합니다."

#~ msgid "Write all IP addresses in [hosts] group"
#~ msgstr "[hosts] 그룹의 모든 IP 주소를 적습니다."

#~ msgid "Open terminal"
#~ msgstr "터미널을 오픈합니다."

#~ msgid ""
#~ "Disable host key checking, because it"
#~ " can cause troubles due to "
#~ "interactive prompt"
#~ msgstr ""
#~ "호스트 키 체크(host key checking)를 비활성화 "
#~ "합니다. Interactive prompt로 인한 문제가 생길 "
#~ "수 있습니다."

#~ msgid "Go to ansible folder"
#~ msgstr "Ansible 폴더로 갑니다."

#~ msgid "Run playbook, providing your private key and hosts file"
#~ msgstr "Playbook을 실행합니다. 개인키와 호스트 파일을 인수로 넘겨야 합니다."

#~ msgid "Wait until playbook finishes and then Iroha network is ready and up."
#~ msgstr "playbook이 끝날 때까지 기다리면 Iroha 네트워크가 실행될 준비가 된 것입니다."

#~ msgid "Checking Iroha peer status"
#~ msgstr "Iroha 피어의 상태 확인하기"

#~ msgid "SSH into any of your machines"
#~ msgstr "머신에 SSH로 접속합니다."

#~ msgid "Check Iroha container logs:"
#~ msgstr "Iroha 컨테이너의 로그를 확인합니다."

#~ msgid "Dealing with troubles"
#~ msgstr "문제 해결하기"

#~ msgid "—\"Please, help me, because I am…\""
#~ msgstr "—\"제발 도와주세요. 왜냐하면 저는...\""

#~ msgid "Not having Iroha daemon binary"
#~ msgstr "Iroha 데몬 바이너리를 가지고 있지 않습니다."

#~ msgid ""
#~ "You can build Iroha daemon binary "
#~ "from sources, following API section from"
#~ " the `website <https://hyperledger.github.io/iroha-"
#~ "api/#build>`__"
#~ msgstr ""
#~ "Iroha 데몬 바이너리를 소스에서 직접 빌드할 수 "
#~ "있습니다. `API 섹션  <https://hyperledger.github.io"
#~ "/iroha-api/#build>`__을 참고하세요"

#~ msgid "Not having config file"
#~ msgstr "설정 파일이 없습니다."

#~ msgid ""
#~ "Check how to create a configuration "
#~ "file by following this `link "
#~ "<https://hyperledger.github.io/iroha-api/#prepare-"
#~ "configuration-file>`__"
#~ msgstr ""
#~ "어떻게 설정 파일을 만드는지 `여기 "
#~ "<https://hyperledger.github.io/iroha-api/#prepare-"
#~ "configuration-file>`__에서 확인해보세요."

#~ msgid "Not having genesis block"
#~ msgstr "제너시스 블록이 없어요."

#~ msgid ""
#~ "Create genesis block by generating it"
#~ " via `iroha-cli` or manually, as "
#~ "it is described `here "
#~ "<https://hyperledger.github.io/iroha-api/#create-"
#~ "genesis-block>`__"
#~ msgstr ""
#~ "`iroha-cli`을 통해 또는 직접 제네시스 블록을 "
#~ "생성할 수 있습니다. `여기 <https://hyperledger.github.io"
#~ "/iroha-api/#create-genesis-block>`__를 확인해 "
#~ "보세요."

#~ msgid "Not having a keypair for a peer"
#~ msgstr "피어의 키쌍이 없어요."

#~ msgid ""
#~ "In order to create a keypair for"
#~ " an account or a peer, use "
#~ "iroha-cli binary by passing the name"
#~ " of the peer with `--new_account` "
#~ "option."
#~ msgstr ""
#~ "계정이나 피어의 키쌍을 생성하기 위해서 iroha-cli"
#~ " 바이너리를 사용하세요. `--new_account` 옵션과 피어의 "
#~ "이름을 같이 인수로 넘겨주면 됩니다."

#~ msgid "Guides and how-tos"
#~ msgstr "시작 가이드"

#~ msgid ""
#~ "Here we will take a look more "
#~ "closely at how to use Iroha. In"
#~ " essence, this section is a "
#~ "collection of how-tos for different "
#~ "scenarios: - how to install Iroha "
#~ "- what is required to build client"
#~ " libraries and how to use them "
#~ "(for example https://developers.google.com/protocol-"
#~ "buffers/docs/javatutorial) - how to use "
#~ "CLI - how to deploy a network "
#~ "of Iroha peers, etc."
#~ msgstr ""
#~ "여기서는 Iroha의 사용 방법에 대해 보다 자세히 "
#~ "알아봅니다. 다양한 시나리오에 대한 방법의 모음으로 볼 "
#~ "수도 있습니다. Iroha의 설치 방법, 클라이언트 빌드에"
#~ " 필요한 것과 사용하는 방법(예를 들어 "
#~ "https://developers.google.com/protocol-"
#~ "buffers/docs/javatutorial), CLI 사용법, Iroha 피어"
#~ " 네트워크를 배포하는 방법 등이 있습니다."

#~ msgid "Client libraries"
#~ msgstr "클라이언트 라이브러리"

#~ msgid "C++ library"
#~ msgstr "C++ 라이브러리"

#~ msgid "Where to get"
#~ msgstr "얻을 수 있는 곳"

#~ msgid "How to use/import"
#~ msgstr "사용 및 import 방법"

#~ msgid "Troubleshooting"
#~ msgstr "트러블슈팅"

#~ msgid "Troubleshoting"
#~ msgstr "트러블슈팅"

#~ msgid "Maintenance"
#~ msgstr "유지보수"

#~ msgid ""
#~ "Hardware requirements, deployment process in"
#~ " details, aspects related to security, "
#~ "configuration files — all of the "
#~ "listed is explained in this separate "
#~ "section, helpful for DevOps engineers or"
#~ " those who are digging deeper in "
#~ "the system capabilities."
#~ msgstr ""
#~ "하드웨어 요구사항, 배포 프로세스에 대한 세부 내용, "
#~ "보안 관련 사항, 설정파일은 각각 서로 다른 "
#~ "섹션에서 다루고 있습니다. 데브옵스(DevOps) 엔지니어나 시스템"
#~ " capability에 대해 깊게 알아보고 싶은 분들에게 "
#~ "도움이 될 것입니다."

#~ msgid "Ansible"
#~ msgstr "Ansible"

#~ msgid "Use Case Scenarios"
#~ msgstr "유즈케이스 시나리오"

#~ msgid ""
#~ "We list a number of use cases "
#~ "and specific advantages that Hyperledger "
#~ "Iroha can introduce to these "
#~ "applications. We hope that the "
#~ "applications and use cases will inspire"
#~ " developers and creators to further "
#~ "innovation with Hyperledger Iroha."
#~ msgstr ""

#~ msgid "Certificates in Education, Healthcare"
#~ msgstr ""

#~ msgid ""
#~ "Hyperledger Iroha incorporates into the "
#~ "system multiple certifying authorities such"
#~ " as universities, schools, and medical "
#~ "institutions. Flexible permission model used"
#~ " in Hyperledger Iroha allows building "
#~ "certifying identities, and grant certificates."
#~ " The storage of explicit and implicit"
#~ " information in users' account allows "
#~ "building various reputation and identity "
#~ "systems."
#~ msgstr ""

#~ msgid ""
#~ "By using Hyperledger Iroha each "
#~ "education or medical certificate can be"
#~ " verified that it was issued by "
#~ "certain certifying authorities. Immutability "
#~ "and clear validation rules provide "
#~ "transparency to health and education "
#~ "significantly reducing the usage of fake"
#~ " certificates."
#~ msgstr ""

#~ msgid "Example"
#~ msgstr ""

#~ msgid ""
#~ "Imagine a medical institution registered "
#~ "as a ``hospital`` domain in Hyperledger"
#~ " Iroha. This domain has certified and"
#~ " registered workers each having some "
#~ "role, e.g. ``physician``, ``therapist``, "
#~ "``nurse``. Each patient of the hospital"
#~ " has an account with full medical "
#~ "history. Each medical record, like blood"
#~ " test results, is securely and "
#~ "privately stored in the account of "
#~ "the patient as JSON key/values. Rules"
#~ " in ``hospital`` domain are defined "
#~ "such that only certified medical workers"
#~ " and the user can access the "
#~ "personal information. The medical data "
#~ "returned by a query is verified "
#~ "that it comes from a trusted "
#~ "source."
#~ msgstr ""

#~ msgid ""
#~ "Hospital is tied to a specific "
#~ "location, following legal rules of that"
#~ " location, like storing personal data "
#~ "of citizens only in specific "
#~ "regions(`privacy rules`_). A multi-domain "
#~ "approach in Hyperledger Iroha allows "
#~ "sharing information across multiple countries"
#~ " not violating legal rules. For "
#~ "example, if the user ``makoto@hospital`` "
#~ "decides to share personal case history"
#~ " with a medical institution in "
#~ "another country, the user can use "
#~ "``grant`` command with permission "
#~ "``can_get_my_acc_detail``."
#~ msgstr ""

#~ msgid ""
#~ "Similar to a medical institution, a "
#~ "registered university in Hyperledger Iroha "
#~ "has permissions to push information to"
#~ " the graduated students. A diploma or"
#~ " certificate is essentially Proof-of-"
#~ "Graduation with a signature of "
#~ "recognized University. This approach helps "
#~ "to ease hiring process, with an "
#~ "employer making a query to Hyperledger"
#~ " Iroha to get the acquired skills "
#~ "and competence of the potential "
#~ "employee."
#~ msgstr ""

#~ msgid "Cross-Border Asset Transfers"
#~ msgstr ""

#~ msgid ""
#~ "Hyperledger Iroha provides fast and "
#~ "clear trade and settlement rules using"
#~ " multi-signature accounts and atomic "
#~ "exchange. Asset management is easy as"
#~ " in centralized systems while providing "
#~ "necessary security guarantees. By simplifying"
#~ " the rules and commands required to"
#~ " create and transfer assets, we lower"
#~ " the barrier to entry, while at "
#~ "the same time maintaining high-security"
#~ " guarantees."
#~ msgstr ""

#~ msgid ""
#~ "For example [#f1]_, a user might "
#~ "want to transfer the ownership of "
#~ "a car. User ``haruto`` has registered"
#~ " owner-asset relationship with a car"
#~ " of ``sora`` brand with parameters: "
#~ "``{\"id\": \"34322069732074686520616E73776572\", "
#~ "\"color\": \"red\", \"size\": \"small\"}``. "
#~ "This ownership is fixed in an "
#~ "underlying database of the system with"
#~ " copies at each validating peer. To"
#~ " perform the transfer operation user "
#~ "``haruto`` creates an offer, i.e. a "
#~ "multi-signature transaction with two "
#~ "commands: ``transfer`` to user ``haru`` "
#~ "the car identifier and ``transfer`` some"
#~ " amount of ``usd`` tokens from "
#~ "``haru`` to ``haruto``. Upon receiving "
#~ "the offer ``haru`` accepts it by "
#~ "signing the multi-signature transaction, "
#~ "in this case, transaction atomically "
#~ "commits to the system."
#~ msgstr ""

#~ msgid ""
#~ "Hypeledger Iroha has no built-in "
#~ "token, but it supports different assets"
#~ " from various creators. This approach "
#~ "allows building a decentralized exchange "
#~ "market. For example, the system can "
#~ "have central banks from different "
#~ "countries to issue assets."
#~ msgstr ""

#~ msgid "Currently not implemented"
#~ msgstr ""

#~ msgid "Financial Applications"
#~ msgstr ""

#~ msgid ""
#~ "Hyperleger Iroha can be very useful "
#~ "in the auditing process. Each "
#~ "information is validated by business "
#~ "rules and is constantly maintained by"
#~ " distinct network participants. Access "
#~ "control rules along with some encryption"
#~ " maintain desired level of privacy. "
#~ "Access control rules can be defined "
#~ "at different levels: user-level, "
#~ "domain-level or system-level. At the"
#~ " user-level privacy rules for a "
#~ "specific individual are defined. If "
#~ "access rules are determined at domain"
#~ " or system level, they are affecting"
#~ " all users in the domain. In "
#~ "Hyperledger Iroha we provide convenient "
#~ "role-based access control rules, where "
#~ "each role has specific permissions."
#~ msgstr ""

#~ msgid ""
#~ "Transactions can be traced with a "
#~ "local database. Using Iroha-API auditor"
#~ " can query and perform analytics on"
#~ " the data, execute specific audit "
#~ "software. Hyperledger Iroha supports different"
#~ " scenarios for deploying analytics "
#~ "software:  on a local computer, or "
#~ "execute code on specific middleware. "
#~ "This approach allows analyzing Big Data"
#~ " application with Hadoop, Apache, and "
#~ "others. Hypeledger Iroha serves as a "
#~ "guarantor of data integrity and privacy"
#~ " (due to the query permissions "
#~ "restriction)."
#~ msgstr ""

#~ msgid ""
#~ "For example, auditing can be helpful "
#~ "in financial applications. An auditor "
#~ "account has a role of the "
#~ "``auditor`` with permissions to access "
#~ "the information of users in the "
#~ "domain without bothering the user. To"
#~ " reduce the probability of account "
#~ "hijacking and prevent the auditor from"
#~ " sending malicious queries, the auditor "
#~ "is typically defined as a multi-"
#~ "signature account, meaning that auditor "
#~ "can make queries only having signatures"
#~ " from multiple separate identities. The "
#~ "auditor can make queries not only "
#~ "to fetch account data and balance "
#~ "but also all transactions of a "
#~ "user, e.g. all transfers of user "
#~ "``haruto`` in domain ``konoha``. To "
#~ "efficiently analyze data of million "
#~ "users each Iroha node can work in"
#~ " tandem with analytics software."
#~ msgstr ""

#~ msgid ""
#~ "Multi-signature transactions are a "
#~ "powerful tool of Hyperledger Iroha that"
#~ " can disrupt tax system. Each "
#~ "transaction in a certain domain can "
#~ "be as a multi-signature transaction, "
#~ "where one signature comes from the "
#~ "user (for example asset transfer) and"
#~ " the second signature comes from "
#~ "special taxing nodes. Taxing nodes will"
#~ " have special validation rules written "
#~ "using Iroha-API, e.g. each purchase "
#~ "in the certified stores must pay "
#~ "taxes. In other words, Iroha a "
#~ "valid purchase transaction must contain "
#~ "two commands: money transfer(purchase) to "
#~ "the store and money transfer(tax "
#~ "payment) to the government."
#~ msgstr ""

#~ msgid "Identity Management"
#~ msgstr ""

#~ msgid ""
#~ "Hyperledger Iroha has an intrinsic "
#~ "support for identity management. Each "
#~ "user in the system has a uniquely"
#~ " identified account with personal "
#~ "information, and each transaction is "
#~ "signed and associated with a certain "
#~ "user. This makes Hyperledger Iroha "
#~ "perfect for various application with KYC"
#~ " (Know Your Customer) features."
#~ msgstr ""

#~ msgid ""
#~ "For example, insurance companies can "
#~ "benefit from querying the information of"
#~ " user’s transaction without worrying about"
#~ " the information truthfulness. Users can"
#~ " also benefit from storing personal "
#~ "information on a blockchain since "
#~ "authenticated information will reduce the "
#~ "time of claims processing. Imagine a "
#~ "situation where a user wants to "
#~ "make a hard money loan. Currently, "
#~ "pre-qualification is a tedious process"
#~ " of gathering information about income, "
#~ "debts and information verification. Each "
#~ "user in Hyperledger Iroha has an "
#~ "account with verified personal information,"
#~ " such as owning assets, job "
#~ "positions, and debts. User income and"
#~ " debts can be traced using query "
#~ "``GetAccountTransactions``, owning assets using "
#~ "query ``GetAccountAssets`` and job positions"
#~ " using ``GetAccountDetail``. Each query "
#~ "returns verified result reducing the "
#~ "processing time of hard money loan "
#~ "will take only a few seconds. To"
#~ " incentivize users to share personal "
#~ "information, various companies can come "
#~ "up with business processes. For example,"
#~ " insurance companies can create bonus "
#~ "discounts for users making fitness "
#~ "activities. Fitness applications can push "
#~ "private Proof-of-Activity to the "
#~ "system, and the user can decide "
#~ "later to share information with "
#~ "insurance companies using ``GrantPermission`` "
#~ "with permission ``can_get_my_acc_detail``."
#~ msgstr ""

#~ msgid "Supply Chain"
#~ msgstr ""

#~ msgid ""
#~ "Governance of a decentralized system and"
#~ " representing legal rules as a "
#~ "system's code is an essential "
#~ "combination of any supply chain system."
#~ " Certification system used in Hyperledger"
#~ " Iroha allows tokenization of physical "
#~ "items and embedding them into the "
#~ "system. Each item comes with the "
#~ "information about “what, when, where and"
#~ " why”."
#~ msgstr ""

#~ msgid ""
#~ "Permission systems and restricted set of"
#~ " secure core commands narrows the "
#~ "attack vector and provides effortlessly "
#~ "a basic level of privacy. Each "
#~ "transaction is traceable within a system"
#~ " with a hash value, by the "
#~ "credentials or certificates of the "
#~ "creator."
#~ msgstr ""

#~ msgid ""
#~ "Food supply chain is a shared "
#~ "system with multiple different actors, "
#~ "such as farmers, storehouses, grocery "
#~ "stores, and customers. The goal is "
#~ "to deliver food from a farmer's "
#~ "field to the table of a customer."
#~ " The product goes through many "
#~ "stages, with each stage recorded in "
#~ "shared space. A customer scans a "
#~ "code of the product via a mobile"
#~ " device, in which an Iroha query "
#~ "is encoded. Iroha query provides a "
#~ "full history with all stages, "
#~ "information about the product and the"
#~ " farmer."
#~ msgstr ""

#~ msgid ""
#~ "For example, ``gangreen`` is a "
#~ "registered farmer ``tomato`` asset creator,"
#~ " he serves as a guarantor tokenizing"
#~ " physical items, i.e. associating each "
#~ "tomato with an Iroha ``tomato`` item."
#~ " Asset creation and distribution processes"
#~ " are totally transparent for network "
#~ "participants. Iroha ``tomato`` goes on a"
#~ " journey through a multitude of "
#~ "vendors to finally come to user "
#~ "``chad``."
#~ msgstr ""

#~ msgid ""
#~ "We simplified asset creation to just "
#~ "a single command ``CreateAsset`` without "
#~ "the need to create complex smart "
#~ "contracts. One the major advantages of"
#~ " Hyperledger Iroha is in its ease,"
#~ " that allows developers to focus on"
#~ " the provided value of their "
#~ "applications."
#~ msgstr ""

#~ msgid "Related Research"
#~ msgstr "관련 리서"

#~ msgid ""
#~ "(The idea was to show current "
#~ "pioneers of blockchain applications and "
#~ "their works.)"
#~ msgstr "치치"

#~ msgid "Hyperledger Iroha documentation"
#~ msgstr "Hyperledger Iroha 문서"

#~ msgid "Last Reviewed"
#~ msgstr "마지막 리뷰"

#~ msgid "2018-03-06"
#~ msgstr "2018-03-06"

#~ msgid ""
#~ "Welcome! Hyperledger Iroha is a simple"
#~ " blockchain platform you can use to"
#~ " make trusted, secure, and fast "
#~ "applications by bringing the power of"
#~ " permission-based blockchain with Byzantine"
#~ " fault-tolerant consensus. It's free, "
#~ "open-source, and works on Linux "
#~ "and Mac OS, with a variety of "
#~ "mobile and desktop libraries."
#~ msgstr ""
#~ "환영합니다. Hyperledger Iroha는 비잔친 장해 허용 "
#~ "합의 알고리즘을 가진 권한(permission) 기반 블록체인으로 "
#~ "신뢰성 있고 안전하며 빠른 어플리케이션에 사용될 수 "
#~ "있는 심플한 블록체인 플랫폼입니다. 무료이며 오픈 소스인"
#~ " Iroha는 리눅스와 Mac OS를 지원합니다. 또한 "
#~ "다양한 모바일과 데스크톱 라이브러리를 지원합니다."

#~ msgid ""
#~ "You can download the source code "
#~ "of Hyperledger Iroha and latest releases"
#~ " from `GitHub page "
#~ "<https://github.com/hyperledger/iroha>`_."
#~ msgstr ""
#~ "Hyperledger Iroha의 소스코드와 최신 버전의 릴리즈는 "
#~ "`깃허브<https://github.com/hyperledger/iroha>`_에서 다운로드 받을 "
#~ "수 있습니다."

#~ msgid ""
#~ "This documentation will guide you "
#~ "through the installation, deployment, and "
#~ "launch of Iroha network, and explain "
#~ "to you how to write an application"
#~ " for it. We will also see which"
#~ " use case scenarios are feasible now,"
#~ " and are going to be implemented "
#~ "in the future."
#~ msgstr ""
#~ "이 문서는 설치 및 배포, Iroha 네트워크의 "
#~ "구축까지 다루고 있으며 어플리케이션을 위한 코드를 작성하는"
#~ " 법에 대해서도 다루고 있습니다. 또한 어떠한 유즈케이스"
#~ " 시나리오가 미래에 구현 가능한지에 대해서도 다루고 "
#~ "있습니다."

#~ msgid ""
#~ "As Hyperledger Iroha is an open-"
#~ "source project, we will also cover "
#~ "contribution part and explain you a "
#~ "working process."
#~ msgstr "Hyperledger Iroha는 오픈소스 프로젝트로 기여하는 방법과 워킹 프로세스에 대해서도 다루고 있습니다."

#~ msgid ""
#~ "There is a separate website for "
#~ "all external API documentation, which is"
#~ " `Iroha API <https://hyperledger.github.io/iroha-"
#~ "api>`_. We are in the process of"
#~ " migration, so that in future only"
#~ " RTD is maintained and updated."
#~ msgstr ""
#~ "외부 API 문서를 다루는 별도의 웹사이트인 `Iroha"
#~ " API <https://hyperledger.github.io/iroha-api>`_가 "
#~ "있습니다. 마이그레이션(migration) 중이기 때문에  RTD(Read "
#~ "The Docs)만 유지보수 및 업데이트될 것입니다."

#~ msgid "Overview of Iroha"
#~ msgstr "Iroha 개요"

#~ msgid "What are the key features of Iroha?"
#~ msgstr "Iroha의 주요 특징은 무엇인가?"

#~ msgid "Where Iroha can be used?"
#~ msgstr "Iroha는 어디에 사용될 수 있는가?"

#~ msgid "How is it different from Bitcoin or Ethereum?"
#~ msgstr "비트코인과 이더리움과는 어떤 점이 다른가?"

#~ msgid ""
#~ "How is it different from the rest"
#~ " of Hyperledger frameworks or other "
#~ "permissioned blockchains?"
#~ msgstr "다른 Hyperledger 프레임워크나 다른 권한 기반 블록체인과 무엇이 다른가?"

#~ msgid "Is it fast?"
#~ msgstr "빠른가?"

#~ msgid "How to create applications around Iroha?"
#~ msgstr "Iroha 기반의 어플리케이션을 어떻게 만들 수 있나?"

#~ msgid ""
#~ "A command changes the state, called "
#~ "World State View, by performing an "
#~ "action over an entity (asset, account)"
#~ " in the system. Any command should"
#~ " be included in a transaction to "
#~ "perform an action."
#~ msgstr ""
#~ "커맨드는 시스템 내부의 객체(에셋, 계정)에 대한 일련의"
#~ " 작업들을 수행하면서 World State View라고 하는 "
#~ "상태를 변화시킵니다. 어떤 커맨드들이 작업을 수행하려면 반드시"
#~ " 트랜젝션에 포함되어야 합니다."

#~ msgid "Purpose"
#~ msgstr "목적"

#~ msgid ""
#~ "The purpose of add asset quantity "
#~ "command is to increase the quantity "
#~ "of an asset on account of "
#~ "transaction creator. Use case scenario "
#~ "is to increase the number of a "
#~ "mutable asset in the system, which "
#~ "can act as a claim on a "
#~ "commodity (e.g. money, gold, etc.)"
#~ msgstr "에셋 수량 "

#~ msgid "Schema"
#~ msgstr "스키마"

#~ msgid "Structure"
#~ msgstr "구조"

#~ msgid "Field"
#~ msgstr "필드명"

#~ msgid "Description"
#~ msgstr "설명"

#~ msgid "Constraint"
#~ msgstr "조건"

#~ msgid "Account ID"
#~ msgstr "계정 ID"

#~ msgid "account id in which to add asset"
#~ msgstr "에셋을 추가할 계졍 ID"

#~ msgid "<account_name>@<domain_id>"
#~ msgstr "<account_name>@<domain_id>"

#~ msgid "alex@morgan"
#~ msgstr "alex@morgan"

#~ msgid "Asset ID"
#~ msgstr "에셋 ID"

#~ msgid "id of the asset"
#~ msgstr "에셋의 ID"

#~ msgid "<asset_name>#<domain_id>"
#~ msgstr "<asset_name>#<domain_id>"

#~ msgid "usd#morgan"
#~ msgstr "usd#morgan"

#~ msgid "Amount"
#~ msgstr "수량"

#~ msgid "positive amount of the asset to add"
#~ msgstr "추가할 에셋의 수량(양수)"

#~ msgid "> 0"
#~ msgstr ">0"

#~ msgid "200.02"
#~ msgstr "200.02"

#~ msgid "Asset and account should exist"
#~ msgstr "에셋과 계정은 존재해야 합니다."

#~ msgid "Added quantity precision should be equal to asset precision"
#~ msgstr "추가된 에셋 수량의 정밀도는 에셋의 정밀도와 같아야 합니다."

#~ msgid ""
#~ "Creator of a transaction should have "
#~ "a role which has permissions for "
#~ "issuing assets"
#~ msgstr "트랜젝션 생성자는 에셋을 발행할 수 있는 권한을 가지고 있는 역할(role)이어야 합니다."

#~ msgid "Creator of a transaction adds account quantity to his/her account only"
#~ msgstr "트랜젝션의 생성자는 자기 자신의 계정에만 에셋 수량을 추가할 수 있습니다."

#~ msgid ""
#~ "The purpose of add peer command is"
#~ " to write into ledger the fact "
#~ "of peer addition into the peer "
#~ "network. After a transaction with "
#~ "AddPeer has been committed, consensus "
#~ "and synchronization components will start "
#~ "using it."
#~ msgstr "피어 추가하기 커맨드는 "

#~ msgid "Address"
#~ msgstr "주소"

#~ msgid "resolvable address in network (IPv4, IPv6, domain name, etc.)"
#~ msgstr "네트워크의 resovable한 주소(IPv4, IPv6, 도메인 이름 등등)"

#~ msgid "should be resolvable"
#~ msgstr "resolvable해야 한다."

#~ msgid "192.168.1.1:50541"
#~ msgstr "192.168.1.1:50541"

#~ msgid "Peer key"
#~ msgstr "피어 키(Peer Key)"

#~ msgid ""
#~ "peer public key, which is used in"
#~ " consensus algorithm to sign-off "
#~ "vote, commit, reject messages"
#~ msgstr "합의 알고리즘에서 vote에 사인하고 커밋하고 메시지를 거부하기 위해 사용되는 피어 공개키"

#~ msgid "ed25519 public key"
#~ msgstr "ed25519 공개키"

#~ msgid "292a8714694095edce6be799398ed5d6244cd7be37eb813106b217d850d261f2"
#~ msgstr "292a8714694095edce6be799398ed5d6244cd7be37eb813106b217d850d261f2"

#~ msgid "Creator of the transaction has a role which has CanAddPeer permission"
#~ msgstr "트랜젝션의 생성자가 CanAddPeer 권한이 있는 역할(role)을 가져야 합니다."

#~ msgid "Such network address has not been already added"
#~ msgstr "네트워크의 주소가 이전에 추가된 적이 없어야 합니다."

#~ msgid ""
#~ "The purpose of add signatory command "
#~ "is to add an identifier to the "
#~ "account. Such identifier is a public "
#~ "key of another device or a public"
#~ " key of another user."
#~ msgstr ""
#~ "서명 추가하기 커맨드는 계정에 identifier를 더하는 "
#~ "것을 목적으로 합니다. Identifier란 다른 디바이스의 "
#~ "공개키 또는 다른 유저의 공개키를 의미합니다."

#~ msgid "Account to which to add signatory"
#~ msgstr "서명을 추가할 계정"

#~ msgid "makoto@soramitsu"
#~ msgstr "makoto@soramitsu"

#~ msgid "Public key"
#~ msgstr "공개키"

#~ msgid "Signatory to add to account"
#~ msgstr "계정에 추가할 서명"

#~ msgid "359f925e4eeecfdd6aa1abc0b79a6a121a5dd63bb612b603247ea4f8ad160156"
#~ msgstr "359f925e4eeecfdd6aa1abc0b79a6a121a5dd63bb612b603247ea4f8ad160156"

#~ msgid "Two cases:"
#~ msgstr "두 가지 케이스:"

#~ msgid ""
#~ "Case 1. Transaction creator wants to "
#~ "add a signatory to his or her "
#~ "account, having permission CanAddSignatory"
#~ msgstr "케이스 1: 트랜젝션의 생성자가 CanAddSignatory 권한을 가진 상태에서 자신의 계정에 서명자를 더하고 싶은 경우"

#~ msgid "Case 2. CanAddSignatory was granted to transaction creator"
#~ msgstr "케이스 2: CanAddSignatory 권한이 트랜젝션 생성자에게 주어진 경우"

#~ msgid ""
#~ "The purpose of append role command "
#~ "is to promote an account to some"
#~ " created role in the system, where"
#~ " a role is a set of permissions"
#~ " account has to perform an action "
#~ "(command or query)."
#~ msgstr ""
#~ "역할 추가하기(Append Role) 커맨드는 특정 "
#~ "계정(Account)에 시스템에 정의된 역할(Role)을 부여하기 위해"
#~ " 사용합니다. 역할이란 시스템 내에서 어떤 행동을 할"
#~ " 때 필요한 권한의 집합을 의미합니다."

#~ msgid "id or account to append role to"
#~ msgstr "역할에 추가할 ID 또는 계정"

#~ msgid "already existent"
#~ msgstr "이미 존재해야 합니다."

#~ msgid "Role name"
#~ msgstr "Role name(역할 이름)"

#~ msgid "name of already created role"
#~ msgstr "이미 정의된 역할의 이름"

#~ msgid "MoneyCreator"
#~ msgstr "MoneyCreator"

#~ msgid "The role should exist in the system"
#~ msgstr "역할이 이미 시스템 내부에 정의되어 있어야 합니다."

#~ msgid ""
#~ "Transaction creator should have permissions"
#~ " to append role (CanAppendRole)"
#~ msgstr "트잰섹션 생성자는 역할을 추가할 수 있는 권한을 가지고 있어야 합니다. (CanAppendRole)"

#~ msgid ""
#~ "Account, which appends role, has set "
#~ "of permissions in his roles that "
#~ "is a superset of appended role (in"
#~ " other words no-one can append "
#~ "role that is more powerful than "
#~ "what transaction creator is)"
#~ msgstr ""
#~ "역할을 추가하는 계정은 계정에 추가할 역할을 "
#~ "포함(superset)하는 역할을 가져야 합니다. 다시 말해, "
#~ "누구도 트랜젝션 생성자 만큼이나 강력한 역할을 추가할 "
#~ "수 없다는 것을 의미합니다."

#~ msgid ""
#~ "The purpose of create account command"
#~ " is to make entity in the "
#~ "system, capable of sending transactions "
#~ "or queries, storing signatories, personal "
#~ "data and identifiers."
#~ msgstr ""
#~ "계정 생성하기 커맨든는 시스템에 트랜젝션이나 쿼리를 보낼"
#~ " 수 있고 서명과 개인정보 및 ID를 저장할 "
#~ "수 있는 객체를 만들 때 사용합니다."

#~ msgid "Account name"
#~ msgstr "계정 이름(Account Name)"

#~ msgid "domain-unique name for account"
#~ msgstr "계정의 이름(도메인 내부의 다른 계정과 이름이 겹치지 않아야 함)"

#~ msgid "`[a-z_0-9]{1,32}`"
#~ msgstr "`[a-z_0-9]{1,32}`"

#~ msgid "morgan_stanley"
#~ msgstr "morgan_stanley"

#~ msgid "Domain ID"
#~ msgstr "도메인 ID"

#~ msgid "target domain to make relation with"
#~ msgstr "계정이 속할 도메인"

#~ msgid "should be created before the account"
#~ msgstr "계정 생성 이전에 만들어진 도메인이어야 합니다."

#~ msgid "america"
#~ msgstr "america"

#~ msgid "Main pubkey"
#~ msgstr "Main pubkey(메인 공개키)"

#~ msgid "first public key to add to the account"
#~ msgstr "계정에 추가할 첫 공개키"

#~ msgid "407e57f50ca48969b08ba948171bb2435e035d82cec417e18e4a38f5fb113f83"
#~ msgstr "407e57f50ca48969b08ba948171bb2435e035d82cec417e18e4a38f5fb113f83"

#~ msgid "Transaction creator has permission to create an account"
#~ msgstr "트랜젝션의 생성자는 계정을 생성할 수 있는 권한이 있어야 합니다."

#~ msgid "Domain, passed as domain_id, has already been created in the system"
#~ msgstr "domain_id로 넘겨지는 도메인은 이미 시스템에 만들어져 있어야 합니다."

#~ msgid ""
#~ "Such public key has not been added"
#~ " before as first public key of "
#~ "account or added to a multi-"
#~ "signature account"
#~ msgstr "  "

#~ msgid ""
#~ "The purpose of сreate asset command "
#~ "is to create a new type of "
#~ "asset, unique in a domain. An "
#~ "asset is a countable representation of"
#~ " a commodity."
#~ msgstr ""
#~ "에셋 생성 커맨드는 새로운 타입의 에셋을 만들 때"
#~ " 사용합니다. 각 에셋은 같은 도메인 내에서 중복되지"
#~ " 않아야 합니다. 에셋은 상품을 셀 수 있는 "
#~ "형식(Countable Representation)으로 표현한 것으로 볼 "
#~ "수 있습니다."

#~ msgid "Asset name"
#~ msgstr "에셋 이름(Asset name)"

#~ msgid "domain-unique name for asset"
#~ msgstr "에셍의 이름(같은 도메인 내부에 중복되는 이름이 없어야 합니다.)"

#~ msgid "soracoin"
#~ msgstr "soracoin"

#~ msgid "RFC1035 [#f1]_, RFC1123 [#f2]_"
#~ msgstr "RFC1035 [#f1]_, RFC1123 [#f2]_"

#~ msgid "japan"
#~ msgstr "japan"

#~ msgid "Precision"
#~ msgstr "정밀도(Precision)"

#~ msgid "number of digits after comma/dot"
#~ msgstr ",(콤마) 이나 .(마침표) 다음에 오는 숫자의 수(소수 부분)"

#~ msgid "0 <= precision <= uint32 max"
#~ msgstr "0 <=  정밀도 <= uint32 max"

#~ msgid "2"
#~ msgstr "2"

#~ msgid "Transaction creator has permission to create assets"
#~ msgstr "트랜젝션 생성자가 에셋을 생성할 수 있는 권한을 가지고 있어야 합니다."

#~ msgid "Asset name is unique in domain"
#~ msgstr "도메인 내부에서 고유한 에셋 이름을 가져야 합니다."

#~ msgid ""
#~ "The purpose of create domain command "
#~ "is to make new domain in Iroha "
#~ "network, which is a group of "
#~ "accounts."
#~ msgstr ""
#~ "도메인 생성하기 커맨드는 Iroha 네트워크에 새로운 도메인을"
#~ " 만들기 위해 사용됩니다. 도메인은 계정들로 구성된 "
#~ "하나의 그룹을 의미합니다."

#~ msgid "ID for created domain"
#~ msgstr "생성된 도메인의 ID"

#~ msgid "unique, RFC1035 [#f1]_, RFC1123 [#f2]_"
#~ msgstr "고유해야 합니다., RFC1035 [#f1]_, RFC1123 [#f2]_"

#~ msgid "japan05"
#~ msgstr "japan05"

#~ msgid "Default role"
#~ msgstr "디폴트 역할(Role)"

#~ msgid "role for any created user in the domain"
#~ msgstr "도메인에 생성된 유저들이 기본적으로 갖게 되는 역할"

#~ msgid "one of the existing roles"
#~ msgstr "이미 존재하는 역할 중 하나여야 합니다."

#~ msgid "User"
#~ msgstr "User"

#~ msgid "Domain ID is unique"
#~ msgstr "도메인 ID는 중복되지 않아야 합니다."

#~ msgid ""
#~ "Account, who sends this command in "
#~ "transaction, has role with permission to"
#~ " create domain"
#~ msgstr "이 커맨드를 트랜젝션에 보내는 계정은 도메인을 생성할 수 있는 권한을 가지고 있어야 합니다."

#~ msgid ""
#~ "Role, which will be assigned to "
#~ "created user by default, exists in "
#~ "the system"
#~ msgstr "디폴트 역할은 시스템 내부에 이미 존재하는 역할이어야 합니다."

#~ msgid ""
#~ "The purpose of create role command "
#~ "is to create a new role in "
#~ "the system from the set of "
#~ "permissions. Combining different permissions "
#~ "into roles, maintainers of Iroha peer"
#~ " network can create customized security "
#~ "model."
#~ msgstr ""
#~ "역할 생성 커맨드는 여러 권한들을 모아 시스템 내의"
#~ " 새로운 역할을 만들 때 사용합니다. 다양한 권한들을"
#~ " 조합하여 역할을 만들어냄으로써 Iroha 피어 네트워크의 "
#~ "메인테이너들이 네트워크의 보안 모델을 커스터마이즈할 수 "
#~ "있습니다."

#~ msgid "name of role to create"
#~ msgstr "생성되는 역할의 이름"

#~ msgid "Permissions"
#~ msgstr "Permissions"

#~ msgid "array of already existent permissions"
#~ msgstr "이미 존재하는 관한들의 배열"

#~ msgid ""
#~ "set of passed permissions is fully "
#~ "included into set of existing "
#~ "permissions"
#~ msgstr "인수로 넘기는 권한들이 이미 존재하는 권한들이어야 합니다."

#~ msgid "{can_receive, can_transfer}"
#~ msgstr "{can_receive, can_transfer}"

#~ msgid ""
#~ "Set of passed permissions is fully "
#~ "included into set of existing "
#~ "permissions"
#~ msgstr "인수로 넘기는 권한들이 이미 존재하는 권한들이어야 합니다."

#~ msgid "Set of the permissions is not empty"
#~ msgstr "인수로 넘기는 권한의 배열이 비어있지 않아야 합니다."

#~ msgid ""
#~ "The purpose of detach role command "
#~ "is to detach a role from the "
#~ "set of roles of an account. By "
#~ "executing this command it is possible"
#~ " to decrease the number of possible"
#~ " actions in the system for the "
#~ "user."
#~ msgstr ""
#~ "역할 제거하기 커맨드는 계정이 가지고 있는 역할 중"
#~ " 하나의 역할을 제거할 때 사용합니다. 이 커맨드를"
#~ " 통해 시스템의 유저가 할 수 있는 행동을 "
#~ "제한할 수 있습니다."

#~ msgid "ID of account where role will be deleted"
#~ msgstr "역할을 제거할 계정의 ID"

#~ msgid "a detached role name"
#~ msgstr "제거할 역할의 이름"

#~ msgid "existing role"
#~ msgstr "존재하는 역할"

#~ msgid "The role exists in the system"
#~ msgstr "시스템에 이미 존재하는 역할이어야 합니다."

#~ msgid "The account has such role"
#~ msgstr "계정이 그러한 역할을 가지고 있어야 합니다."

#~ msgid ""
#~ "The purpose of grant permission command"
#~ " is to give another account rights"
#~ " to perform actions on the account"
#~ " of transaction sender (give someone "
#~ "right to do something with my "
#~ "account)."
#~ msgstr "계정 부여하기 커맨드는 다른 계정에게 "

#~ msgid "id of account whom rights are granted"
#~ msgstr "권한을 받을 계정의 ID"

#~ msgid "Permission name"
#~ msgstr "권한 이름(Permission name)"

#~ msgid "name of granted permission"
#~ msgstr "부여할 권한의 이름"

#~ msgid "permission is defined"
#~ msgstr "권한이 이미 정의되어 있어야 합니다."

#~ msgid "CanTransferAssets"
#~ msgstr "CanTransferAssets"

#~ msgid "Account exists"
#~ msgstr "계정이 존재해야 합니다."

#~ msgid "Transaction creator is allowed to grant this permission"
#~ msgstr "트랜젝션의 생성자가 권한을 부여할 수 있어야 합니다."

#~ msgid "Remove signatory"
#~ msgstr "서명 제거하기"

#~ msgid ""
#~ "Purpose of remove signatory command is"
#~ " to remove a public key, associated"
#~ " with an identity, from an account"
#~ msgstr "서명 제거하기 커맨드는 계정에서 공개키를 제거할 때 사용됩니다."

#~ msgid "Signatory to delete"
#~ msgstr "제거할 서명"

#~ msgid ""
#~ "When signatory is deleted, we should "
#~ "check if invariant of **size(signatories) "
#~ ">= quorum** holds"
#~ msgstr "서명이 제거되면 **size(signatories) >= quorum** 조건을 만족하는지 반드시 확인해야 합니다."

#~ msgid "Signatory should have been previously added to the account"
#~ msgstr "서명은 이전에 계정에 추가된 적이 있어야 합니다."

#~ msgid ""
#~ "Case 1. When transaction creator wants"
#~ " to remove signatory from their "
#~ "account and he or she has "
#~ "permission CanRemoveSignatory"
#~ msgstr ""
#~ "케이스 1: 트랜젝션 생성자가 자신 아닌 다른 "
#~ "계정에서 서명을 제거하려고 하고 자신이 CanRemoveSignatory"
#~ " 권한을 가진 경우"

#~ msgid "Case 2. CanRemoveSignatory was granted to transaction creator"
#~ msgstr "케이스 2: CanRemoveSignatory 권한이 트랜젝션 생성자에세 주어진 경우"

#~ msgid ""
#~ "The purpose of revoke permission command"
#~ " is to revoke or dismiss given "
#~ "granted permission from another account "
#~ "in the network."
#~ msgstr "권한 제거하기 커맨드는 네트워크 내의 다른 계정의 권한을 제거할 때 사용됩니다."

#~ msgid "permission was granted"
#~ msgstr "이전에 부여받은 권한이어야 합니다."

#~ msgid ""
#~ "Transaction creator should have previously "
#~ "granted this permission to a target "
#~ "account"
#~ msgstr "트랜젝션의 생성자는 이전에 권한을 제거하고자 하는 계정에게 제거하고자 하는 권한과 같은 권한을 부여했어야 합니다."

#~ msgid ""
#~ "Purpose of set account detail command"
#~ " is to set key-value information "
#~ "for a given account"
#~ msgstr "계정 정보 설정하기 커맨드는 계정의 키-값(key-value) 형태의 정보를 설정하기 위해 사용됩니다."

#~ msgid "id of account whom key-value information was set"
#~ msgstr "키- 정보를 설정한 계정의 ID"

#~ msgid "Key"
#~ msgstr "키"

#~ msgid "key of information being set"
#~ msgstr "설정된 "

#~ msgid "`[A-Za-z0-9_]{1,64}`"
#~ msgstr "`[A-Za-z0-9_]{1,64}`"

#~ msgid "Name"
#~ msgstr "Name"

#~ msgid "Value"
#~ msgstr "Value"

#~ msgid "value of corresponding key"
#~ msgstr "키에 대응하는 값"

#~ msgid "≤ 4096"
#~ msgstr "≤ 4096"

#~ msgid "Makoto"
#~ msgstr "Makoto"

#~ msgid ""
#~ "Case 1. When transaction creator wants"
#~ " to set account detail to his/her "
#~ "account and he or she has "
#~ "permission CanSetAccountInfo"
#~ msgstr "케이스 1: 트랜젝션 생성자가 자신의 계정 정보를 설정려고 하고 자신이 CanSetAccountInfo 권한을 가진 경우"

#~ msgid "Case 2. CanSetAccountInfo was granted to transaction creator"
#~ msgstr "케이스 2: 트랜젝션 생성자가 CanSetAccountInfo 권한을 가진 경우"

#~ msgid ""
#~ "The purpose of set account quorum "
#~ "command is to set the number of"
#~ " signatories required to confirm the "
#~ "identity of a user, who creates "
#~ "the transaction. Use case scenario is"
#~ " to set the number of different "
#~ "users, utilizing single account, to sign"
#~ " off the transaction."
#~ msgstr ""
#~ "계정 정족수 설정하기 커맨드는 유저 인증 확인에 "
#~ "필요한 서명의 수를 설정하는데 사용됩니다. 정족수는 어떤"
#~ " 트랜젝션을 승인하기 위한 최소 투표의 수로 이해하시면"
#~ " 됩니다. 유즈케이스 시나리오로 트랜젝션을 승인하는데 필요한 "
#~ "유저들(각 유저는 하나의 계정을 사용합니다)의 수를 설정하는"
#~ " 것이 있습니다."

#~ msgid "ID of account to set quorum"
#~ msgstr "정족수를 설정할 계정의 ID"

#~ msgid "Quorum"
#~ msgstr "Quorum"

#~ msgid ""
#~ "number of signatories needed to be "
#~ "included with a transaction from this"
#~ " account"
#~ msgstr "이 계정이 만든 트랜젝션에 포함되어야 할 서명의 수"

#~ msgid "0 < quorum ≤ public-key set up to account ≤ 128"
#~ msgstr "0 < 정족수 ≤ public-key set up to account ≤ 128"

#~ msgid "5"
#~ msgstr "5"

#~ msgid ""
#~ "When quorum is set, it is checked"
#~ " if invariant of **size(signatories) >= "
#~ "quorum** holds."
#~ msgstr "정족수가 설정된 후에도  **size(signatories) >= quorum** 조건을 만족해야 합니다."

#~ msgid ""
#~ "Case 1. When transaction creator wants"
#~ " to set quorum for his/her account"
#~ " and he or she has permission "
#~ "CanRemoveSignatory"
#~ msgstr "케이스 1: 트랜젝션 생성자가 자신의 계정의 정족수를 설정하기 원하고 자신이 CanRemoveSignatory 권한을 가진 경우"

#~ msgid ""
#~ "The purpose of subtract asset quantity"
#~ " command is the opposite of "
#~ "AddAssetQuantity commands — to decrease "
#~ "the number of assets on account of"
#~ " transaction creator."
#~ msgstr ""
#~ "에셋 수량 줄이기 커맨드는 AddAssetQuantity커맨드와 정반대로"
#~ " 작동합니다. 트랜젝션 생선자의 계정에 있는 에셋의 "
#~ "수량을 줄일 때 사용합니다."

#~ msgid "account id from which to subtract asset"
#~ msgstr "에셋을 줄일 계정의 ID"

#~ msgid "positive amount of the asset to subtract"
#~ msgstr "줄일 수량은 양수여야 합니다."

#~ msgid "200"
#~ msgstr "200"

#~ msgid ""
#~ "Creator of the transaction should have"
#~ " a role which has permissions for "
#~ "subtraction of assets"
#~ msgstr "트랜젝션의 생성자는 에셋의 수량을 줄일 수 있는 권한을 가진 역할이어야 합니다."

#~ msgid ""
#~ "Creator of transaction subtracts account "
#~ "quantity in his/her account only"
#~ msgstr "트랜젝션의 생성자는 다른 계저잉 아닌 자신의 계정에 있는 에셋만 수량 줄이기를 할 수 있습니다."

#~ msgid ""
#~ "The purpose of transfer asset command"
#~ " is to share assets within the "
#~ "account in peer network: in the "
#~ "way that source account transfers assets"
#~ " to the target account."
#~ msgstr "에셋 보내기 커맨드는 피어 네트워크에 있는 한 계정에서 다른 계정으로 에셋을 전달할 때 사용됩니다."

#~ msgid "Source account ID"
#~ msgstr "Source account ID"

#~ msgid "ID of account to withdraw asset from"
#~ msgstr "에셋을 보낼 계정의 ID"

#~ msgid "Destination account ID"
#~ msgstr "Destination account ID"

#~ msgid "ID of account to send asset at"
#~ msgstr "에셋을 받을 계정의 ID"

#~ msgid "alex@california"
#~ msgstr "alex@california"

#~ msgid "ID of asset to transfer"
#~ msgstr "보낼 에셋의 ID"

#~ msgid "usd#usa"
#~ msgstr "usd#usa"

#~ msgid "Message to attach to transfer"
#~ msgstr "에셋을 보낼 때 첨부할 메시지"

#~ msgid "Max length is 64"
#~ msgstr "최대 길이가 64여야 합니다."

#~ msgid "here's my money take it"
#~ msgstr "here's my money take it"

#~ msgid "amount of the asset to transfer"
#~ msgstr "보낼 에셋의 수량"

#~ msgid "0 < amount < max_uint256"
#~ msgstr "0 < amount < max_uint256"

#~ msgid "200.20"
#~ msgstr "200.20"

#~ msgid "Source account has this asset in its AccountHasAsset relation [#f1]_"
#~ msgstr "보내는 계정은 AccountHasAsset 관계를 가진 에셋을 소유하고 있어야 합니다. [#f1]_"

#~ msgid ""
#~ "An amount is a positive number and"
#~ " asset precision is consistent with "
#~ "the asset definition"
#~ msgstr "수량은 0보다 커야 하며 에셋의 정밀도는 에셋에 정의된 정밀도와 일치해야 합니다."

#~ msgid "Source account has enough amount of asset to transfer and is not zero"
#~ msgstr "보내는 계정은 전달할 에셋의 수량보다 많은 에셋을 소유하고 있어야 하며 0이 아니어야 합니다."

#~ msgid ""
#~ "Source account can transfer money, and"
#~ " destination account can receive money "
#~ "(their roles have these permissions)"
#~ msgstr "보내는 계정은 돈을 전송할 수 있으며 받는 계정은 돈을 받을 수 있습니다.(이에 대한 권한을 가지고 있어야만 합니다."

#~ msgid "https://www.ietf.org/rfc/rfc1035.txt"
#~ msgstr "https://www.ietf.org/rfc/rfc1035.txt"

#~ msgid "https://www.ietf.org/rfc/rfc1123.txt"
#~ msgstr "https://www.ietf.org/rfc/rfc1123.txt"

#~ msgid "Contents are missing for now."
#~ msgstr "현재 컨텐츠가 비어있습니다."

#~ msgid ""
#~ "In API section we will take a "
#~ "look at building blocks of an "
#~ "application interacting with Iroha. We "
#~ "will overview commands and queries that"
#~ " the system has, and the set of"
#~ " client libraries encompassing transport "
#~ "and application layer logic."
#~ msgstr ""
#~ "API 섹션에서는 Iroha와 상호작용할 수 있는 "
#~ "어플리케이션을 만들 수 있는 방법에 대해 알아봅니다. "
#~ "시스템에 정의된 커맨드와 쿼리를 개괄적으로 알아보며 전송"
#~ " 계층(Transport Layer)와 응용 계층(Application "
#~ "Layer)를 포함하는 클라이언트 라이브러리에 대해서도 알아봅니다."

#~ msgid ""
#~ "A query is a request related to"
#~ " certain part of World State View "
#~ "— the latest state of blockchain. "
#~ "Query cannot modify the contents of "
#~ "the chain and a response is "
#~ "returned to any client immediately after"
#~ " receiving peer has processed a "
#~ "query."
#~ msgstr ""
#~ "쿼리는 World State View(블록체인의 최신 상태)의 "
#~ "특정 부분과 관련하여 요청하는 것입니다. 쿼리는 체인 "
#~ "내부의 컨텐츠를 수정하지 않으며 피어가 들어온 쿼리를 "
#~ "처리한 후 즉시 쿼리에 대한 응답이 클라이언트에게 "
#~ "전달될 것입니다."

#~ msgid "The validation for all queries includes:"
#~ msgstr "valid한 모든 커리는 다음을 포함합니다:"

#~ msgid ""
#~ "timestamp — shouldn't be from the "
#~ "past (24 hours prior to the peer"
#~ " time) or from the future (range "
#~ "of 5 minutes added to the peer "
#~ "time)"
#~ msgstr ""
#~ "타임스탬프(timestamp) — 과거의 시간(피어 기준으로 24시간"
#~ " 전)이나 미래의 시간(피어 기준으로 5분 후)이 될"
#~ " 수 없습니다. "

#~ msgid ""
#~ "signature of query creator — used "
#~ "for checking the identity of query "
#~ "creator"
#~ msgstr "쿼리 생성자의 서명 — 쿼리 생성자의 identity를 확인하는데 사용됩니다."

#~ msgid ""
#~ "query counter — checked to be "
#~ "incremented with every subsequent query "
#~ "from query creator"
#~ msgstr "쿼리 카운터 — 쿼리 생성자가 쿼리를 보낼 때마다 증가합니다."

#~ msgid ""
#~ "roles — depending on the query "
#~ "creator's role: the range of state "
#~ "available to query can relate to "
#~ "to the same account, account in "
#~ "the domain, to the whole chain, or"
#~ " not allowed at all"
#~ msgstr ""

#~ msgid "Get Account"
#~ msgstr "계정 조회하기"

#~ msgid "Purpose of get account query is to get the state of an account."
#~ msgstr "계정 조회하기 쿼리는 계정의 상태를 조회할 때 사용됩니다."

#~ msgid "Request Schema"
#~ msgstr "Request 스키마"

#~ msgid "Request Structure"
#~ msgstr "Request 구조"

#~ msgid "account id to request its state"
#~ msgstr "상태를 조회할 계정의 ID"

#~ msgid "Response Schema"
#~ msgstr "Response 스키마"

#~ msgid "Response Structure"
#~ msgstr "Response 구조"

#~ msgid "account id"
#~ msgstr "계정 ID"

#~ msgid "domain where the account was created"
#~ msgstr "계정이 생성된 도메인"

#~ msgid "morgan"
#~ msgstr "morgan"

#~ msgid "number of signatories needed to sign the transaction to make it valid"
#~ msgstr "트랜젝션을 valid하게 만들기 위해 필요한 서명의 수"

#~ msgid "0 < quorum ≤ 128"
#~ msgstr "0 < quorum ≤ 128"

#~ msgid "JSON data"
#~ msgstr "JSON data"

#~ msgid "key-value account information"
#~ msgstr "키-값(key-value) 형태의 계정 정보"

#~ msgid "JSON"
#~ msgstr "JSON"

#~ msgid "{ genesis: {name: alex} }"
#~ msgstr "{ genesis: {name: alex} }"

#~ msgid "Get Signatories"
#~ msgstr "서명 조회하기"

#~ msgid ""
#~ "Purpose of get signatories query is "
#~ "to get signatories, which act as "
#~ "an identity of the account."
#~ msgstr "서명 조회하기 쿼리는 계정의 identity의 역할을 하는 서명을 조회하는 데 사용합니다."

#~ msgid "account id to request signatories"
#~ msgstr "서명을 조회할 계정의 ID"

#~ msgid "Keys"
#~ msgstr "Keys"

#~ msgid "an array of public keys"
#~ msgstr "공개키의 배열"

#~ msgid "`ed25519 <https://ed25519.cr.yp.to>`_"
#~ msgstr "`ed25519 <https://ed25519.cr.yp.to>`_"

#~ msgid "Get Transactions"
#~ msgstr "트랜젝션 조회하기"

#~ msgid ""
#~ "GetTransactions is used for retrieving "
#~ "information about transactions, based on "
#~ "their hashes."
#~ msgstr "GetTransactions은 트랜젝션의 해시값을 기반으로 트랜젝션의 정보를 조회하는데 사용됩니다."

#~ msgid "Transactions hashes"
#~ msgstr "트랜젝션 해시값"

#~ msgid "an array of hashes"
#~ msgstr "해시값의 배열"

#~ msgid "array with 32 byte hashes"
#~ msgstr "32바이트 해시값의 배열"

#~ msgid "{hash1, hash2…}"
#~ msgstr "{hash1, hash2…}"

#~ msgid "Transactions"
#~ msgstr "트랜젝션"

#~ msgid "an array of transactions"
#~ msgstr "트랜젝션의 배열"

#~ msgid "Committed transactions"
#~ msgstr "커밋된 트랜젝션"

#~ msgid "{tx1, tx2…}"
#~ msgstr "{tx1, tx2…}"

#~ msgid "Get Account Transactions"
#~ msgstr "계정의 트랜젝션 조회하기"

#~ msgid ""
#~ "In a case when a list of "
#~ "transactions per account is needed, "
#~ "`GetAccountTransactions` query can be formed."
#~ msgstr "계정별 트랜젝션의 리스트가 필요한 경우 `GetAccountTransactions` 쿼리를 사용할 수 있습니다."

#~ msgid "account id to request transactions from"
#~ msgstr "트랜젝션 조회를 요청할 계정의 ID"

#~ msgid "an array of transactions for given account"
#~ msgstr "계정의 트랜젝션의 배열"

#~ msgid "Get Account Asset Transactions"
#~ msgstr "계정과 에셋에 관련된 트랜젝션 조회하기"

#~ msgid ""
#~ "`GetAccountAssetTransactions` query returns all "
#~ "transactions associated with given account "
#~ "and asset."
#~ msgstr "`GetAccountAssetTransactions` 쿼리는 주어진 계정과 에셋에 대응하는 모든 트랜젝션을 반환합니다."

#~ msgid "asset id in order to filter transactions containing this asset"
#~ msgstr "에셋 ID(쿼리는 이 에셋이 포함된 트랜젝션만 반환합니다.)"

#~ msgid "jpy#japan"
#~ msgstr "jpy#japan"

#~ msgid "an array of transactions for given account and asset"
#~ msgstr "주어진 계정과 에셋에 대한 트랜젝션의 배열"

#~ msgid "Get Account Assets"
#~ msgstr "계정의 에셋 조회하기"

#~ msgid ""
#~ "To get the state of an asset "
#~ "in an account (a balance), "
#~ "`GetAccountAssets` query can be used."
#~ msgstr "계정이 가진 에셋의 상태를 확인하기 위해서는(잔액의 확인), `GetAccountAssets`을 이용할 수 있습니다."

#~ msgid "account id to request balance from"
#~ msgstr "에셋의 잔액을 확인할 계정의 ID"

#~ msgid "asset id to know its balance"
#~ msgstr "잔액을 확인할 에셋의 ID"

#~ msgid "identifier of asset used for checking the balance"
#~ msgstr "잔액 확인을 위해 사용된 에셋의 ID"

#~ msgid "account which has this balance"
#~ msgstr "잔액 확인한 계정의 ID"

#~ msgid "Balance"
#~ msgstr "Balance"

#~ msgid "balance of the asset"
#~ msgstr "에셋의 잔액"

#~ msgid "Not less than 0"
#~ msgstr "0보다 작지 않다."

#~ msgid "Get Asset Info"
#~ msgstr "에셋 정보 조회하기"

#~ msgid ""
#~ "In order to know precision for "
#~ "given asset, and other related info "
#~ "in the future, such as a "
#~ "description of the asset, etc. user "
#~ "can send `GetAssetInfo` query."
#~ msgstr ""
#~ "에셋의 정밀도(precision)을 알기 위해서는, 또는 에셋에 "
#~ "대한 다른 정보가 필요한 경우 유저는 "
#~ "`GetAssetInfo` 쿼리를 보낼 수 있습니다."

#~ msgid "asset id to know related information"
#~ msgstr "정보를 조회할 에셋의 ID"

#~ msgid "jpy"
#~ msgstr "jpy"

#~ msgid "domain related to this asset"
#~ msgstr "에셋이 속한 도메인"

#~ msgid "number of digits after comma"
#~ msgstr "콤마(,) 다음의 숫자들의 수"

#~ msgid "0 < precision < 256"
#~ msgstr "0 < precision < 256"

#~ msgid "Get Roles"
#~ msgstr "역할 조회하기"

#~ msgid ""
#~ "To get existing roles in the "
#~ "system, a user can send `GetRoles` "
#~ "query to Iroha network."
#~ msgstr "계정에 존재하는 역할에 대해 조회하기 위해 `GetRoles` 쿼리를 Iroha 네트워크에 보낼 수 있습니다."

#~ msgid "Roles"
#~ msgstr "Roles"

#~ msgid "array of created roles in the network"
#~ msgstr "네트워크에 생성된 역할들의 배열"

#~ msgid "set of roles in the system"
#~ msgstr "시스템 내의 역할들"

#~ msgid "{MoneyCreator, User, Admin, …}"
#~ msgstr "{MoneyCreator, User, Admin, …}"

#~ msgid "Get Role Permissions"
#~ msgstr "역할의 권한 조회하기"

#~ msgid ""
#~ "To get available permissions per role"
#~ " in the system, a user can send"
#~ " `GetRolePermissions` query to Iroha "
#~ "network."
#~ msgstr "각 역할이 가능한 권한에 조회하기 위해 `GetRolePermissions` 쿼리를 Iroha 네트워크에 보낼 수 있습니다."

#~ msgid "Role ID"
#~ msgstr "Role ID"

#~ msgid "role to get permissions for"
#~ msgstr "권한을 조회할 역할"

#~ msgid "existing role in the system"
#~ msgstr "시스템 내의 존재하는 역할"

#~ msgid "array of permissions related to the role"
#~ msgstr "역할이 가진 권한의 배열"

#~ msgid "string of permissions related to the role"
#~ msgstr "역할이 가진 권한의 문자열"

#~ msgid "{can_add_asset_qty, …}"
#~ msgstr "{can_add_asset_qty, …}"

#~ msgid "Account"
#~ msgstr "Account"

#~ msgid ""
#~ "An Iroha entity that is able to"
#~ " perform specified set of actions. "
#~ "Each account belongs to one of "
#~ "existing `domains <#domain>`__."
#~ msgstr "일련의 행동을 수행할 수 있는 Iroha의 객체 입니다. 각 계정은 하나의 `도메인 <#domain>`__에 속해 있습니다."

#~ msgid ""
#~ "An account has some number of "
#~ "`roles <#role>`__ (can be none) — "
#~ "which is a collection of permissions."
#~ " Only `grantable permissions <#grantable-"
#~ "permission>`__ are assigned to an "
#~ "account directly."
#~ msgstr ""
#~ "계정은 여러 개의 `역할 <#role>`__ (없을 수도"
#~ " 있습니다.)을 가지고 있습니다. 역할은 여러 권한들의 "
#~ "모음을 의미합니다. 오직 `부여가능한 권한(grantable "
#~ "permission)<#grantable-permission>`__ 만 계정에 직접"
#~ " 주어질 수 있습니다."

#~ msgid "Ametsuchi"
#~ msgstr "Ametsuchi"

#~ msgid ""
#~ "Iroha storage component, which stores "
#~ "blocks and a state generated from "
#~ "blocks, called `World State View "
#~ "<#world-state-view>`__. There is no "
#~ "way for the `client <#client>`__ to "
#~ "directly interact with Ametsuchi."
#~ msgstr ""
#~ "Iroha의 데이터 저장을 담당하는 컴포넌트로 블록의 저장"
#~ " 및 블록에 의해 생성된 상태 - 또는 "
#~ "`World State View <#world-state-view>`__"
#~ " -의 저장을 담당합니다. `클라이언트 <#client>`__ 가"
#~ " 직접 Ametsuchi와 직접 상호작용할 수 없습니다."

#~ msgid "Asset"
#~ msgstr "에셋(Asset)"

#~ msgid ""
#~ "Any countable commodity or value. Each"
#~ " asset is related to one of "
#~ "existing `domains <#domain>`__. For example,"
#~ " an asset can represent any kind "
#~ "of such units - currency unit, a"
#~ " bar of gold, real estate unit, "
#~ "etc."
#~ msgstr ""
#~ "셀 수 있는 모든 상품 또는 값을 의미합니다."
#~ " 각 에셋은 하나의 `도메인 <#domain>`__에 속해 "
#~ "있습니다. 예를 들어, 통화 단위나 골드바, 부동산 "
#~ "단위 처럼 에셋은 어떠한 단위로든지 표현될 수 "
#~ "있습니다."

#~ msgid "Block"
#~ msgstr "블록(Block)"

#~ msgid ""
#~ "Transaction data is permanently recorded "
#~ "in files called blocks. Blocks are "
#~ "organized into a linear sequence over"
#~ " time (also known as the block "
#~ "chain) [#f1]_."
#~ msgstr ""
#~ "트랜젝션 데이터는 블록이라고 불리는 파일에 영구적으로 "
#~ "기록됩니다. 블록은 시간에 따라 선형적인 순서를 가지도록"
#~ " 구성되어 있습니다.(이런 구조때문에 블록체인이라 불리기도 "
#~ "합니다.) [#f1]_"

#~ msgid ""
#~ "Blocks are signed with the cryptographic"
#~ " signatures of Iroha `peers <#peer>`__, "
#~ "voting for this block during `consensus"
#~ " <#consensus>`__. Signable content is "
#~ "called payload, so the structure of "
#~ "a block looks like this:"
#~ msgstr ""
#~ "블록은 Iroha `피어 <#peer>`__의 암호학적인 "
#~ "서명(signature)들로 서명되어 있습니다. 이 서명들은  `합의"
#~ " <#consensus>`__ 과정에서 블록에 대해 투표(vote)할 "
#~ "때 사용됩니다. 서명가능한 컨텐츠는 payload로 불립니다. "
#~ "블록의 구조는 아래와 같습니다:"

#~ msgid "*Outside payload*"
#~ msgstr "*Outside payload*"

#~ msgid "hash — SHA3-512 hash of block protobuf payload"
#~ msgstr "해시 — SHA3-512 hash of block protobuf payload"

#~ msgid ""
#~ "signatures — signatures of peers, which"
#~ " voted for the block during consensus"
#~ " round"
#~ msgstr "서명(signatures) — 합의(Consensus) 중에 블록에 투표(vote)한 피어들의 서명"

#~ msgid "*Inside payload*"
#~ msgstr "*Inside payload*"

#~ msgid "height — a number of blocks in the chain up to the block"
#~ msgstr "높이(height) — 현재 블록까지의 블록의 수"

#~ msgid "timestamp — Unix time (in milliseconds) of block forming by a peer"
#~ msgstr "타임스탬프(timestamp) — 피어에 의해 블록이 생성된 유닉스 시간(밀리세컨즈 단위)"

#~ msgid ""
#~ "body — transactions, which successfully "
#~ "passed validation and consensus step"
#~ msgstr "바디(body) — 검증과 합의 단계를 성공적으로 통과한 트랜젝션들"

#~ msgid "transactions quantity"
#~ msgstr "트랜잭션의 수(transactions quantity)"

#~ msgid "previous hash of a block"
#~ msgstr "이전 블록의 해시"

#~ msgid "Block Creator"
#~ msgstr "블록 생성자(Block Creator)"

#~ msgid ""
#~ "System component that forms a block "
#~ "from a set of transactions that "
#~ "have been passed `stateless <#stateless-"
#~ "validation>`__ and `stateful <#stateful-"
#~ "validation>`__ validation for further "
#~ "propagation to `consensus <#consensus>`__."
#~ msgstr ""
#~ "`합의 <#consensus>`__과정으로 넘어가기 전 `stateless "
#~ "<#stateless-validation>`__ 검증과 `stateful "
#~ "<#stateful-validation>`__ 검증을 통과한 여러 트랜젝션으로"
#~ " 블록을 생성하는 시스템 컴포넌트입니다."

#~ msgid "Client"
#~ msgstr "클라이언트(Client)"

#~ msgid "Any application that uses Iroha is treated as a client."
#~ msgstr "Iroha를 사용하는 모든 형태의 어플리케이션을 클라이언트로 취급합니다."

#~ msgid ""
#~ "A distinctive feature of Iroha is "
#~ "that all clients are using simple "
#~ "client-server abstractions when they "
#~ "interact with a peer network: they "
#~ "don't use any abstractions which are "
#~ "specific for blockchain-related systems. "
#~ "For example, in Bitcoin clients have "
#~ "to validate blocks, or in Fabric "
#~ "they need to poll several peers to"
#~ " make sure that a transaction was "
#~ "written in a block, whereas in "
#~ "Iroha a client interacts with any "
#~ "peer similarly to a single server."
#~ msgstr ""
#~ "Iroha의 특징은 모든 클라이언트가 피어 네트워크와 "
#~ "상호작용할 때 간단한 구조의 클라이언트-서버 추상화를 사용하고"
#~ " 있다는 점입니다. 그들은 블록체인 관련 시스템에 특화된"
#~ " 추상화는 사용하지 않습니다. 예를 들어 비트코인 "
#~ "클라이언트는 블록을 직접 validate하고 Hyperledger "
#~ "Fabric에서는 트랜젝션이 블록에 씌여진 것을 확인하기 위해"
#~ " 몇몇 피어를 선택해야 합니다. 반면 Iroha의 "
#~ "클라이언트는 하나의 서버와 상호작용 하듯이"

#~ msgid "Command"
#~ msgstr "커맨드(command)"

#~ msgid ""
#~ "A command is an intention to "
#~ "change the `state <#world-state-"
#~ "view>`__. For example, in order to "
#~ "create a new `role <#role>`__ in "
#~ "Iroha you have to issue `Create "
#~ "role <../api/commands.html#create-role>`__ command."
#~ msgstr ""
#~ "커맨드는 `상태 <#world-state-view>`__를 바꾸기 "
#~ "위해 사용됩니다. 예를 들어 Iroha에 새로운 `역할 "
#~ "<#role>`__을 생성하기 위해서는 `역할 생성하기 "
#~ "<../api/commands.html#create-role>`__커맨드를 사용해야 합니다."

#~ msgid "Consensus"
#~ msgstr "합의(Consensus)"

#~ msgid ""
#~ "A consensus algorithm is a process "
#~ "in computer science used to achieve "
#~ "agreement on a single data value "
#~ "among distributed processes or systems. "
#~ "Consensus algorithms are designed to "
#~ "achieve reliability in a network "
#~ "involving multiple unreliable nodes. Solving"
#~ " that issue -- known as the "
#~ "consensus problem -- is important in "
#~ "distributed computing and multi-agent "
#~ "systems."
#~ msgstr ""
#~ "합의 알고리즘은 다수의 프로세스나 시스템에 분산되어 있는"
#~ " 하나의 데이터에 대해 합의를 이루는 컴퓨터 과학의"
#~ " 한 방법입니다. 합의 알고리즘은 다수의 신뢰할 수"
#~ " 없는 노드가 포함된 네트워크의 신뢰성(Reliability)을 "
#~ "이루기 위해 디자인 되었습니다. 합의 문제로 불리기도 "
#~ "하는 이러한 문제를 해결하는 것은 분산 컴퓨팅과 "
#~ "multi-agent 시스템에서 중요한 문제입니다."

#~ msgid "*Consensus, as an algorithm*"
#~ msgstr "*알고리즘으로서의 합의*"

#~ msgid ""
#~ "An algorithm to achieve agreement on "
#~ "a block among peers in the "
#~ "network. By having it in the "
#~ "system, reliability is increased."
#~ msgstr ""
#~ "네트워크 피어들이 가지고 있는 하나의 블록에 대해 "
#~ "합의를 이루게 하는 알고리즘입니다. 이 알고리즘을 통해 "
#~ "네트워크 신뢰성이 증가합니다."

#~ msgid "*Consensus, as a component*"
#~ msgstr "*컴포넌트로서의 합의*"

#~ msgid ""
#~ "Preserves consistent state among the "
#~ "`peers <#peer>`__ within a peer network."
#~ " Iroha uses own consensus algorithm "
#~ "called Yet Another Consensus (aka YAC)."
#~ " Distinctive features of this algorithm "
#~ "are its scalability, performance, and "
#~ "`Byzantine fault tolerance "
#~ "<https://en.wikipedia.org/wiki/Byzantine_fault_tolerance>`_. If"
#~ " there are missing blocks, they will"
#~ " be downloaded from another peer via"
#~ " `Synchronizer <#synchronizer>`__. Committed "
#~ "blocks are stored in `Ametsuchi "
#~ "<#ametsuchi>`__ block storage."
#~ msgstr ""
#~ "`피어 <#peer>`__ 들 간의 일정한 상태를 보존합니다."
#~ " Iroha는 Yet Another Consensus(YAC)라는 자체적인"
#~ " 합의 알고리즘을 사용하고 있습니다. 이 알고리즘의 "
#~ "특징은 scalability와 퍼포먼스, `비잔틴 장애 "
#~ "허용(Byzantine fault tolerance) "
#~ "<https://en.wikipedia.org/wiki/Byzantine_fault_tolerance>`_. 만약"
#~ " 빠진(missing) 블록이 있는 경우 `Synchronizer "
#~ "<#synchronizer>`__를 통해 다른 피어로부터 빠진 블록을"
#~ " 다운로드 받습니다. 커밋된 블록은 `Ametsuchi "
#~ "<#ametsuchi>`__ 블록 저장소에 저장됩니다."

#~ msgid "Domain"
#~ msgstr "도메인(Domain)"

#~ msgid ""
#~ "A named abstraction for grouping "
#~ "`accounts <#account>`__ and `assets "
#~ "<#asset>`__."
#~ msgstr "`계정 <#account>`__ 과 `에셋 <#asset>`__의 그룹"

#~ msgid "Ordering Gate"
#~ msgstr "Ordering Gate"

#~ msgid ""
#~ "Internal Iroha component that passes "
#~ "`transactions <#transaction>`__ from `Peer "
#~ "Communication Service <#peer-communication-"
#~ "service>`__ to `Ordering Service "
#~ "<#ordering-service>`__. Ordering Gate eventually"
#~ " recieves `proposals <#proposal>`__ from "
#~ "Ordering Service and sends them to "
#~ "`Simulator <#simulator>`__ for `stateful "
#~ "validation <#stateful-validation>`__."
#~ msgstr ""
#~ "Iroha의 내부 컴포넌트로 `Peer Communication "
#~ "Service <#peer-communication-service>`__로부터 "
#~ "`트랜젝션 <#transaction>`__ 을 `Ordering Service"
#~ " <#ordering-service>`__로 전달합니다."

#~ msgid "Ordering Service"
#~ msgstr "Ordering Service"

#~ msgid ""
#~ "Internal Iroha component that combines "
#~ "several `transactions <#transaction>`__ that "
#~ "have been passed `stateless validation "
#~ "<#stateless-validation>`__ into a `proposal "
#~ "<#proposal>`__. Proposal creation could be "
#~ "triggered by one of the following "
#~ "events:"
#~ msgstr ""
#~ "Iroha의 내부 컴포넌트로 `stateless validation "
#~ "<#stateless-validation>`__을 통과한 여러 `트랜젝션 "
#~ "<#transaction>`__을 합쳐 `proposal <#proposal>`__로 "
#~ "만듭니다. Proposal 생성은 아래 이벤트 중 하나로"
#~ " 인해 일어나게 됩니다. "

#~ msgid "Time limit dedicated to transactions collection has expired."
#~ msgstr "트랜젝션을 모으는(transaction collection) 시간 제한이 지난 경우"

#~ msgid ""
#~ "Ordering service has received the "
#~ "maximum amount of transactions allowed "
#~ "for a single proposal."
#~ msgstr "Ordering service가 하나의 Proposal에 포함될 수 있는 트랜젝션 수보다 더 많은 트랜젝션을 받은 경우"

#~ msgid ""
#~ "Both parameters (timeout and maximum "
#~ "size of proposal) are configurable "
#~ "(check `environment-specific parameters "
#~ "<../guides/configuration.html#environment-specific-"
#~ "parameters>`_ page)."
#~ msgstr ""
#~ "두 파라미터 (시간초과와 Proposal의 최대 트랜젝션의 "
#~ "수)는 설정 가능합니다.(`environment-specific parameters"
#~ " <../guides/configuration.html#environment-specific-"
#~ "parameters>`_ 페이지를 확인하세요.)"

#~ msgid ""
#~ "A common precondition for both triggers"
#~ " is that at least one transaction "
#~ "should reach ordering service. Otherwise, "
#~ "no proposal will be formed."
#~ msgstr ""
#~ "위의 두 가지 경우 중 하나라도 발생하기 위해서는"
#~ " 적어도 하나의 트랜젝션이 Ordering Service에 도달해야"
#~ " 합니다. 그렇지 않으면 proposal은 생성되지 않습니다."

#~ msgid "Peer"
#~ msgstr ""

#~ msgid ""
#~ "A node that is a part of "
#~ "Iroha network. It participates in "
#~ "`consensus <#consensus>`_ process."
#~ msgstr "Iroha 네트워크의 일부인 노드입니다. `합의 <#consensus>`_ 과정에 참여합니다."

#~ msgid "Peer Communication Service"
#~ msgstr "Peer Communication Service"

#~ msgid ""
#~ "Internal component of Iroha - an "
#~ "intermediary that transmits `transaction "
#~ "<#transaction>`__ from `Torii <#torii>`__ to"
#~ " `Ordering Gate <#ordering-gate>`__. The"
#~ " main goal of PCS is to hide"
#~ " the complexity of interaction with "
#~ "consensus implementation."
#~ msgstr ""

#~ msgid "Permission"
#~ msgstr "권한(Permission)"

#~ msgid ""
#~ "A named rule that gives the "
#~ "privilege to perform a command. "
#~ "Permission **cannot** be granted to an"
#~ " `account <#account>`__ directly, instead, "
#~ "an account has roles, which are "
#~ "the collection of permissions."
#~ msgstr ""

#~ msgid "Grantable Permission"
#~ msgstr ""

#~ msgid ""
#~ "Only grantable permission is given to"
#~ " an `account <#account>`__ directly. An "
#~ "account that holds grantable permission "
#~ "is allowed to perform some particular"
#~ " action on behalf of another account."
#~ " For example, if the account "
#~ "a@domain1 gives the account b@domain2 a"
#~ " permission that it can transfer "
#~ "assets — then  b@domain2 can transfer"
#~ " assets of a@domain1 to anyone."
#~ msgstr ""

#~ msgid "Proposal"
#~ msgstr "Proposal"

#~ msgid ""
#~ "A set of `transactions <#transaction>`__ "
#~ "that have passed only `stateless "
#~ "validation <#stateless-validation>`__."
#~ msgstr ""

#~ msgid "Verified Proposal"
#~ msgstr "Verified Proposal"

#~ msgid ""
#~ "A set of transactions that have "
#~ "been passed `stateless <#stateless-"
#~ "validation>`__ and `stateful <#stateful-"
#~ "validation>`__ validation, but were not "
#~ "committed yet."
#~ msgstr ""

#~ msgid "Role"
#~ msgstr "역할(Role)"

#~ msgid "A named abstraction that holds a set of `permissions <#permission>`__."
#~ msgstr ""

#~ msgid "Simulator"
#~ msgstr "Simulator"

#~ msgid "See `Verified Proposal Creator <#verified-proposal-creator>`__."
#~ msgstr ""

#~ msgid ""
#~ "A request to Iroha that does "
#~ "**not** change the `state <#world-"
#~ "state-view>`__. By performing a query, "
#~ "a client can get request data from"
#~ " the state, for example a balance "
#~ "of his account, a history of "
#~ "transactions, etc."
#~ msgstr ""

#~ msgid "Synchronizer"
#~ msgstr "Synchronizer"

#~ msgid ""
#~ "Is a part of `consensus <#consensus>`__."
#~ " Adds missing blocks to `peers' "
#~ "<#peer>`__ chains (downloads them from "
#~ "other peers)."
#~ msgstr ""

#~ msgid "Torii"
#~ msgstr "Torii"

#~ msgid ""
#~ "⛩. Entry point for `clients "
#~ "<#client>`__. Uses gRPC as a transport."
#~ " In order to interact with Iroha "
#~ "anyone can use gRPC endpoints, described"
#~ " in `Commands <../api/commands.html>`__ and "
#~ "`Queries <../api/queries.html>`__ sections, or "
#~ "use `client libraries <../guides/libraries.html>`__."
#~ msgstr ""

#~ msgid ""
#~ "An ordered set of `commands "
#~ "<#command>`__, which is applied to the"
#~ " ledger atomically. Any nonvalid command"
#~ " within a transaction leads to "
#~ "rejection of the whole transaction "
#~ "during the validation process."
#~ msgstr ""

#~ msgid "Validator"
#~ msgstr "검증자(Validator)"

#~ msgid "There are two kinds of validation - stateless and stateful."
#~ msgstr "stateless 검증과 stateful 검증, 총 2 종류의 검증이 있습니다."

#~ msgid "Stateless Validation"
#~ msgstr "Stateless 검증"

#~ msgid ""
#~ "Performed in `Torii <#torii>`__. Checks "
#~ "if an object is well-formed, "
#~ "including the signatures."
#~ msgstr "`Torii <#torii>`__에서 수행됩니다. 서명(Signatures)를 포함한 객체가 잘 생성되었는지 확인합니다."

#~ msgid "Stateful Validation"
#~ msgstr "Stateful 검증"

#~ msgid ""
#~ "Performed in `Verified Proposal Creator "
#~ "<#verified-proposal-creator>`__. Validates "
#~ "against `World State View <#world-"
#~ "state-view>`__."
#~ msgstr ""
#~ "`Verified Proposal Creator <#verified-"
#~ "proposal-creator>`__에서 수행됩니다. `World State "
#~ "View <#world-state-view>`__에 대해서 검증을 "
#~ "시도합니다."

#~ msgid "Verified Proposal Creator"
#~ msgstr "Verified Proposal Creator"

#~ msgid ""
#~ "Internal Iroha component that performs "
#~ "`stateful validation <#stateful-validation>`_ "
#~ "of `transactions <#transaction>`__ contained "
#~ "in received `proposal <#proposal>`__. On "
#~ "the basis of transactions that have "
#~ "been passed stateful validation **verified "
#~ "proposal** will be created and passed"
#~ " to `Block Creator <#block-creator>`__. "
#~ "All the transactions that have not "
#~ "passed stateful validation will be "
#~ "dropped and not included in a "
#~ "verified proposal."
#~ msgstr ""

#~ msgid "World State View"
#~ msgstr "World State View"

#~ msgid ""
#~ "WSV reflects the current state of "
#~ "the system, can be considered as a"
#~ " snapshot. For example, WSV holds "
#~ "information about an amount of `assets"
#~ " <#asset>`__ that an `account <#account>`__"
#~ " has at the moment but does not"
#~ " contain any info history of "
#~ "`transaction <#transaction>`__ flow."
#~ msgstr ""

#~ msgid "https://en.bitcoin.it/wiki/Block"
#~ msgstr "https://en.bitcoin.it/wiki/Block"

#~ msgid ""
#~ "Docs are constantly updated and this "
#~ "section is going to be improved. "
#~ "Check glossary page while contents are"
#~ " elaborated."
#~ msgstr ""

#~ msgid "Client Libraries"
#~ msgstr "클라이언트 라이브러리"

#~ msgid ""
#~ "Contents are missing for now. Please "
#~ "check deploy/ansible folder and README.md "
#~ "file in it."
#~ msgstr "현재 컨텐츠가 비어있습니다. deploy/ansible 폴더와 그 안에 README.md 파일을 확인해주세요."

#~ msgid "2018-03-30"
#~ msgstr "2018-03-30"

#~ msgid "Simple deployment and maintenance"
#~ msgstr "간단한 배포(deployment) 및 유지보수(maintenance)"

#~ msgid "Variety of libraries for developers"
#~ msgstr "개발자들을 위한 다양한 라이브러리"

#~ msgid "Role-based access control"
#~ msgstr "역할(Role) 기반의 엑세스 컨트롤"

#~ msgid "Modular design, driven by command–query separation principle"
#~ msgstr "커맨드 쿼리 분리( command–query separation) 기반의 모듈러 디자인"

#~ msgid "Assets and identity management"
#~ msgstr "에셋과 identity 관리"

#~ msgid "In our quality model, we focus on and continuously improve:"
#~ msgstr "저희는 아래 사항들을 집중적으로 개선하기 위해 노력합니다."

#~ msgid "Reliability (fault tolerance, recoverability)"
#~ msgstr "신뢰성(Reliability) - 장애 허용(Fault Tolerance), Recoverability"

#~ msgid ""
#~ "Performance Efficiency (in particular time-"
#~ "behavior and resource utilization)"
#~ msgstr ""
#~ "Performance Efficiency (in particular time-"
#~ "behavior and resource utilization)"

#~ msgid ""
#~ "Usability (learnability, user error "
#~ "protection, appropriateness recognisability)"
#~ msgstr ""
#~ "Usability (learnability, user error "
#~ "protection, appropriateness recognisability)"

#~ msgid "Where can Iroha be used?"
#~ msgstr ""

#~ msgid ""
#~ "Hyperledger Iroha is a general purpose"
#~ " permissioned blockchain system that can"
#~ " be used to manage digital assets,"
#~ " identity, and serialized data. This "
#~ "can be useful for applications such "
#~ "as interbank settlement, central bank "
#~ "digital currencies, payment systems, national"
#~ " IDs, and logistics, among others."
#~ msgstr ""

#~ msgid ""
#~ "For a detailed description please check"
#~ " our `Use Case Scenarios section "
#~ "<http://iroha.readthedocs.io/en/latest/use_cases/>`_."
#~ msgstr ""

#~ msgid ""
#~ "Bitcoin and Ethereum are designed to "
#~ "be permissionless ledgers where anyone "
#~ "can join and access all the data."
#~ " They also have native cryptocurrencies "
#~ "that are required to interact with "
#~ "the systems."
#~ msgstr ""

#~ msgid ""
#~ "In Iroha, there is no native "
#~ "cryptocurrency. Instead, to meet the "
#~ "needs of enterprises, system interaction "
#~ "is permissioned, meaning that only "
#~ "people with requisite access can "
#~ "interact with the system. Additionally, "
#~ "queries are also permissioned, such that"
#~ " access to all the data can be"
#~ " controlled."
#~ msgstr ""

#~ msgid ""
#~ "One major difference from Ethereum, in"
#~ " particular, is that Hyperledger Iroha "
#~ "allows users to perform common "
#~ "functions, such as creating and "
#~ "transferring digital assets, by using "
#~ "prebuilt commands that are in the "
#~ "system. This negates the need to "
#~ "write cumbersome and hard to test "
#~ "smart contracts, enabling developers to "
#~ "complete simple tasks faster and with"
#~ " less risk."
#~ msgstr ""

#~ msgid ""
#~ "Iroha has a novel, Byzantine fault "
#~ "tolerant consensus algorithm (called YAC "
#~ "[#f1]_) that is high-performance and "
#~ "allows for finality of transactions with"
#~ " low latency. Other frameworks either "
#~ "focus more on probabilistic consensus "
#~ "algorithms, such as Nakamoto Consensus, "
#~ "or sacrifice Byzantine fault tolerance."
#~ msgstr ""

#~ msgid ""
#~ "Also, Iroha's built-in commands are "
#~ "a major benefit compared to other "
#~ "platforms, since it is very simple "
#~ "to do common tasks such as create"
#~ " digital assets, register accounts, and "
#~ "transfer assets between accounts. Moreover,"
#~ " it narrows the attack vector, "
#~ "improving overall security of the "
#~ "system, as there are less things "
#~ "to fail."
#~ msgstr ""

#~ msgid ""
#~ "Finally, Iroha is the only ledger "
#~ "that has a robust permission system, "
#~ "allowing permissions to be set for "
#~ "all commands, queries, and joining of"
#~ " the network."
#~ msgstr ""

#~ msgid "Yet Another Consensus"
#~ msgstr "Yet Another Consensus"

#~ msgid ""
#~ "As per the latest review date of"
#~ " these docs, according to `Huawei "
#~ "Caliper <https://github.com/hyperledger/caliper>`_ testing"
#~ " tool, Iroha is capable of processing"
#~ " 45 transactions per second. Theoretically,"
#~ " this is not even close to the"
#~ " limit of the system, and we "
#~ "will continue constant optimizations in "
#~ "order to improve stability and "
#~ "performance."
#~ msgstr ""

#~ msgid ""
#~ "In order to bring the power of "
#~ "blockchain into your application, you "
#~ "should think first of how it is"
#~ " going to interface with Iroha peers."
#~ " A good start is to check `Core"
#~ " Concepts section "
#~ "<http://iroha.readthedocs.io/en/latest/core_concepts/>`_, "
#~ "explaining what exactly is a transaction"
#~ " and query, and how users of "
#~ "your application are supposed to "
#~ "interact with it."
#~ msgstr ""

#~ msgid ""
#~ "We also have several client libraries"
#~ " which provide tools for developers "
#~ "to form building blocks, such as "
#~ "signatures, commands, send messages to "
#~ "Iroha peers and check the status."
#~ msgstr ""

#~ msgid "Android Library"
#~ msgstr "Android 라이브러리"

#~ msgid ""
#~ "The library, in essence, is a set"
#~ " of Java interfaces and binary "
#~ "libraries compiled for different "
#~ "architectures. Supported architectures are "
#~ "*arm, x86, x86_64*."
#~ msgstr ""
#~ "본질적으로 라이브러리는 자바 인터페이스와 서로 다른 "
#~ "아키텍쳐에서 컴파일 된 바이너리 라이브러리의 모음입니다. "
#~ "지원되는 아키텍쳐는 *arm, x86, x86_64*입니다."

#~ msgid "Where to Get"
#~ msgstr "라이브러리 얻기"

#~ msgid "There are two ways to get Iroha library for Android:"
#~ msgstr "Android용 Iroha 라이브러리를 얻을 수 있는 방법은 2가지 입니다."

#~ msgid ""
#~ "Grab via Gradle (see details in "
#~ "the section `Importing the Library from"
#~ " jcenter`_)"
#~ msgstr "Gradle을 통해 얻는 방법(`Importing the Library from jcenter`_섹션에서 자세하게 다룹니다.)"

#~ msgid "Compile the library on your own."
#~ msgstr "직접 라이브러리를 컴파일 하는 방법"

#~ msgid "Both options are described in the following sections."
#~ msgstr "두 방법 모두 아래에 있는 섹션에서 자세히 다룹니다."

#~ msgid "Manual Build"
#~ msgstr "직접 빌드하기"

#~ msgid "The guide was tested on systems running Ubuntu 16.04 and macOS."
#~ msgstr "이 가이드는 Ubuntu 16.04와 macOS에서 테스트되었습니다."

#~ msgid "Android NDK"
#~ msgstr "Android NDK"

#~ msgid ""
#~ "Please `download "
#~ "<https://developer.android.com/ndk/downloads/index.html>`__ and"
#~ " unpack NDK to any suitable folder."
#~ msgstr ""

#~ msgid "Automake, Bison, Cmake"
#~ msgstr "Automake, Bison, Cmake"

#~ msgid ""
#~ "Please refer to the page `Installing "
#~ "Dependencies <dependencies.html>`__ to get "
#~ "installation recipes for the tools."
#~ msgstr ""

#~ msgid "Building the Library"
#~ msgstr "라이브러리 빌드하기"

#~ msgid ""
#~ "All you need now is to download"
#~ " `build script "
#~ "<https://github.com/hyperledger/iroha/blob/develop/shared_model/packages/android"
#~ "/android-build.sh>`__ ``android-build.sh`` to "
#~ "any empty folder and launch it "
#~ "there."
#~ msgstr ""

#~ msgid "Launch parameters are listed in the table below."
#~ msgstr ""

#~ msgid "Position"
#~ msgstr "Position"

#~ msgid "Required"
#~ msgstr ""

#~ msgid "Parameter Name"
#~ msgstr "파라미터 이름"

#~ msgid "Possible Values"
#~ msgstr ""

#~ msgid "1"
#~ msgstr "1"

#~ msgid "Yes"
#~ msgstr ""

#~ msgid "**Platform Name**"
#~ msgstr "**플랫폼 이름**\n"

#~ msgid "Name of the target platform for binary part of the library."
#~ msgstr "라이브러리의 바이너리를 위한 타겟 플랫폼의 이름"

#~ msgid "``arm64-v8a``, ``armeabi-v7a``, ``armeabi``, ``x86``, ``x86_64``"
#~ msgstr "``arm64-v8a``, ``armeabi-v7a``, ``armeabi``, ``x86``, ``x86_64``"

#~ msgid "**Android API Level**"
#~ msgstr "**Android API Level**"

#~ msgid ""
#~ "API level supported by your NDK. "
#~ "See the link under the table for"
#~ " details."
#~ msgstr ""

#~ msgid "``27`` for android-ndk-r16b"
#~ msgstr ""

#~ msgid "3"
#~ msgstr "3"

#~ msgid "**Android NDK Path**"
#~ msgstr "**Android NDK Path**"

#~ msgid ""
#~ "Full path to unpacked NDK. Please "
#~ "ensure that path does not contain "
#~ "spaces."
#~ msgstr ""

#~ msgid "``/home/user/lib/android-ndk-r16b``"
#~ msgstr "``/home/user/lib/android-ndk-r16b``"

#~ msgid "4"
#~ msgstr "4"

#~ msgid "**Java Package Name**"
#~ msgstr "**Java Package Name**"

#~ msgid ""
#~ "Package name that will be used for"
#~ " Java interfaces generation. Note that "
#~ "the binary also depends on chosen "
#~ "package name."
#~ msgstr ""

#~ msgid "``jp.co.soramitsu.iroha.android``"
#~ msgstr "``jp.co.soramitsu.iroha.android``"

#~ msgid "No"
#~ msgstr ""

#~ msgid "**Build Type**"
#~ msgstr "**Build Type**"

#~ msgid ""
#~ "Defines build mode of binary part "
#~ "of the library. ``Release`` is the "
#~ "default option."
#~ msgstr ""

#~ msgid "``Debug`` or ``Release``"
#~ msgstr "``Debug`` 또는 ``Release``"

#~ msgid ""
#~ "`Android API levels "
#~ "<https://developer.android.com/guide/topics/manifest/uses-"
#~ "sdk-element.html#ApiLevels>`__"
#~ msgstr ""

#~ msgid ""
#~ "Please use the same root part of"
#~ " Java package name for library build"
#~ " as you use for your Android "
#~ "project. For example, your project is"
#~ " located in a package called "
#~ "``com.mycompany.androidapp``, so please consider "
#~ "to build the library in a package,"
#~ " which name starts with "
#~ "``com.mycompany.androidapp`` (e.g. "
#~ "``com.mycompany.androidapp.iroha``)."
#~ msgstr ""

#~ msgid "A couple of launch commands examples:"
#~ msgstr ""

#~ msgid ""
#~ "Build artefacts will be collected in "
#~ "``lib`` directory near the script "
#~ "``android-build.sh``. There will be two "
#~ "files - an archive ``bindings.zip`` and"
#~ " ``libirohajava.so``."
#~ msgstr ""

#~ msgid "How to Use/Import"
#~ msgstr ""

#~ msgid "Importing the Library from jcenter"
#~ msgstr ""

#~ msgid ""
#~ "The easiest way to use Irohalib "
#~ "for Android is to import the "
#~ "library dependency from `jcenter "
#~ "<https://bintray.com/bulatmukhutdinov/maven/iroha-android-"
#~ "bindings>`__."
#~ msgstr ""

#~ msgid "All you need to do is a simple set of four steps:"
#~ msgstr ""

#~ msgid "Add to your ``build.gradle`` file the following line:"
#~ msgstr ""

#~ msgid ""
#~ "Copy the latest version of ``*.proto``"
#~ " files from ``develop`` branch of "
#~ "Iroha `repository "
#~ "<https://github.com/hyperledger/iroha/tree/develop/schema>`__ "
#~ "into ``app/src/main/proto/`` folder inside "
#~ "your project in Android Studio."
#~ msgstr ""

#~ msgid "The resulting directory structure should look like as follows:"
#~ msgstr ""

#~ msgid ""
#~ "Create additional directories "
#~ "``app/src/main/proto/google/protobuf/`` and place "
#~ "there a file called ``empty.proto`` with"
#~ " the following contents:"
#~ msgstr ""

#~ msgid ""
#~ "Add ``protobuf`` and ``grpc`` dependecies "
#~ "and protobuf configuration block into "
#~ "your ``build.gradle`` file."
#~ msgstr ""

#~ msgid "How to Use Manually Built Library"
#~ msgstr ""

#~ msgid ""
#~ "Create directory structure inside your "
#~ "Android project according to the package"
#~ " name of build library. Put there "
#~ "all the ``.java`` files from "
#~ "``bindings.zip`` archive. For example, the "
#~ "path could be "
#~ "``app/src/main/java/com/mycompany/iroha`` if you "
#~ "built the library with ``com.mycompany.iroha``"
#~ " package name."
#~ msgstr ""

#~ msgid ""
#~ "Create directory ``app/src/main/jniLibs/<platform>`` "
#~ "where ``<platform>`` is the name of "
#~ "target platform (e.g. ``arm64-v8a``). Put "
#~ "there ``libirohajava.so``. Repeat this step"
#~ " for all required platforms (in this"
#~ " case you need to build the "
#~ "library for each platform)."
#~ msgstr ""

#~ msgid ""
#~ "Repeat steps 2-4 from the previous "
#~ "section `Importing the Library from "
#~ "jcenter`_."
#~ msgstr ""

#~ msgid "Example Code"
#~ msgstr "예시 코드"

#~ msgid ""
#~ "Explore ``bindings`` branch of `iroha-"
#~ "android <https://github.com/hyperledger/iroha-"
#~ "android/tree/bindings>`__ repository to get "
#~ "source code and view sample application."
#~ msgstr ""

#~ msgid "Java Library"
#~ msgstr "Java 라이브러리"

#~ msgid "Java 6"
#~ msgstr "Java 6"

#~ msgid "Gradle"
#~ msgstr "Gradle"

#~ msgid ""
#~ "For the latest version checkout a "
#~ "``develop`` branch by adding ``-b "
#~ "develop`` parameter."
#~ msgstr ""

#~ msgid ""
#~ "Now we need to build our Java "
#~ "native library. Run "
#~ "``example/java/build_library.sh``, which will take"
#~ " care of it."
#~ msgstr ""

#~ msgid ""
#~ "``build_library.sh`` script creates a ``dist``"
#~ " folder with files, needed in :ref"
#~ ":`java-how-to-use` section."
#~ msgstr ""

#~ msgid "How to Use"
#~ msgstr ""

#~ msgid "There are two ways of adding the Java library to your project:"
#~ msgstr ""

#~ msgid "Import Java bindings through Maven Central"
#~ msgstr ""

#~ msgid "Compile Java bindings manually"
#~ msgstr ""

#~ msgid "Import Java Bindings from Maven Central"
#~ msgstr ""

#~ msgid ""
#~ "First of all, you need to copy "
#~ "``example/java/dist/libirohajava.jnilib`` to the "
#~ "root folder of your project."
#~ msgstr ""

#~ msgid ""
#~ "If you use **Gradle**, add the "
#~ "following line to your ``build.gradle`` "
#~ "file:"
#~ msgstr ""

#~ msgid "build.gradle"
#~ msgstr "build.gradle"

#~ msgid "pom.xml"
#~ msgstr "pom.xml"

#~ msgid ""
#~ "Set the latest version number from "
#~ "our `Maven repository "
#~ "<https://mvnrepository.com/artifact/jp.co.soramitsu/iroha>`_"
#~ msgstr ""

#~ msgid "Compiling Java Bindings Manually"
#~ msgstr ""

#~ msgid ""
#~ "Java bindings were compiled with "
#~ "``example/java/build_library.sh`` in `Build Process`"
#~ " section. You need to copy "
#~ "``example/java/dist/libirohajava.jnilib`` to the "
#~ "root folder of your project:"
#~ msgstr ""

#~ msgid ""
#~ "If you use **Gradle**, you need to"
#~ " copy ``example/java/dist/iroha_lib.jar`` to the"
#~ " ``libs`` folder of your project"
#~ msgstr ""

#~ msgid "Then please add the following to your ``build.gradle`` file:"
#~ msgstr ""

#~ msgid "After it please add this to your ``pom.xml``:"
#~ msgstr ""

#~ msgid ""
#~ "Explore ``example/java/TransactionExample.java`` file "
#~ "to get an idea of how to "
#~ "work with a library."
#~ msgstr ""

#~ msgid "To start the example, you need to build the example:"
#~ msgstr ""

#~ msgid "Python Library"
#~ msgstr "Python 라이브러리"

#~ msgid ""
#~ "There are two ways to get Iroha"
#~ " library for Python: via pip and "
#~ "manual compilation from source code. The"
#~ " installation via pip do the same "
#~ "steps as manual compilation so for "
#~ "both of them you need to install"
#~ " all of the prerequisites."
#~ msgstr ""

#~ msgid "CMake, git, g++, boost, swig, protobuf, python"
#~ msgstr "CMake, git, g++, boost, swig, protobuf, python"

#~ msgid "Install Iroha Python Libraries"
#~ msgstr ""

#~ msgid "Via PIP"
#~ msgstr ""

#~ msgid "For the latest version"
#~ msgstr ""

#~ msgid "Source code"
#~ msgstr "소스 코드"

#~ msgid ""
#~ "For the latest version checkout to "
#~ "develop branch by adding *-b develop*"
#~ " parameter."
#~ msgstr ""

#~ msgid ""
#~ "After this you can find Iroha "
#~ "python library in "
#~ "**iroha/build/shared_model/bindings** folder, where "
#~ "you have previously cloned repository."
#~ msgstr ""

#~ msgid "Compile Protobuf Modules of Iroha from Schema Files"
#~ msgstr ""

#~ msgid ""
#~ "Iroha communicates with users through "
#~ "protobuf messages. In order to send "
#~ "transactions and queries to Iroha node"
#~ " you need to get python module "
#~ "for generating protobuf messages. First "
#~ "of all you need to clone schema"
#~ " folder of Iroha repository. If you"
#~ " have already cloned Iroha repository "
#~ "in the previous step, just use "
#~ "schema folder from there."
#~ msgstr ""

#~ msgid "protobuf, pip"
#~ msgstr "protobuf, pip"

#~ msgid "Building Protobuf Files"
#~ msgstr ""

#~ msgid ""
#~ "Protobuf files can be found in "
#~ "**iroha-schema** folder ('\\*_pb2\\*.py' files)"
#~ msgstr ""

#~ msgid "In order to specify Iroha libraries location:"
#~ msgstr ""

#~ msgid "Import Iroha and all of the protobuf modules that you need:"
#~ msgstr ""

#~ msgid ""
#~ "Work with byte arrays is different "
#~ "in Python 2 and Python 3. Due "
#~ "to this fact, the work with hashes"
#~ " and blobs is different in the "
#~ "examples. Given examples work fine with"
#~ " both versions of Python."
#~ msgstr ""

#~ msgid "Import Iroha and schema classes, generated from Iroha protobuf:"
#~ msgstr ""

#~ msgid "Get Iroha objects:"
#~ msgstr ""

#~ msgid "Read public and private keys:"
#~ msgstr ""

#~ msgid "Print transaction status with synchronous simple call:"
#~ msgstr ""

#~ msgid "Or streaming call:"
#~ msgstr ""

#~ msgid "Send transactions to Iroha:"
#~ msgstr ""

#~ msgid "Send query to Iroha and receive a responce:"
#~ msgstr ""

#~ msgid "Create domain and asset:"
#~ msgstr ""

#~ msgid "Create asset quantity:"
#~ msgstr ""

#~ msgid "Create account:"
#~ msgstr ""

#~ msgid "Send asset:"
#~ msgstr ""

#~ msgid "Get asset info:"
#~ msgstr ""

#~ msgid "Get account asset:"
#~ msgstr ""

#~ msgid "Building Iroha"
#~ msgstr ""

#~ msgid ""
#~ "In this guide we will learn how"
#~ " to install all dependencies, required "
#~ "to build Iroha and how to build"
#~ " it."
#~ msgstr ""

#~ msgid "Preparing the Environment"
#~ msgstr ""

#~ msgid ""
#~ "In order to successfully build Iroha,"
#~ " we need to configure the "
#~ "environment. There are several ways to"
#~ " do it and we will describe all"
#~ " of them."
#~ msgstr ""

#~ msgid ""
#~ "Currently, we support Unix-like systems"
#~ " (we are basically targeting popular "
#~ "Linux distros and macOS). If you "
#~ "happen to have Windows or you "
#~ "don't want to spend time installing "
#~ "all dependencies you might want to "
#~ "consider using Docker environment. Also, "
#~ "Windows users might consider using `WSL"
#~ " <https://en.wikipedia.org/wiki/Windows_Subsystem_for_Linux>`_"
#~ msgstr ""

#~ msgid ""
#~ "Having troubles? Check FAQ section or"
#~ " communicate to us directly, in case"
#~ " you were stuck on something. We "
#~ "don't expect this to happen, but "
#~ "some issues with an environment are "
#~ "possible."
#~ msgstr ""

#~ msgid ""
#~ "You don't need Docker to run "
#~ "Iroha, it is just one of the "
#~ "possible choices."
#~ msgstr ""

#~ msgid ""
#~ "First of all, you need to install"
#~ " ``docker`` and ``docker-compose``. You "
#~ "can read how to install it on "
#~ "a `Docker's website <https://www.docker.com"
#~ "/community-edition/>`_"
#~ msgstr ""

#~ msgid "Please, use the latest available docker daemon and docker-compose."
#~ msgstr ""

#~ msgid ""
#~ "Then you should clone the `Iroha "
#~ "repository <https://github.com/hyperledger/iroha>`_ to "
#~ "the directory of your choice."
#~ msgstr ""

#~ msgid ""
#~ "After it, you need to run the "
#~ "development environment. Run the ``scripts"
#~ "/run-iroha-dev.sh`` script:"
#~ msgstr ""

#~ msgid ""
#~ "Please make sure that Docker is "
#~ "running before executing the script. "
#~ "macOS users could find a Docker "
#~ "icon in system tray, Linux user "
#~ "could use ``systemctl start docker``"
#~ msgstr ""

#~ msgid "After you execute this script, following things happen:"
#~ msgstr ""

#~ msgid ""
#~ "1. The script checks if you don't"
#~ " have containers with Iroha already "
#~ "running. Successful completion finishes with"
#~ " the new container shell. 2. The "
#~ "script will download ``iroha-docker-"
#~ "develop`` and ``postgres`` images. ``iroha-"
#~ "docker-develop`` image contains all "
#~ "development dependencies and is based on"
#~ " top of ``ubuntu:16.04``. ``postgres`` "
#~ "image is required for starting and "
#~ "running Iroha. 3. Two containers are "
#~ "created and launched. 4. The user "
#~ "is attached to the interactive "
#~ "environment for development and testing "
#~ "with ``iroha`` folder mounted from the"
#~ " host machine. Iroha folder is "
#~ "mounted to ``/opt/iroha`` in Docker "
#~ "container."
#~ msgstr ""

#~ msgid ""
#~ "Now your are ready to build Iroha!"
#~ " Please go to `Building Iroha` "
#~ "section."
#~ msgstr ""

#~ msgid "Linux"
#~ msgstr "리눅스"

#~ msgid "Boost"
#~ msgstr "부스트"

#~ msgid ""
#~ "Iroha requires Boost of at least "
#~ "1.65 version. To install Boost libraries"
#~ " (``libboost-all-dev``), use `current "
#~ "release <http://www.boost.org/users/download/>`_ from "
#~ "Boost webpage. The only dependencies are"
#~ " system and filesystem, so use "
#~ "``./bootstrap.sh --with-libraries=system,filesystem`` "
#~ "when you are building the project."
#~ msgstr ""

#~ msgid "Other Dependencies"
#~ msgstr "다른 종속성"

#~ msgid "To build Iroha, you need following packages:"
#~ msgstr ""

#~ msgid ""
#~ "``build-essential`` ``automake`` ``libtool`` "
#~ "``libssl-dev`` ``zlib1g-dev`` ``libc6-dbg`` "
#~ "``golang`` ``git`` ``tar`` ``gzip`` ``ca-"
#~ "certificates`` ``wget`` ``curl`` ``file`` "
#~ "``unzip`` ``python`` ``cmake``"
#~ msgstr ""

#~ msgid "Use this code to install dependencies on Debian-based Linux distro."
#~ msgstr ""

#~ msgid ""
#~ "If you are willing to actively "
#~ "develop Iroha and to build shared "
#~ "libraries, please consider installing the "
#~ "`latest release <https://cmake.org/download/>`_ of"
#~ " CMake."
#~ msgstr ""

#~ msgid "macOS"
#~ msgstr "macOS"

#~ msgid ""
#~ "If you want to build it from "
#~ "scratch and actively develop it, please"
#~ " use this code to install all "
#~ "dependencies with Homebrew."
#~ msgstr ""

#~ msgid "To install the Homebrew itself please run"
#~ msgstr ""

#~ msgid ""
#~ "``ruby -e \"$(curl -fsSL "
#~ "https://raw.githubusercontent.com/homebrew/install/master/install)\"``"
#~ msgstr ""

#~ msgid "Cloning the Repository"
#~ msgstr ""

#~ msgid ""
#~ "Clone the `Iroha repository "
#~ "<https://github.com/hyperledger/iroha>`_ to the "
#~ "directory of your choice."
#~ msgstr ""

#~ msgid ""
#~ "If you have installed the prerequisites"
#~ " with Docker, you don't need to "
#~ "clone Iroha again, because when you "
#~ "run ``run-iroha-dev.sh`` it attaches "
#~ "to Iroha source code folder. Feel "
#~ "free to edit source code files "
#~ "with your host environment and build "
#~ "it within docker container."
#~ msgstr ""

#~ msgid "To build Iroha, use those commands"
#~ msgstr ""

#~ msgid ""
#~ "Alternatively, you can use these "
#~ "shorthand parameters (they are not "
#~ "documented though)"
#~ msgstr ""

#~ msgid ""
#~ "On macOS ``$(nproc)`` variable does not"
#~ " work. Check the number of logical"
#~ " cores with ``sysctl -n hw.ncpu`` and"
#~ " put it explicitly in the command "
#~ "above, e.g. ``cmake --build build -- "
#~ "-j4``"
#~ msgstr ""

#~ msgid "CMake Parameters"
#~ msgstr "CMake 파라미터"

#~ msgid ""
#~ "We use CMake to build platform-"
#~ "dependent build files. It has numerous"
#~ " flags for configuring the final "
#~ "build. Note that besides the listed "
#~ "parameters cmake's variables can be "
#~ "useful as well. Also as long as"
#~ " this page can be deprecated (or "
#~ "just not complete) you can browse "
#~ "custom flags via ``cmake -L``, "
#~ "``cmake-gui``, or ``ccmake``."
#~ msgstr ""

#~ msgid ""
#~ "You can specify parameters at the "
#~ "cmake configuring stage (e.g cmake "
#~ "-DTESTING=ON)."
#~ msgstr ""

#~ msgid "Main Parameters"
#~ msgstr "주요 파라미터"

#~ msgid "Possible values"
#~ msgstr ""

#~ msgid "Default"
#~ msgstr "디폴트"

#~ msgid "TESTING"
#~ msgstr "TESTING"

#~ msgid "ON/OFF"
#~ msgstr "ON/OFF"

#~ msgid "ON"
#~ msgstr "ON"

#~ msgid "Enables or disables build of the tests"
#~ msgstr ""

#~ msgid "BENCHMARKING"
#~ msgstr "BENCHMARKING"

#~ msgid "OFF"
#~ msgstr "OFF"

#~ msgid "Enables or disables build of the Google Benchmarks library"
#~ msgstr ""

#~ msgid "COVERAGE"
#~ msgstr "COVERAGE"

#~ msgid "Enables or disables lcov setting for code coverage generation"
#~ msgstr ""

#~ msgid "SWIG_PYTHON"
#~ msgstr "SWIG_PYTHON"

#~ msgid "Enables of disables the library building and Python bindings"
#~ msgstr ""

#~ msgid "SWIG_JAVA"
#~ msgstr "SWIG_JAVA"

#~ msgid "Enables of disables the library building and Java bindings"
#~ msgstr ""

#~ msgid "Packaging Specific Parameters"
#~ msgstr ""

#~ msgid "ENABLE_LIBS_PACKAGING"
#~ msgstr "ENABLE_LIBS_PACKAGING"

#~ msgid "Enables or disables all types of packaging"
#~ msgstr ""

#~ msgid "PACKAGE_ZIP"
#~ msgstr "PACKAGE_ZIP"

#~ msgid "Enables or disables zip packaging"
#~ msgstr ""

#~ msgid "PACKAGE_TGZ"
#~ msgstr "PACKAGE_TGZ"

#~ msgid "Enables or disables tar.gz packaging"
#~ msgstr ""

#~ msgid "PACKAGE_RPM"
#~ msgstr "PACKAGE_RPM"

#~ msgid "Enables or disables rpm packaging"
#~ msgstr ""

#~ msgid "PACKAGE_DEB"
#~ msgstr "PACKAGE_DEB"

#~ msgid "Enables or disables deb packaging"
#~ msgstr ""

#~ msgid "Running Tests (optional)"
#~ msgstr "테스트하기 (선택사항)"

#~ msgid ""
#~ "After building Iroha, it is a good"
#~ " idea to run tests to check the"
#~ " operability of the daemon. You can"
#~ " run tests with this code:"
#~ msgstr ""

#~ msgid "Alternatively, you can run following command in the ``build`` folder"
#~ msgstr ""

#~ msgid ""
#~ "Some of the tests will fail "
#~ "without PostgreSQL storage running, so "
#~ "if you are not using ``scripts/run-"
#~ "iroha-dev.sh`` script please run Docker"
#~ " container or create a local "
#~ "connection with following parameters:"
#~ msgstr ""

#~ msgid "Installing Dependencies"
#~ msgstr "종속성 설치하기"

#~ msgid ""
#~ "This page contains references and guides"
#~ " about installation of various tools "
#~ "you may need during build of "
#~ "different targets of Iroha project."
#~ msgstr ""

#~ msgid ""
#~ "Please note that most likely you "
#~ "do not need to install all the "
#~ "listed tools. Some of them are "
#~ "required only for building specific "
#~ "versions of Iroha Client Library."
#~ msgstr ""

#~ msgid "Automake"
#~ msgstr "Automake"

#~ msgid "Installation on Ubuntu"
#~ msgstr "우분투에서 설치하기"

#~ msgid "Bison"
#~ msgstr "Bison"

#~ msgid "CMake"
#~ msgstr "CMake"

#~ msgid ""
#~ "Minimum required version is 3.8, but "
#~ "we recommend to install the latest "
#~ "available version (3.10.3 at the "
#~ "moment)."
#~ msgstr "최소 요구 버전은 3.8이지만 최신 버전으로 설치하는 것을 권장합니다.(현재 3.10.3 버전이 최신입니다.)"

#~ msgid ""
#~ "Since Ubuntu repositories contain unsuitable"
#~ " version of CMake, you need to "
#~ "install the new one manually. Here "
#~ "is how to build and install CMake"
#~ " from sources."
#~ msgstr ""
#~ "우분투 저장소의 CMake는 버전이 맞지 않기 때문에 "
#~ "직접 설치릉 해야 합니다. 아래에 Cmake를 소스에서 "
#~ "빌드하고 설치할 수 있는 방법이 있습니다."

#~ msgid "Installation on macOS"
#~ msgstr "macOS에서 설치하기"

#~ msgid "Git"
#~ msgstr "깃"

#~ msgid "Python"
#~ msgstr "파이썬"

#~ msgid "For Python 2:"
#~ msgstr "파이썬2"

#~ msgid "For Python 3:"
#~ msgstr "파이썬3"

#~ msgid "PIP"
#~ msgstr "PIP"

#~ msgid "SWIG"
#~ msgstr "SWIG"

#~ msgid "Protobuf"
#~ msgstr "Protobuf"

#~ msgid ""
#~ "Please note that due to a known"
#~ " issue you would not get any "
#~ "exception if you pass invalid precision"
#~ " value. Valid range is: 0 <= "
#~ "precision <= 255"
#~ msgstr ""

#~ msgid "0 <= precision <= 255"
#~ msgstr ""

#~ msgid "RolePermission"
#~ msgstr ""

#~ msgid "id of the account to which the rights are granted"
#~ msgstr ""

#~ msgid "GrantablePermission name"
#~ msgstr ""

#~ msgid "name of grantable permission"
#~ msgstr ""

#~ msgid ""
#~ "If there was a value for a "
#~ "given key already in the storage "
#~ "then it will be replaced with the"
#~ " new value"
#~ msgstr ""

#~ msgid "id of the account to which the key-value information was set"
#~ msgstr ""

#~ msgid ""
#~ "number of signatories needed to be "
#~ "included within a transaction from this"
#~ " account"
#~ msgstr ""

#~ msgid "ID of the account to withdraw the asset from"
#~ msgstr ""

#~ msgid "ID of the account to send the asset to"
#~ msgstr ""

#~ msgid "ID of the asset to transfer"
#~ msgstr ""

#~ msgid "Message to attach to the transfer"
#~ msgstr ""

#~ msgid "Get Pending Transactions"
#~ msgstr ""

#~ msgid ""
#~ "GetPendingTransactions is used for retrieving"
#~ " a list of pending (not fully "
#~ "signed) `multisignature transactions "
#~ "<../core_concepts/glossary.html#multisignature-transactions>`_"
#~ " or `batches of transactions "
#~ "<../core_concepts/glossary.html#batch-of-transactions>`__"
#~ " issued by account of query creator."
#~ msgstr ""

#~ msgid ""
#~ "The response contains a list of "
#~ "`pending transactions <../core_concepts/glossary.html"
#~ "#pending-transactions>`_."
#~ msgstr ""

#~ msgid "an array of pending transactions"
#~ msgstr ""

#~ msgid "Pending transactions"
#~ msgstr ""

#~ msgid ""
#~ "In a case when a list of "
#~ "transactions per account is needed, "
#~ "`GetAccountTransactions` query can be formed."
#~ " .. note:: This query uses pagination"
#~ " for query responses."
#~ msgstr ""

#~ msgid "Page size"
#~ msgstr ""

#~ msgid ""
#~ "size of the page to be returned"
#~ " by the query, if the response "
#~ "contains fewer transactions than a page"
#~ " size, then next tx hash will "
#~ "be empty in response"
#~ msgstr ""

#~ msgid "page_size > 0"
#~ msgstr ""

#~ msgid "First tx hash"
#~ msgstr ""

#~ msgid ""
#~ "hash of the first transaction in "
#~ "the page. If that field is not "
#~ "set — then the first transactions "
#~ "are returned"
#~ msgstr ""

#~ msgid "hash in hex format"
#~ msgstr ""

#~ msgid "bddd58404d1315e0eb27902c5d7c8eb0602c16238f005773df406bc191308929"
#~ msgstr ""

#~ msgid "All transactions size"
#~ msgstr ""

#~ msgid "total number of transactions created by the given account"
#~ msgstr ""

#~ msgid "100"
#~ msgstr ""

#~ msgid "Next transaction hash"
#~ msgstr ""

#~ msgid ""
#~ "hash pointing to the next transaction"
#~ " after the last transaction in the"
#~ " page. Empty if a page contains "
#~ "the last transaction for the given "
#~ "account"
#~ msgstr ""

#~ msgid ""
#~ "`GetAccountAssetTransactions` query returns all "
#~ "transactions associated with given account "
#~ "and asset. .. note:: This query "
#~ "uses pagination for query responses."
#~ msgstr ""

#~ msgid "total number of transactions for given account and asset"
#~ msgstr ""

#~ msgid ""
#~ "hash pointing to the next transaction"
#~ " after the last transaction in the"
#~ " page. Empty if a page contains "
#~ "the last transaction for given account"
#~ " and asset"
#~ msgstr ""

#~ msgid ""
#~ "To get the state of all assets "
#~ "in an account (a balance), "
#~ "`GetAccountAssets` query can be used."
#~ msgstr ""

#~ msgid "Get Account Detail"
#~ msgstr ""

#~ msgid ""
#~ "To get details of the account, "
#~ "`GetAccountDetail` query can be used. "
#~ "Account details are key-value pairs, "
#~ "splitted into writers categories. Writers "
#~ "are accounts, which added the "
#~ "corresponding account detail. Example of "
#~ "such structure is:"
#~ msgstr ""

#~ msgid ""
#~ "Here, one can see four account "
#~ "details - \"age\", \"hobbies\" and "
#~ "\"sports\" - added by two writers "
#~ "- \"account@a_domain\" and \"account@b_domain\". "
#~ "All of these details, obviously, are "
#~ "about the same account."
#~ msgstr ""

#~ msgid ""
#~ "Pay attention, that all fields are "
#~ "optional. Reasons will be described "
#~ "later."
#~ msgstr ""

#~ msgid "account id to get details from"
#~ msgstr ""

#~ msgid "account@domain"
#~ msgstr ""

#~ msgid "key, under which to get details"
#~ msgstr ""

#~ msgid "string"
#~ msgstr ""

#~ msgid "age"
#~ msgstr ""

#~ msgid "Writer"
#~ msgstr ""

#~ msgid "account id of writer"
#~ msgstr ""

#~ msgid "Detail"
#~ msgstr ""

#~ msgid "key-value pairs with account details"
#~ msgstr ""

#~ msgid "see below"
#~ msgstr ""

#~ msgid "Usage Examples"
#~ msgstr ""

#~ msgid ""
#~ "Let's again consider the example of "
#~ "details from the beginning and see, "
#~ "how different variants of `GetAccountDetail`"
#~ " queries will change the resulting "
#~ "response."
#~ msgstr ""

#~ msgid "**account_id is not set**"
#~ msgstr ""

#~ msgid ""
#~ "If account_id is not set - other"
#~ " fields can be empty or not -"
#~ " it will automatically be substituted "
#~ "with query creator's account, which will"
#~ " lead to one of the next cases."
#~ msgstr ""

#~ msgid "**only account_id is set**"
#~ msgstr ""

#~ msgid ""
#~ "In this case, all details about "
#~ "that account are going to be "
#~ "returned, leading to the following "
#~ "response:"
#~ msgstr ""

#~ msgid "**account_id and key are set**"
#~ msgstr ""

#~ msgid ""
#~ "Here, details added by all writers "
#~ "under the key are going to be "
#~ "returned. For example, if we asked "
#~ "for the key \"age\", that's the "
#~ "response we would get:"
#~ msgstr ""

#~ msgid "**account_id and writer are set**"
#~ msgstr ""

#~ msgid ""
#~ "Now, the response will contain all "
#~ "details about this account, added by "
#~ "one specific writer. For example, if "
#~ "we asked for writer \"account@b_domain\", "
#~ "we would get:"
#~ msgstr ""

#~ msgid "**account_id, key and writer are set**"
#~ msgstr ""

#~ msgid ""
#~ "Lastly, if all three field are "
#~ "set, result will contain details, added"
#~ " the specific writer and under the"
#~ " specific key, for example, if we "
#~ "asked for key \"age\" and writer "
#~ "\"account@a_domain\", we would get:"
#~ msgstr ""

#~ msgid "`List of Iroha permissions <../maintenance/permissions.html>`_."
#~ msgstr ""

#~ msgid ""
#~ "In the context of transactions signing,"
#~ " quorum number is a minimum amount"
#~ " of signatures required to consider a"
#~ " transaction signed. The default value "
#~ "is 1. Each account can link "
#~ "additional public keys and increase own"
#~ " quorum number."
#~ msgstr ""

#~ msgid "Signatory"
#~ msgstr ""

#~ msgid ""
#~ "Represents an entity that can confirm"
#~ " multisignature transactions for some "
#~ "`account <#account>`__. It can be "
#~ "attached to account via `AddSignatory "
#~ "<../api/commands.html#add-signatory>`__ and detached"
#~ " via `RemoveSignatory <../api/commands.html#remove-"
#~ "signatory>`__."
#~ msgstr ""

#~ msgid "Transaction Structure"
#~ msgstr ""

#~ msgid "**Payload** stores all transaction fields, except signatures:"
#~ msgstr ""

#~ msgid "Time of creation (unix time, in milliseconds)"
#~ msgstr ""

#~ msgid "Account ID of transaction creator (username@domain)"
#~ msgstr ""

#~ msgid "Quorum field (indicates required number of signatures)"
#~ msgstr ""

#~ msgid ""
#~ "Repeated commands which are described in"
#~ " details in `commands section "
#~ "<../api/commands.html>`__"
#~ msgstr ""

#~ msgid ""
#~ "Batch meta information (optional part). "
#~ "See `Batch of Transactions`_ for details"
#~ msgstr ""

#~ msgid ""
#~ "**Signatures** contain one or many "
#~ "signatures (ed25519 public key + "
#~ "signature)"
#~ msgstr ""

#~ msgid "Reduced Transaction Hash"
#~ msgstr ""

#~ msgid ""
#~ "Reduced hash is calculated over "
#~ "transaction payload excluding batch meta "
#~ "information. Used in `Batch of "
#~ "Transactions`_."
#~ msgstr ""

#~ msgid "Transaction Statuses"
#~ msgstr ""

#~ msgid ""
#~ "Hyperledger Iroha supports both push and"
#~ " pull interaction mode with a client."
#~ " A client that uses pull mode "
#~ "requests status updates about transactions "
#~ "from Iroha peer by sending transaction"
#~ " hashes and awaiting a response. In"
#~ " contrary push interaction is done "
#~ "over the listening of an event "
#~ "stream for each transaction. In any "
#~ "of these modes, the set of "
#~ "transaction statuses is the same:"
#~ msgstr ""

#~ msgid "Transaction Status Set"
#~ msgstr ""

#~ msgid "NOT_RECEIVED: requested peer does not have this transaction."
#~ msgstr ""

#~ msgid ""
#~ "MST_EXPIRED: this transactions is a part"
#~ " of MST pipeline and has expired."
#~ msgstr ""

#~ msgid ""
#~ "STATELESS_VALIDATION_FAILED: the transaction was "
#~ "formed with some fields, not meeting "
#~ "stateless validation constraints. This status"
#~ " is returned to a client, who "
#~ "formed transaction, right after the "
#~ "transaction was sent. It would also "
#~ "return the reason — what rule was"
#~ " violated."
#~ msgstr ""

#~ msgid ""
#~ "STATELESS_VALIDATION_SUCCESS: the transaction has"
#~ " successfully passed stateless validation. "
#~ "This status is returned to a "
#~ "client, who formed transaction, right "
#~ "after the transaction was sent."
#~ msgstr ""

#~ msgid ""
#~ "STATEFUL_VALIDATION_FAILED: the transaction has "
#~ "commands, which violate validation rules, "
#~ "checking state of the chain (e.g. "
#~ "asset balance, account permissions, etc.). "
#~ "It would also return the reason —"
#~ " what rule was violated."
#~ msgstr ""

#~ msgid ""
#~ "STATEFUL_VALIDATION_SUCCESS: the transaction has "
#~ "successfully passed stateful validation."
#~ msgstr ""

#~ msgid ""
#~ "COMMITTED: the transaction is the part"
#~ " of a block, which gained enough "
#~ "votes and is in the block store"
#~ " at the moment."
#~ msgstr ""

#~ msgid "Pending Transactions"
#~ msgstr ""

#~ msgid ""
#~ "Any transaction that has lesser "
#~ "signatures at the moment than `quorum`_"
#~ " of transaction creator account is "
#~ "considered as pending. Pending transaction "
#~ "will be submitted for `stateful "
#~ "validation`_ as soon as `multisignature "
#~ "<#multisignature-transactions>`__ mechanism will "
#~ "collect required amount of signatures "
#~ "for quorum."
#~ msgstr ""

#~ msgid ""
#~ "Transaction that already has quorum of"
#~ " signatures can also be considered as"
#~ " pending in cases when the "
#~ "transaction is a part of `batch of"
#~ " transactions`_ and there is a not"
#~ " fully signed transaction."
#~ msgstr ""

#~ msgid "Batch of Transactions"
#~ msgstr ""

#~ msgid "*The feature is to be released.*"
#~ msgstr ""

#~ msgid ""
#~ "Transactions batch is a feature that "
#~ "allows sending several transactions to "
#~ "Iroha at once preserving their order."
#~ msgstr ""

#~ msgid ""
#~ "Each transaction within a batch includes"
#~ " batch meta information. Batch meta "
#~ "contains batch type identifier (atomic "
#~ "or ordered) and a list of `reduced"
#~ " hashes <#reduced-transaction-hash>`_ of"
#~ " all transactions within a batch. The"
#~ " order of hashes prescribes transactions"
#~ " sequence."
#~ msgstr ""

#~ msgid ""
#~ "Batch can contain transactions created "
#~ "by different accounts. Any transaction "
#~ "within a batch can require single "
#~ "or `multiple <#multisignature-transactions>`__ "
#~ "signatures (depends on quorum set for"
#~ " an account of transaction creator). "
#~ "At least one transaction inside a "
#~ "batch should have at least one "
#~ "signature to let the batch pass "
#~ "`stateless validation`_."
#~ msgstr ""

#~ msgid "Atomic Batch"
#~ msgstr ""

#~ msgid ""
#~ "All the transactions within an atomic"
#~ " batch should pass `stateful validation`_"
#~ " for the batch to be applied to"
#~ " a ledger."
#~ msgstr ""

#~ msgid "Ordered Batch"
#~ msgstr ""

#~ msgid ""
#~ "Ordered batch preserves only the "
#~ "sequence of transactions applying to a"
#~ " ledger. All the transactions that "
#~ "able to pass stateful validation within"
#~ " a batch will be applied to a"
#~ " ledger. Validation failure of one "
#~ "transaction would NOT directly imply the"
#~ " failure of the whole batch."
#~ msgstr ""

#~ msgid "Multisignature Transactions"
#~ msgstr ""

#~ msgid ""
#~ "A transaction which has the `quorum`_"
#~ " greater than one is considered as"
#~ " multisignature (also called mst). To "
#~ "achieve `stateful validity <#stateful-"
#~ "validation>`__ the confirmation is required"
#~ " by the `signatories <#signatory>`__ of "
#~ "the creator account. These participants "
#~ "need to send the same transaction "
#~ "with their signature."
#~ msgstr ""

#~ msgid "Sections"
#~ msgstr ""

#~ msgid ""
#~ "To keep things simple, in this "
#~ "guide we will create a network "
#~ "containing only one node. To understand"
#~ " how to run several peers, follow "
#~ "`this guide. "
#~ "<github.com/hyperledger/iroha/tree/master/deploy/ansible>`_"
#~ msgstr ""

#~ msgid ""
#~ "``--depth=1`` option allows us to "
#~ "download only latest commit and save "
#~ "some time and bandwidth. If you "
#~ "want to get a full commit history,"
#~ " you can omit this option."
#~ msgstr ""

#~ msgid ""
#~ "``--entrypoint=/bin/bash \\`` Because "
#~ "``hyperledger/iroha`` has the custom script"
#~ " which runs after starting the "
#~ "container, we want to override it "
#~ "so we can start Iroha Daemon "
#~ "manually."
#~ msgstr ""

#~ msgid ""
#~ "``hyperledger/iroha:develop`` is the image "
#~ "which has the ``develop`` branch."
#~ msgstr ""

#~ msgid ""
#~ "Specifying a new genesis block using "
#~ "`--genesis_block` with blocks already present"
#~ " in ledger requires `--overwrite_ledger` "
#~ "flag to be set. The daemon will"
#~ " fail otherwise."
#~ msgstr ""

#~ msgid "Fund Management"
#~ msgstr ""

#~ msgid ""
#~ "With the support of multisignature "
#~ "transactions it is possible to maintain"
#~ " a fund by many managers. In "
#~ "that scheme investment can only be "
#~ "made after the confirmation of the "
#~ "quorum participants."
#~ msgstr ""

#~ msgid ""
#~ "The fund assets should be held at"
#~ " one account. Its signatories should "
#~ "be fund managers, who are dealing "
#~ "with investments and portfolio distributions."
#~ " That can be added via "
#~ "``AddSignatory`` command. All of the "
#~ "assets should be held within one "
#~ "account, which signatories represent the "
#~ "fund managers. Thus the concrete "
#~ "exchanges can be performed with the "
#~ "multisignature transaction so that everyone"
#~ " will decide on a particular "
#~ "financial decision. The one may confirm"
#~ " a deal by sending the original "
#~ "transaction and one of managers' "
#~ "signature. Iroha will maintain the "
#~ "transaction sending so that the deal "
#~ "will not be completed until it "
#~ "receives the required number of "
#~ "confirmation, which is parametrized with "
#~ "the transaction quorum parameter."
#~ msgstr ""

#~ msgid ""
#~ "``mst_enable`` enables or disables "
#~ "multisignature transaction support in Iroha."
#~ " We recommend setting this parameter "
#~ "to ``false`` at the moment until "
#~ "you really need it."
#~ msgstr ""

#~ msgid ""
#~ "1. The script checks if you don't"
#~ " have containers with Iroha already "
#~ "running. Successful completion finishes with"
#~ " the new container shell. 2. The "
#~ "script will download ``hyperledger/iroha:develop-"
#~ "build`` and ``postgres`` images. "
#~ "``hyperledger/iroha:develop-build`` image contains"
#~ " all development dependencies and is "
#~ "based on top of ``ubuntu:16.04``. "
#~ "``postgres`` image is required for "
#~ "starting and running Iroha. 3. Two "
#~ "containers are created and launched. 4."
#~ " The user is attached to the "
#~ "interactive environment for development and"
#~ " testing with ``iroha`` folder mounted "
#~ "from the host machine. Iroha folder "
#~ "is mounted to ``/opt/iroha`` in Docker"
#~ " container."
#~ msgstr ""

#~ msgid ""
#~ "Iroha requires Boost of at least "
#~ "1.65 version. To install Boost libraries"
#~ " (``libboost-all-dev``), use `current "
#~ "release <http://www.boost.org/users/download/>`_ from "
#~ "Boost webpage. The only dependencies are"
#~ " thread, system and filesystem, so "
#~ "use ``./bootstrap.sh --with-"
#~ "libraries=thread,system,filesystem`` when you are"
#~ " building the project."
#~ msgstr ""

#~ msgid ""
#~ "Minimum required version is 3.11.4, but"
#~ " we recommend to install the latest"
#~ " available version (3.12.0 at the "
#~ "moment)."
#~ msgstr ""

#~ msgid "Entity-relationship model"
#~ msgstr ""

#~ msgid ""
#~ "Each Hyperledger Iroha peer has a "
#~ "state, called \"World State View\", "
#~ "which is represented by a set of"
#~ " entities and relations between them. "
#~ "To explain you more which entities "
#~ "exist in the system and what are"
#~ " the relations, this sections includes "
#~ "ER diagram and an explanation of "
#~ "its components."
#~ msgstr ""

#~ msgid "ER diagram"
#~ msgstr ""

#~ msgid ""
#~ "address — network address and internal"
#~ " port, is used for synchronization, "
#~ "consensus, and communication with the "
#~ "ordering service"
#~ msgstr ""

#~ msgid ""
#~ "public_key — key, which will be "
#~ "used for signing blocks during consensus"
#~ " process"
#~ msgstr ""

#~ msgid "asset_id — identifier of asset, formatted as asset_name#domain_id"
#~ msgstr ""

#~ msgid ""
#~ "domain_id — identifier of domain, where"
#~ " the asset was created, references "
#~ "existing domain"
#~ msgstr ""

#~ msgid "precision — size of fractional part"
#~ msgstr ""

#~ msgid "data — JSON with arbitrary structure of asset description"
#~ msgstr ""

#~ msgid "public_key — a public key"
#~ msgstr ""

#~ msgid "domain_id — identifier of a domain"
#~ msgstr ""

#~ msgid ""
#~ "default_role — a default role per "
#~ "user created in the domain, references"
#~ " existing role"
#~ msgstr ""

#~ msgid "role_id — identifier of role"
#~ msgstr ""

#~ msgid "RoleHasPermissions"
#~ msgstr ""

#~ msgid "role_id — identifier of role, references existing role"
#~ msgstr ""

#~ msgid "permission_id — an id of predefined role"
#~ msgstr ""

#~ msgid "account_id — identifier of account, formatted as account_name@domain_id"
#~ msgstr ""

#~ msgid ""
#~ "domain_id — identifier of domain where"
#~ " the account was created, references "
#~ "existing domain"
#~ msgstr ""

#~ msgid ""
#~ "quorum — number of signatories required"
#~ " for creation of valid transaction "
#~ "from this account"
#~ msgstr ""

#~ msgid "transaction_count – counter of transactions created by this account"
#~ msgstr ""

#~ msgid "data — key-value storage for any information, related to the account"
#~ msgstr ""

#~ msgid "AccountHasSignatory"
#~ msgstr ""

#~ msgid "account_id — identifier of account, references existing account"
#~ msgstr ""

#~ msgid ""
#~ "public_key — a public key (which "
#~ "is also called signatory), references "
#~ "existing signatory"
#~ msgstr ""

#~ msgid "AccountHasAsset"
#~ msgstr ""

#~ msgid "asset_id — identifier of asset, references existing asset"
#~ msgstr ""

#~ msgid "amount — an amount of the asset, belonging to the account"
#~ msgstr ""

#~ msgid "AccountHasRoles"
#~ msgstr ""

#~ msgid "AccountHasGrantablePermissions"
#~ msgstr ""

#~ msgid ""
#~ "account_id — identifier of account, "
#~ "references existing account. This account "
#~ "gives grantable permission to perform "
#~ "operation over itself to permittee."
#~ msgstr ""

#~ msgid ""
#~ "permittee_account_id — identifier of account,"
#~ " references existing account. This account"
#~ " is given permission to perform "
#~ "operation over account_id."
#~ msgstr ""

#~ msgid "permission_id — identifier of grantable_permission"
#~ msgstr ""

#~ msgid "Deploying Iroha on Kubernetes cluster"
#~ msgstr ""

#~ msgid ""
#~ "By following this guide you will "
#~ "be able to deploy a Kubernetes "
#~ "cluster from scratch on AWS cloud "
#~ "using Terraform and Kubespray, and "
#~ "deploy a network of Iroha nodes on"
#~ " it."
#~ msgstr ""

#~ msgid "machine running Linux (tested on Ubuntu 16.04) or MacOS"
#~ msgstr ""

#~ msgid "Python 3.3+"
#~ msgstr ""

#~ msgid "boto3"
#~ msgstr ""

#~ msgid "Ansible 2.4+"
#~ msgstr ""

#~ msgid ""
#~ "*ed25519-cli* utility for key generation. "
#~ "Statically linked binary (for x86_64 "
#~ "platform) can be found in "
#~ "deploy/ansible/playbooks/iroha-k8s/scripts directory. "
#~ "You may need to `compile it "
#~ "yourself <https://github.com/Warchant/ed25519-cli>`__."
#~ msgstr ""

#~ msgid ""
#~ "You do not need the items below"
#~ " if you already have a working "
#~ "Kubernetes (k8s) cluster. You can skip"
#~ " to `Generating Iroha configs`_ chapter."
#~ msgstr ""

#~ msgid "Terraform 0.11.8+"
#~ msgstr ""

#~ msgid "AWS account for deploying a k8s cluster on EC2"
#~ msgstr ""

#~ msgid "Preparation"
#~ msgstr ""

#~ msgid ""
#~ "You need to obtain AWS key for "
#~ "managing resources. We recommend to "
#~ "create a separate IAM user for "
#~ "that. Go to your AWS console, head"
#~ " to \"My Security Credentials\" menu "
#~ "and create a user in \"Users\" "
#~ "section. Assign \"AmazonEC2FullAccess\" and "
#~ "\"AmazonVPCFullAccess\" policies to that user."
#~ " Click \"Create access key\" on "
#~ "Security credentials tab. Take a note"
#~ " for values of Access key ID "
#~ "and Secret key. Set these values "
#~ "as environment variables in your "
#~ "console:"
#~ msgstr ""

#~ msgid "Checkout the source tree from Github:"
#~ msgstr ""

#~ msgid "Setting up cloud infrastructure"
#~ msgstr ""

#~ msgid ""
#~ "We use Hashicorp's Terraform infrastructure"
#~ " management tool for automated deployment"
#~ " of AWS EC2 nodes in multiple "
#~ "regions. `Kubespray <https://github.com/kubernetes-"
#~ "incubator/kubespray>`__ Ansible module is used"
#~ " for setting up a production-grade"
#~ " k8s cluster."
#~ msgstr ""

#~ msgid ""
#~ "Terraform module creates 3 AWS instances"
#~ " in 3 different regions: eu-west-1,"
#~ " eu-west-2, eu-west-3 by default. "
#~ "Instance type is *c5.large*. There is"
#~ " a separate VPC created in every "
#~ "region. All created VPCs are then "
#~ "connected using VPC peering connection. "
#~ "That is to create a seamless "
#~ "network for k8s cluster."
#~ msgstr ""

#~ msgid ""
#~ "There are several configurable options: "
#~ "number of nodes in each region and"
#~ " its role in k8s cluster (kube-"
#~ "master or kube-node). They can be"
#~ " set either in *variables.tf* file or"
#~ " via environment variables (using the "
#~ "same variable name but prefixed with "
#~ "TF_VAR. See more in `Terraform docs "
#~ "<https://www.terraform.io/intro/getting-started/variables.html"
#~ "#from-environment-variables>`__). More options"
#~ " can be configured by tuning "
#~ "parameters in module's *variables.tf* file."
#~ msgstr ""

#~ msgid ""
#~ "You must set up SSH key in "
#~ "*deploy/tf/k8s/variables.tf* as well. Replace "
#~ "public key with your own. It will"
#~ " added on each created EC2 instance."
#~ msgstr ""

#~ msgid ""
#~ "Navigate to *deploy/tf/k8s* directory. "
#~ "Terraform needs to download required "
#~ "modules first:"
#~ msgstr ""

#~ msgid "Then run module execution:"
#~ msgstr ""

#~ msgid ""
#~ "Review the execution plan and type "
#~ "*yes* to approve. Upon completion you"
#~ " should see an output similar to "
#~ "this:"
#~ msgstr ""

#~ msgid ""
#~ "We are now ready to deploy k8s "
#~ "cluster. Wait a couple of minutes "
#~ "before instances are initialized."
#~ msgstr ""

#~ msgid "Setting up k8s cluster"
#~ msgstr ""

#~ msgid ""
#~ "There is an Ansible role for "
#~ "setting up k8s cluster. It is an"
#~ " external module called Kubespray. It "
#~ "is stored as a submodule in "
#~ "Hyperledger Iroha repository. This means "
#~ "it needs to be initialized first:"
#~ msgstr ""

#~ msgid "This command will download Kubespray from master repository."
#~ msgstr ""

#~ msgid "Install required dependencies:"
#~ msgstr ""

#~ msgid ""
#~ "Proceed to actual cluster deployment. "
#~ "Make sure you replaced *key-file* "
#~ "parameter with an actual path to "
#~ "SSH private key that was used "
#~ "previously during Terraform configuration. "
#~ "*REGIONS* variable corresponds to default "
#~ "list of regions used on a previous"
#~ " step. Modify it accordingly in case"
#~ " you added or removed any. Inventory"
#~ " file is a Python script that "
#~ "returns Ansible-compatible list of hosts"
#~ " filtered by tag."
#~ msgstr ""

#~ msgid "Upon successful completion you will have working k8s cluster."
#~ msgstr ""

#~ msgid "Generating Iroha configs"
#~ msgstr ""

#~ msgid ""
#~ "In order for Iroha to work "
#~ "properly it requires to generate a "
#~ "key pair for each node, genesis "
#~ "block and configuration file. This is"
#~ " usually a tedious and error-prone"
#~ " procedure, especially for a large "
#~ "number of nodes. We automated it "
#~ "with Ansible role. You can skip to"
#~ " `Deploying Iroha on the cluster`_ "
#~ "chapter if you want to quick start"
#~ " using default configs for k8s "
#~ "cluster with 4 Iroha replicas."
#~ msgstr ""

#~ msgid ""
#~ "Generate configuration files for *N* "
#~ "Iroha nodes. *replicas* variable controls "
#~ "the number of *N*:"
#~ msgstr ""

#~ msgid ""
#~ "You should find files created in "
#~ "*deploy/ansible/roles/iroha-k8s/files/conf*."
#~ msgstr ""

#~ msgid "Deploying Iroha on the cluster"
#~ msgstr ""

#~ msgid ""
#~ "Make sure you have configuration files"
#~ " in *deploy/ansible/roles/iroha-k8s/files*. "
#~ "Specifically, non-empty *conf* directory "
#~ "and *k8s-iroha.yaml* file."
#~ msgstr ""

#~ msgid ""
#~ "There are two options for managing "
#~ "k8s cluster: logging into either of "
#~ "master node and executing commands there"
#~ " or configure remote management. We "
#~ "will cover the second option here "
#~ "as the first one is trivial."
#~ msgstr ""

#~ msgid ""
#~ "In case you set up cluster using"
#~ " Kubespray, you can find *admin.conf* "
#~ "file on either of master node in"
#~ " */etc/kubernetes* directory. Copy this "
#~ "file on the control machine (the "
#~ "one you will be running *kubectl* "
#~ "command from). Make sure *server* "
#~ "parameter in this file points to "
#~ "external IP address or DNS name of"
#~ " a master node. Usually, there is "
#~ "a private IP address of the node"
#~ " (in case of AWS). Make sure "
#~ "*kubectl* utility is installed (`check "
#~ "out the docs <https://kubernetes.io/docs/tasks/tools"
#~ "/install-kubectl/>`__ for instructions)."
#~ msgstr ""

#~ msgid "Replace the default *kubectl* configuration:"
#~ msgstr ""

#~ msgid "We can now control the remote k8s cluster"
#~ msgstr ""

#~ msgid ""
#~ "*k8s-iroha.yaml* pod specification file "
#~ "requires the creation of a *config-"
#~ "map* first. This is a special "
#~ "resource that is mounted in the "
#~ "init container of each pod, and "
#~ "contains the configuration and genesis "
#~ "block files required to run Iroha."
#~ msgstr ""

#~ msgid ""
#~ "Each peer will have their public "
#~ "and private keys stored in a "
#~ "Kubernetes secret which is  mounted in"
#~ " the init container and copied over"
#~ " for Iroha to use. Peers will "
#~ "only be able read their assigned "
#~ "secret when running Iroha."
#~ msgstr ""

#~ msgid "Deploy Iroha network pod specification:"
#~ msgstr ""

#~ msgid ""
#~ "Wait a moment before each node "
#~ "downloads and starts Docker containers. "
#~ "Executing *kubectl get pods* command "
#~ "should eventually return a list of "
#~ "deployed pods each in *Running* state."
#~ msgstr ""

#~ msgid ""
#~ "Pods do not expose ports externally. "
#~ "You need to connect to Iroha "
#~ "instance by its hostname (iroha-0, "
#~ "iroha-1, etc). For that you have "
#~ "to have a running pod in the "
#~ "same network."
#~ msgstr ""

#~ msgid ""
#~ "Hyperledger Iroha uses a role-based "
#~ "access control system to limit actions"
#~ " of its users. This system greatly"
#~ " helps to implement use cases "
#~ "involving user groups having different "
#~ "access levels — ranging from the "
#~ "weak users, who can't even receive "
#~ "asset transfer to the super-users. "
#~ "The beauty of our permission system "
#~ "is that you don't have to have "
#~ "a super-user in your Iroha setup"
#~ " or use all the possible permissions:"
#~ " you can create segregated and "
#~ "lightweight roles."
#~ msgstr ""

#~ msgid ""
#~ "Maintenance of the system involves "
#~ "setting up roles and permissions, that"
#~ " are included in the roles. This "
#~ "might be done at the initial step"
#~ " of system deployment — in genesis"
#~ " block, or later when Iroha network"
#~ " is up and running, roles can "
#~ "be changed (if there is a role "
#~ "that can do that :)"
#~ msgstr ""

#~ msgid ""
#~ "This section will help you to "
#~ "understand permissions and give you an"
#~ " idea of how to create roles "
#~ "including certain permissions. Each permission"
#~ " is provided with an example written"
#~ " in Python that demonstrates the way"
#~ " of transaction or query creation, "
#~ "which require specific permission. Every "
#~ "example uses *commons.py* module, which "
#~ "listing is available at `Supplementary "
#~ "Sources`_ section."
#~ msgstr ""

#~ msgid "List of Permissions"
#~ msgstr ""

#~ msgid "Permission Name"
#~ msgstr ""

#~ msgid "Category"
#~ msgstr ""

#~ msgid "Type"
#~ msgstr ""

#~ msgid "`can_create_account`_"
#~ msgstr ""

#~ msgid "`can_set_detail`_"
#~ msgstr ""

#~ msgid "`can_set_my_account_detail`_ ``grantable``"
#~ msgstr ""

#~ msgid "`can_create_asset`_"
#~ msgstr ""

#~ msgid "`can_receive`_"
#~ msgstr ""

#~ msgid "`can_transfer`_"
#~ msgstr ""

#~ msgid "`can_transfer_my_assets`_ ``grantable``"
#~ msgstr ""

#~ msgid "`can_add_asset_qty`_"
#~ msgstr ""

#~ msgid "Asset Quantity"
#~ msgstr ""

#~ msgid "`can_subtract_asset_qty`_"
#~ msgstr ""

#~ msgid "`can_add_domain_asset_qty`_"
#~ msgstr ""

#~ msgid "`can_subtract_domain_asset_qty`_"
#~ msgstr ""

#~ msgid "`can_create_domain`_"
#~ msgstr ""

#~ msgid "`can_grant_can_add_my_signatory`_"
#~ msgstr ""

#~ msgid "Grant"
#~ msgstr ""

#~ msgid "`can_grant_can_remove_my_signatory`_"
#~ msgstr ""

#~ msgid "`can_grant_can_set_my_account_detail`_"
#~ msgstr ""

#~ msgid "`can_grant_can_set_my_quorum`_"
#~ msgstr ""

#~ msgid "`can_grant_can_transfer_my_assets`_"
#~ msgstr ""

#~ msgid "`can_add_peer`_"
#~ msgstr ""

#~ msgid "`can_append_role`_"
#~ msgstr ""

#~ msgid "`can_create_role`_"
#~ msgstr ""

#~ msgid "`can_detach_role`_"
#~ msgstr ""

#~ msgid "`can_add_my_signatory`_ ``grantable``"
#~ msgstr ""

#~ msgid "`can_add_signatory`_"
#~ msgstr ""

#~ msgid "`can_remove_my_signatory`_ ``grantable``"
#~ msgstr ""

#~ msgid "`can_remove_signatory`_"
#~ msgstr ""

#~ msgid "`can_set_my_quorum`_ ``grantable``"
#~ msgstr ""

#~ msgid "`can_set_quorum`_"
#~ msgstr ""

#~ msgid "`can_get_all_acc_detail`_"
#~ msgstr ""

#~ msgid "`can_get_all_accounts`_"
#~ msgstr ""

#~ msgid "`can_get_domain_acc_detail`_"
#~ msgstr ""

#~ msgid "`can_get_domain_accounts`_"
#~ msgstr ""

#~ msgid "`can_get_my_acc_detail`_"
#~ msgstr ""

#~ msgid "`can_get_my_account`_"
#~ msgstr ""

#~ msgid "`can_get_all_acc_ast`_"
#~ msgstr ""

#~ msgid "Account Asset"
#~ msgstr ""

#~ msgid "`can_get_domain_acc_ast`_"
#~ msgstr ""

#~ msgid "`can_get_my_acc_ast`_"
#~ msgstr ""

#~ msgid "`can_get_all_acc_ast_txs`_"
#~ msgstr ""

#~ msgid "Account Asset Transaction"
#~ msgstr ""

#~ msgid "`can_get_domain_acc_ast_txs`_"
#~ msgstr ""

#~ msgid "`can_get_my_acc_ast_txs`_"
#~ msgstr ""

#~ msgid "`can_get_all_acc_txs`_"
#~ msgstr ""

#~ msgid "Account Transaction"
#~ msgstr ""

#~ msgid "`can_get_domain_acc_txs`_"
#~ msgstr ""

#~ msgid "`can_get_my_acc_txs`_"
#~ msgstr ""

#~ msgid "`can_read_assets`_"
#~ msgstr ""

#~ msgid "`can_get_blocks`_"
#~ msgstr ""

#~ msgid "Block Stream"
#~ msgstr ""

#~ msgid "`can_get_roles`_"
#~ msgstr ""

#~ msgid "`can_get_all_signatories`_"
#~ msgstr ""

#~ msgid "`can_get_domain_signatories`_"
#~ msgstr ""

#~ msgid "`can_get_my_signatories`_"
#~ msgstr ""

#~ msgid "`can_get_all_txs`_"
#~ msgstr ""

#~ msgid "`can_get_my_txs`_"
#~ msgstr ""

#~ msgid "Command-related permissions"
#~ msgstr ""

#~ msgid "can_create_account"
#~ msgstr ""

#~ msgid ""
#~ "Allows creating new `accounts "
#~ "<../core_concepts/glossary.html#account>`__."
#~ msgstr ""

#~ msgid ""
#~ "Related API method: `Create Account "
#~ "<../api/commands.html#create-account>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kCreateAccount``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kCreateAccount``"
#~ msgstr ""

#~ msgid "**Example**"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain \"test\" that "
#~ "contains only can_create_account permission "
#~ "and Alice account in that domain. "
#~ "Alice can create Bob account."
#~ msgstr ""

#~ msgid "can_set_detail"
#~ msgstr ""

#~ msgid ""
#~ "Allows setting `account "
#~ "<../core_concepts/glossary.html#account>`__ detail."
#~ msgstr ""

#~ msgid ""
#~ "The `permission "
#~ "<../core_concepts/glossary.html#permission>`__ allows "
#~ "setting details to other accounts. "
#~ "Another way to set detail without "
#~ "can_set_detail permission is to grant "
#~ "`can_set_my_account_detail`_ permission to someone."
#~ " In order to grant, `transaction "
#~ "<../core_concepts/glossary.html#transaction>`__ creator "
#~ "should have `can_grant_can_set_my_account_detail`_ "
#~ "permission."
#~ msgstr ""

#~ msgid ""
#~ "Transaction creator can always set "
#~ "detail for own account even without "
#~ "that permission."
#~ msgstr ""

#~ msgid ""
#~ "Related API method: `Set Account Detail"
#~ " <../api/commands.html#set-account-detail>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kSetDetail``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kSetDetail``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain \"test\" that "
#~ "contains only can_set_detail permission and"
#~ " Alice account in that domain. Alice"
#~ " can set detail for Admin account."
#~ msgstr ""

#~ msgid "can_set_my_account_detail"
#~ msgstr ""

#~ msgid "This is a grantable permission."
#~ msgstr ""

#~ msgid ""
#~ "`Permission <../core_concepts/glossary.html#permission>`__ "
#~ "that allows a specified `account "
#~ "<../core_concepts/glossary.html#account>`__ to set "
#~ "details for the another specified "
#~ "account."
#~ msgstr ""

#~ msgid ""
#~ "To grant the permission an account "
#~ "should already have a role with "
#~ "`can_grant_can_set_my_account_detail`_ permission."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Grantable.kSetMyAccountDetail``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Grantable_kSetMyAccountDetail``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain \"test\" that "
#~ "contains only can_grant_can_set_my_account_detail "
#~ "permission and two accounts for Alice"
#~ " and Bob in that domain. Alice "
#~ "grants to Bob can_set_my_account_detail "
#~ "permission. Bob can set detail for "
#~ "Alice account."
#~ msgstr ""

#~ msgid "can_create_asset"
#~ msgstr ""

#~ msgid "Allows creating new `assets <../core_concepts/glossary.html#asset>`__."
#~ msgstr ""

#~ msgid ""
#~ "Related API method: `Create Asset "
#~ "<../api/commands.html#create-asset>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kCreateAsset``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kCreateAsset``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain \"test\" that "
#~ "contains only can_create_asset permission and"
#~ " Alice account in that domain. Alice"
#~ " can create new assets."
#~ msgstr ""

#~ msgid "can_receive"
#~ msgstr ""

#~ msgid ""
#~ "Allows `account "
#~ "<../core_concepts/glossary.html#account>`__ receive "
#~ "`assets <../core_concepts/glossary.html#asset>`__."
#~ msgstr ""

#~ msgid ""
#~ "Related API method: `Transfer Asset "
#~ "<../api/commands.html#transfer-asset>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kReceive``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kReceive``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain \"test\" that "
#~ "contains can_receive and can_transfer "
#~ "permissions and two accounts for Alice"
#~ " and Bob. Admin creates \"coin\" "
#~ "asset, adds some quantity of it "
#~ "and transfers the asset to Alice. "
#~ "Alice can transfer assets to Bob "
#~ "(Alice has can_transfer permission and "
#~ "Bob has can_receive permission)."
#~ msgstr ""

#~ msgid "can_transfer"
#~ msgstr ""

#~ msgid ""
#~ "Allows sending `assets "
#~ "<../core_concepts/glossary.html#asset>`__ from an "
#~ "`account <../core_concepts/glossary.html#account>`__ of"
#~ " `transaction <../core_concepts/glossary.html#transaction>`__"
#~ " creator."
#~ msgstr ""

#~ msgid ""
#~ "You can transfer an asset from one"
#~ " `domain <../core_concepts/glossary.html#domain>`__ to"
#~ " another, even if the other domain"
#~ " does not have an asset with "
#~ "the same name."
#~ msgstr ""

#~ msgid "Destination account should have `can_receive`_ permission."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kTransfer``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kTransfer``"
#~ msgstr ""

#~ msgid "can_transfer_my_assets"
#~ msgstr ""

#~ msgid ""
#~ "`Permission <../core_concepts/glossary.html#permission>`__ "
#~ "that allows a specified `account "
#~ "<../core_concepts/glossary.html#account>`__ to transfer"
#~ " `assets <../core_concepts/glossary.html#asset>`__ of"
#~ " another specified account."
#~ msgstr ""

#~ msgid "See the example (to be done) for the usage details."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Grantable.kTransferMyAssets``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Grantable_kTransferMyAssets``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain \"test\" that "
#~ "contains can_grant_can_transfer_my_assets, can_receive,"
#~ " can_transfer permissions and two accounts"
#~ " for Alice and Bob in that "
#~ "domain. Admin issues some amount of "
#~ "\"coin\" asset and transfers it to "
#~ "Alice. Alice grants to Bob "
#~ "can_transfer_my_assets permission. Bob can "
#~ "transfer Alice's assets to any account"
#~ " that has can_receive permission, for "
#~ "example, to Admin."
#~ msgstr ""

#~ msgid "can_add_asset_qty"
#~ msgstr ""

#~ msgid "Allows issuing `assets <../core_concepts/glossary.html#asset>`__."
#~ msgstr ""

#~ msgid ""
#~ "The corresponding `command "
#~ "<../core_concepts/glossary.html#command>`__ can be "
#~ "executed only for an `account "
#~ "<../core_concepts/glossary.html#account>`__ of "
#~ "`transaction <../core_concepts/glossary.html#transaction>`__ "
#~ "creator and only if that account "
#~ "has a `role <../core_concepts/glossary.html#role>`__"
#~ " with the `permission "
#~ "<../core_concepts/glossary.html#permission>`__."
#~ msgstr ""

#~ msgid ""
#~ "Related API method: `Add Asset Quantity"
#~ " <../api/commands.html#add-asset-quantity>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kAddAssetQty``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kAddAssetQty``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain \"test\" that "
#~ "contains only can_add_asset_qty permission and"
#~ " Alice account in that domain. Admin"
#~ " craetes \"coin\" asset. Alice can "
#~ "add to own account any amount of"
#~ " any asset (e.g. \"coin\" asset)."
#~ msgstr ""

#~ msgid "can_subtract_asset_qty"
#~ msgstr ""

#~ msgid "Allows burning `assets <../core_concepts/glossary.html#asset>`__."
#~ msgstr ""

#~ msgid ""
#~ "Related API method: `Subtract Asset "
#~ "Quantity <../api/commands.html#subtract-asset-"
#~ "quantity>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kSubtractAssetQty``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kSubtractAssetQty``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain \"test\" that "
#~ "contains only can_subtract_asset_qty permission "
#~ "and Alice account in that domain. "
#~ "Admin issues some amount of \"coin\" "
#~ "asset and transfers some amount of "
#~ "\"coin\" asset to Alice. Alice can "
#~ "burn any amount of \"coin\" assets."
#~ msgstr ""

#~ msgid "can_add_domain_asset_qty"
#~ msgstr ""

#~ msgid ""
#~ "Allows issuing `assets "
#~ "<../core_concepts/glossary.html#asset>`__ only in "
#~ "own `domain <../core_concepts/glossary.html#domain>`__."
#~ msgstr ""

#~ msgid ""
#~ "The corresponding `command "
#~ "<../core_concepts/glossary.html#command>`__ can be "
#~ "executed only for an `account "
#~ "<../core_concepts/glossary.html#account>`__ of "
#~ "`transaction <../core_concepts/glossary.html#transaction>`__ "
#~ "creator and only if that account "
#~ "has a `role <../core_concepts/glossary.html#role>`__"
#~ " with the `permission "
#~ "<../core_concepts/glossary.html#permission>`__ and only"
#~ " for assets in creator’s domain."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kAddDomainAssetQty``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kAddDomainAssetQty``"
#~ msgstr ""

#~ msgid "can_subtract_domain_asset_qty"
#~ msgstr ""

#~ msgid ""
#~ "Allows burning `assets "
#~ "<../core_concepts/glossary.html#asset>`__ only in "
#~ "own `domain <../core_concepts/glossary.html#domain>`__."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kSubtractDomainAssetQty``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kSubtractDomainAssetQty``"
#~ msgstr ""

#~ msgid "can_create_domain"
#~ msgstr ""

#~ msgid ""
#~ "Allows creating new `domains "
#~ "<../core_concepts/glossary.html#domain>`__ within the "
#~ "system."
#~ msgstr ""

#~ msgid ""
#~ "Related API method: `Create Domain "
#~ "<../api/commands.html#create-domain>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kCreateDomain``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kCreateDomain``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain that contains only"
#~ " can_create_domain permission and Alice "
#~ "account in that domain. Alice can "
#~ "create new domains."
#~ msgstr ""

#~ msgid "can_grant_can_add_my_signatory"
#~ msgstr ""

#~ msgid ""
#~ "Allows `role <../core_concepts/glossary.html#role>`__ "
#~ "owners grant `can_add_my_signatory`_ `permission "
#~ "<../core_concepts/glossary.html#permission>`__."
#~ msgstr ""

#~ msgid ""
#~ "Related API methods: `Grant Permission "
#~ "<../api/commands.html#grant-permission>`__, `Revoke "
#~ "Permission <../api/commands.html#revoke-permission>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kAddMySignatory``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kAddMySignatory``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain that contains only"
#~ " can_grant_can_add_my_signatory permission and "
#~ "two accounts for Alice and Bob in"
#~ " that domain. Alice can grant to "
#~ "Bob and revoke can_add_my_signatory "
#~ "permission."
#~ msgstr ""

#~ msgid "can_grant_can_remove_my_signatory"
#~ msgstr ""

#~ msgid ""
#~ "Allows `role <../core_concepts/glossary.html#role>`__ "
#~ "owners grant `can_remove_my_signatory`_ `permission"
#~ " <../core_concepts/glossary.html#permission>`__."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kRemoveMySignatory``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kRemoveMySignatory``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain that contains only"
#~ " can_grant_can_remove_my_signatory permission and "
#~ "two accounts for Alice and Bob in"
#~ " that domain. Alice can grant to "
#~ "Bob and revoke can_remove_my_signatory "
#~ "permission."
#~ msgstr ""

#~ msgid "can_grant_can_set_my_account_detail"
#~ msgstr ""

#~ msgid ""
#~ "Allows `role <../core_concepts/glossary.html#role>`__ "
#~ "owners grant `can_set_my_account_detail`_ "
#~ "`permission <../core_concepts/glossary.html#permission>`__."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kSetMyAccountDetail``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kSetMyAccountDetail``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain that contains only"
#~ " can_grant_can_set_my_account_detail permission and "
#~ "two accounts for Alice and Bob in"
#~ " that domain. Alice can grant to "
#~ "Bob and revoke can_set_my_account_detail "
#~ "permission."
#~ msgstr ""

#~ msgid "can_grant_can_set_my_quorum"
#~ msgstr ""

#~ msgid ""
#~ "Allows `role <../core_concepts/glossary.html#role>`__ "
#~ "owners grant `can_set_my_quorum`_ `permission "
#~ "<../core_concepts/glossary.html#permission>`__."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kSetMyQuorum``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kSetMyQuorum``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain that contains only"
#~ " can_grant_can_set_my_quorum permission and two"
#~ " accounts for Alice and Bob in "
#~ "that domain. Alice can grant to "
#~ "Bob and revoke can_set_my_quorum permission."
#~ msgstr ""

#~ msgid "can_grant_can_transfer_my_assets"
#~ msgstr ""

#~ msgid ""
#~ "Allows `role <../core_concepts/glossary.html#role>`__ "
#~ "owners grant `can_transfer_my_assets`_ `permission"
#~ " <../core_concepts/glossary.html#permission>`__."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kTransferMyAssets``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kTransferMyAssets``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain that contains only"
#~ " can_grant_can_transfer_my_assets permission and "
#~ "two accounts for Alice and Bob in"
#~ " that domain. Alice can grant to "
#~ "Bob and revoke can_transfer_my_assets "
#~ "permission."
#~ msgstr ""

#~ msgid "can_add_peer"
#~ msgstr ""

#~ msgid ""
#~ "Allows adding `peers "
#~ "<../core_concepts/glossary.html#peer>`__ to the "
#~ "network."
#~ msgstr ""

#~ msgid ""
#~ "A new peer will be a valid "
#~ "participant in the next `consensus "
#~ "<../core_concepts/glossary.html#consensus>`__ round after"
#~ " an agreement on `transaction "
#~ "<../core_concepts/glossary.html#transaction>`__ containing "
#~ "\"addPeer\" `command "
#~ "<../core_concepts/glossary.html#command>`__."
#~ msgstr ""

#~ msgid "Related API method: `Add Peer <../api/commands.html#add-peer>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kAddPeer``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kAddPeer``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain that contains only"
#~ " can_add_peer permission and Alice account"
#~ " in that domain. Alice can add "
#~ "new peers."
#~ msgstr ""

#~ msgid "can_append_role"
#~ msgstr ""

#~ msgid ""
#~ "Allows appending `roles "
#~ "<../core_concepts/glossary.html#role>`__ to another "
#~ "`account <../core_concepts/glossary.html#account>`__."
#~ msgstr ""

#~ msgid ""
#~ "You can append only that role that"
#~ " has lesser or the same set of"
#~ " privileges as `transaction "
#~ "<../core_concepts/glossary.html#transaction>`__ creator."
#~ msgstr ""

#~ msgid "Related API method: `Append Role <../api/commands.html#append-role>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kAppendRole``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kAppendRole``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domian that contains "
#~ "can_append_role and can_add_peer permissions "
#~ "and two accounts for Alice and Bob"
#~ " in that domain. Admin creates the"
#~ " second role that contains only "
#~ "can_add_peer permission. Alice can append "
#~ "role to Bob."
#~ msgstr ""

#~ msgid "can_create_role"
#~ msgstr ""

#~ msgid ""
#~ "Allows creating a new `role "
#~ "<../core_concepts/glossary.html#role>`__ within a "
#~ "system."
#~ msgstr ""

#~ msgid ""
#~ "Possible set of `permissions "
#~ "<../core_concepts/glossary.html#permission>`__ for a "
#~ "new role is limited to those "
#~ "permissions that `transaction "
#~ "<../core_concepts/glossary.html#transaction>`__ creator "
#~ "has."
#~ msgstr ""

#~ msgid "Related API method: `Create Role <../api/commands.html#create-role>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kCreateRole``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kCreateRole``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain that contains only"
#~ " can_create_role permission and Alice "
#~ "account in that domain. Alice can "
#~ "create new roles."
#~ msgstr ""

#~ msgid "can_detach_role"
#~ msgstr ""

#~ msgid ""
#~ "Allows revoking a `role "
#~ "<../core_concepts/glossary.html#role>`__ from a "
#~ "user."
#~ msgstr ""

#~ msgid ""
#~ "Due to a known issue the "
#~ "permission allows to detach any role "
#~ "without limitations "
#~ "https://soramitsu.atlassian.net/browse/IR-1468"
#~ msgstr ""

#~ msgid "Related API method: `Detach Role <../api/commands.html#detach-role>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kDetachRole``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kDetachRole``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain that contains only"
#~ " can_detach_role permission and creates "
#~ "Alice account in that domain. Admin "
#~ "has two roles test_role and admin_role."
#~ " Alice can detach test_role from "
#~ "Admin account."
#~ msgstr ""

#~ msgid "can_add_my_signatory"
#~ msgstr ""

#~ msgid ""
#~ "`Permission <../core_concepts/glossary.html#permission>`__ "
#~ "that allows a specified `account "
#~ "<../core_concepts/glossary.html#account>`__ to add "
#~ "an extra public key to the another"
#~ " specified account."
#~ msgstr ""

#~ msgid ""
#~ "Related API method: `Add Signatory "
#~ "<../api/commands.html#add-signatory>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Grantable.kAddMySignatory``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Grantable_kAddMySignatory``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain that contains only"
#~ " can_grant_can_add_my_signatory permission and "
#~ "two accounts for Alice and Bob in"
#~ " that domain. Alice can grant to "
#~ "Bob can_add_my_signatory permission. Bob can"
#~ " add an extra key to Alice "
#~ "account."
#~ msgstr ""

#~ msgid "can_add_signatory"
#~ msgstr ""

#~ msgid ""
#~ "Allows linking additional public keys to"
#~ " `account <../core_concepts/glossary.html#account>`__."
#~ msgstr ""

#~ msgid ""
#~ "The corresponding `command "
#~ "<../core_concepts/glossary.html#command>`__ can be "
#~ "executed only for an account of "
#~ "`transaction <../core_concepts/glossary.html#transaction>`__ "
#~ "creator and only if that account "
#~ "has a `role <../core_concepts/glossary.html#role>`__"
#~ " with the `permission "
#~ "<../core_concepts/glossary.html#permission>`__."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kAddSignatory``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kAddSignatory``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain that contains only"
#~ " can_add_signatory permission and Alice "
#~ "account in that domain. Alice can "
#~ "add to own account additional keys."
#~ msgstr ""

#~ msgid "can_remove_my_signatory"
#~ msgstr ""

#~ msgid ""
#~ "`Permission <../core_concepts/glossary.html#permission>`__ "
#~ "that allows a specified `account "
#~ "<../core_concepts/glossary.html#account>`__ remove public"
#~ " key from the another specified "
#~ "account."
#~ msgstr ""

#~ msgid ""
#~ "Related API method: `Remove Signatory "
#~ "<../api/commands.html#remove-signatory>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Grantable.kRemoveMySignatory``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Grantable_kRemoveMySignatory``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain that contains "
#~ "can_add_signatory and can_grant_can_remove_my_signatory"
#~ " permissions and two accounts for "
#~ "Alice and Bob. Alice grants "
#~ "can_remove_my_signatory permission to Bob and"
#~ " adds additional key to own account."
#~ " Bob can remove one of Alice's "
#~ "keys."
#~ msgstr ""

#~ msgid "can_remove_signatory"
#~ msgstr ""

#~ msgid ""
#~ "Allows unlinking additional public keys "
#~ "from an `account "
#~ "<../core_concepts/glossary.html#account>`__."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kRemoveSignatory``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kRemoveSignatory``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domian that contains "
#~ "can_remove_signatory permission and Alice "
#~ "account in that domain. Admin adds "
#~ "an extra key to Alice account. "
#~ "Alice can remove one of the keys."
#~ msgstr ""

#~ msgid "can_set_my_quorum"
#~ msgstr ""

#~ msgid ""
#~ "`Permission <../core_concepts/glossary.html#permission>`__ "
#~ "that allows a specified `account "
#~ "<../core_concepts/glossary.html#account>`__ to set "
#~ "`quorum <../core_concepts/glossary.html#quorum>`__ for "
#~ "the another specified account."
#~ msgstr ""

#~ msgid "Account should have greater or equal amount of keys than quorum."
#~ msgstr ""

#~ msgid ""
#~ "Related API method: `Set Account Quorum"
#~ " <../api/commands.html#set-account-quorum>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Grantable.kSetMyQuorum``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Grantable_kSetMyQuorum``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain that contains "
#~ "can_grant_can_set_my_quorum and can_add_signatory "
#~ "permissions and create two accounts for"
#~ " Alice and Bob in that domain. "
#~ "Alice grants to Bob can_set_my_qourum "
#~ "permission and adds an extra key "
#~ "to account. Bob can set quorum for"
#~ " Alice."
#~ msgstr ""

#~ msgid "can_set_quorum"
#~ msgstr ""

#~ msgid "Allows setting `quorum <../core_concepts/glossary.html#quorum>`__."
#~ msgstr ""

#~ msgid ""
#~ "At least the same number (or more)"
#~ " of public keys should be already "
#~ "linked to an `account "
#~ "<../core_concepts/glossary.html#account>`__."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kSetQuorum``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kSetQuorum``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates domain that contains only"
#~ " can_set_quorum permission and creates "
#~ "Alice account in that domain. Admin "
#~ "adds an extra key for Alice "
#~ "account. Alice can set quorum equals "
#~ "two."
#~ msgstr ""

#~ msgid "Query-related permissions"
#~ msgstr ""

#~ msgid "can_get_all_acc_detail"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting all the details set "
#~ "to any `account "
#~ "<../core_concepts/glossary.html#account>`__ within the "
#~ "system."
#~ msgstr ""

#~ msgid ""
#~ "Related API method: `Get Account Detail"
#~ " <../api/queries.html#get-account-detail>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetAllAccDetail``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetAllAccDetail``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in a "
#~ "diffrerent domain that has only "
#~ "can_get_all_acc_detail permission. Alice can "
#~ "access details set to Admin account."
#~ msgstr ""

#~ msgid "can_get_all_accounts"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting `account "
#~ "<../core_concepts/glossary.html#account>`__ information: "
#~ "`quorum <../core_concepts/glossary.html#quorum>`__ and "
#~ "all the details related to the "
#~ "account."
#~ msgstr ""

#~ msgid ""
#~ "With this `permission "
#~ "<../core_concepts/glossary.html#permission>`__, `query "
#~ "<../core_concepts/glossary.html#query>`__ creator can "
#~ "get information about any account within"
#~ " a system."
#~ msgstr ""

#~ msgid ""
#~ "All the details (set by the "
#~ "account owner or owners of other "
#~ "accounts) will be returned."
#~ msgstr ""

#~ msgid "Related API method: `Get Account <../api/queries.html#get-account>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetAllAccounts``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetAllAccounts``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in a "
#~ "different domain that has only "
#~ "can_get_all_accounts permission. Alice can "
#~ "access account information of Admin."
#~ msgstr ""

#~ msgid "can_get_domain_acc_detail"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting all the details set "
#~ "to any `account "
#~ "<../core_concepts/glossary.html#account>`__ within the "
#~ "same `domain <../core_concepts/glossary.html#domain>`__"
#~ " as a domain of `query "
#~ "<../core_concepts/glossary.html#query>`__ creator account."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetDomainAccDetail``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetDomainAccDetail``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in the "
#~ "same domain that has only "
#~ "can_get_domain_acc_detail permission. Alice can "
#~ "get details set to Admin account."
#~ msgstr ""

#~ msgid "can_get_domain_accounts"
#~ msgstr ""

#~ msgid ""
#~ "With this `permission "
#~ "<../core_concepts/glossary.html#permission>`__, `query "
#~ "<../core_concepts/glossary.html#query>`__ creator can "
#~ "get information only about accounts from"
#~ " the same `domain "
#~ "<../core_concepts/glossary.html#domain>`__."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetDomainAccounts``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetDomainAccounts``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in the "
#~ "same domain that has only "
#~ "can_get_domain_accounts. Alice can access "
#~ "account information of Admin."
#~ msgstr ""

#~ msgid "can_get_my_acc_detail"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting all the details set "
#~ "to the `account "
#~ "<../core_concepts/glossary.html#account>`__ of `query "
#~ "<../core_concepts/glossary.html#query>`__ creator."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetMyAccDetail``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetMyAccDetail``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in the "
#~ "domain that has only can_get_my_acc_detail "
#~ "permission. Alice can get details set"
#~ " to own account."
#~ msgstr ""

#~ msgid "can_get_my_account"
#~ msgstr ""

#~ msgid ""
#~ "With this `permission "
#~ "<../core_concepts/glossary.html#permission>`__, `query "
#~ "<../core_concepts/glossary.html#query>`__ creator can "
#~ "get information only about own account."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetMyAccount``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetMyAccount``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in the "
#~ "domain that has only can_get_my_account "
#~ "permission. Alice can access own account"
#~ " information."
#~ msgstr ""

#~ msgid "can_get_all_acc_ast"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting a balance of `assets "
#~ "<../core_concepts/glossary.html#asset>`__ on any "
#~ "`account <../core_concepts/glossary.html#account>`__ "
#~ "within the system."
#~ msgstr ""

#~ msgid ""
#~ "`Query <../core_concepts/glossary.html#query>`__ response"
#~ " will contain information about all "
#~ "the assets that ever been assigned "
#~ "to an account."
#~ msgstr ""

#~ msgid ""
#~ "Related API method: `Get Account Assets"
#~ " <../api/queries.html#get-account-assets>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetAllAccAst``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetAllAccAst``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in a "
#~ "different domain that has only "
#~ "can_get_all_acc_ast permission. Alice can "
#~ "access assets balance on Admin account."
#~ msgstr ""

#~ msgid "can_get_domain_acc_ast"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting a balance of specified"
#~ " `asset <../core_concepts/glossary.html#asset>`__ on"
#~ " any `account "
#~ "<../core_concepts/glossary.html#account>`__ within the "
#~ "same `domain <../core_concepts/glossary.html#domain>`__"
#~ " as a domain of `query "
#~ "<../core_concepts/glossary.html#query>`__ creator account."
#~ msgstr ""

#~ msgid ""
#~ "Query response will contain information "
#~ "about all the assets that ever "
#~ "been assigned to an account."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetDomainAccAst``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetDomainAccAst``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in the "
#~ "same domain that has only "
#~ "can_get_domain_acc_ast permission. Alice can "
#~ "access assets balance on Admin account."
#~ msgstr ""

#~ msgid "can_get_my_acc_ast"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting a balance of specified"
#~ " `asset <../core_concepts/glossary.html#asset>`__ on"
#~ " `account <../core_concepts/glossary.html#account>`__ "
#~ "of `query <../core_concepts/glossary.html#query>`__ "
#~ "creator."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetMyAccAst``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetMyAccAst``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in a "
#~ "domain that has only can_get_my_acc_ast "
#~ "permission. Alice can access assets "
#~ "balance on own account."
#~ msgstr ""

#~ msgid "can_get_all_acc_ast_txs"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting `transactions "
#~ "<../core_concepts/glossary.html#transaction>`__ associated "
#~ "with a specified `asset "
#~ "<../core_concepts/glossary.html#asset>`__ and any "
#~ "`account <../core_concepts/glossary.html#account>`__ "
#~ "within the system."
#~ msgstr ""

#~ msgid "Incoming asset transfers will also appear in the query response."
#~ msgstr ""

#~ msgid ""
#~ "Related API method: `Get Account Asset"
#~ " Transactions <../api/queries.html#get-account-"
#~ "asset-transactions>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetAllAccAstTxs``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetAllAccAstTxs``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in a "
#~ "different domain that has "
#~ "can_get_all_acc_ast_txs, can_receive and "
#~ "can_transfer permissions. Admin issues some"
#~ " amount of coins and transfers them"
#~ " to Alice. Alice can query all "
#~ "transactions related to coins and Admin"
#~ " account."
#~ msgstr ""

#~ msgid "can_get_domain_acc_ast_txs"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting `transactions "
#~ "<../core_concepts/glossary.html#transaction>`__ associated "
#~ "with a specified `asset "
#~ "<../core_concepts/glossary.html#asset>`__ and an "
#~ "`account <../core_concepts/glossary.html#account>`__ from"
#~ " the same `domain "
#~ "<../core_concepts/glossary.html#domain>`__ as `query "
#~ "<../core_concepts/glossary.html#query>`__ creator."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetDomainAccAstTxs``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetDomainAccAstTxs``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice in the same "
#~ "domain that has only "
#~ "can_get_domain_acc_ast_txs permission. Admin issues"
#~ " some amount of coins and transfers"
#~ " them to Alice. Alice can query "
#~ "all transactions related to coins and"
#~ " Admin account."
#~ msgstr ""

#~ msgid "can_get_my_acc_ast_txs"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting `transactions "
#~ "<../core_concepts/glossary.html#transaction>`__ associated "
#~ "with the `account "
#~ "<../core_concepts/glossary.html#account>`__ of `query "
#~ "<../core_concepts/glossary.html#query>`__ creator and "
#~ "specified `asset "
#~ "<../core_concepts/glossary.html#asset>`__."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetMyAccAstTxs``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetMyAccAstTxs``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in a "
#~ "domain that has only can_get_my_acc_ast_txs"
#~ " permission. Admin issues some amount "
#~ "of coins and transfers them to "
#~ "Alice. Alice can query all transactions"
#~ " related to coins and own account."
#~ msgstr ""

#~ msgid "can_get_all_acc_txs"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting all `transactions "
#~ "<../core_concepts/glossary.html#transaction>`__ issued by"
#~ " any `account "
#~ "<../core_concepts/glossary.html#account>`__ within the "
#~ "system."
#~ msgstr ""

#~ msgid ""
#~ "Incoming asset transfer inside a "
#~ "transaction would NOT lead to an "
#~ "appearance of the transaction in the "
#~ "command output."
#~ msgstr ""

#~ msgid ""
#~ "Related API method: `Get Account "
#~ "Transactions <../api/queries.html#get-account-"
#~ "transactions>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetAllAccTxs``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetAllAccTxs``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in a "
#~ "different domain that has only "
#~ "can_get_all_acc_txs permiison. Alice can "
#~ "request all the transactions issues by"
#~ " Admin."
#~ msgstr ""

#~ msgid "can_get_domain_acc_txs"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting all `transactions "
#~ "<../core_concepts/glossary.html#transaction>`__ issued by"
#~ " any `account "
#~ "<../core_concepts/glossary.html#account>`__ from the "
#~ "same `domain <../core_concepts/glossary.html#domain>`__"
#~ " as `query <../core_concepts/glossary.html#query>`__"
#~ " creator."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetDomainAccTxs``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetDomainAccTxs``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in the "
#~ "same domain that has only "
#~ "can_get_domain_acc_txs permission. Alice can "
#~ "request all the transactions issued by"
#~ " Admin."
#~ msgstr ""

#~ msgid "can_get_my_acc_txs"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting all `transactions "
#~ "<../core_concepts/glossary.html#transaction>`__ issued by"
#~ " an `account "
#~ "<../core_concepts/glossary.html#account>`__ of `query "
#~ "<../core_concepts/glossary.html#query>`__ creator."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetMyAccTxs``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetMyAccTxs``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in a "
#~ "domain that has only can_get_my_acc_txs "
#~ "permission. Alice can get all "
#~ "transactions issued by own account."
#~ msgstr ""

#~ msgid "can_read_assets"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting information about `asset "
#~ "<../core_concepts/glossary.html#asset>`__ precision."
#~ msgstr ""

#~ msgid ""
#~ "Related API method: `Get Asset Info "
#~ "<../api/queries.html#get-asset-info>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kReadAssets``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kReadAssets``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in a "
#~ "domain that has can_read_assets permissions."
#~ " Alice can query information about "
#~ "any asset."
#~ msgstr ""

#~ msgid "can_get_blocks"
#~ msgstr ""

#~ msgid ""
#~ "Allows subscription to the stream of "
#~ "accepted `blocks "
#~ "<../core_concepts/glossary.html#block>`__."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetBlocks``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetBlocks``"
#~ msgstr ""

#~ msgid "can_get_roles"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting a list of `roles "
#~ "<../core_concepts/glossary.html#role>`__ within the "
#~ "system. Allows getting a list of "
#~ "`permissions <../core_concepts/glossary.html#permission>`__ "
#~ "associated with a role."
#~ msgstr ""

#~ msgid ""
#~ "Related API methods: `Get Roles "
#~ "<../api/queries.html#get-roles>`__, `Get Role "
#~ "Permissions <../api/queries.html#get-role-"
#~ "permissions>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetRoles``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetRoles``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in a "
#~ "domain that has can_get_roles permission. "
#~ "Alice can query list of all "
#~ "existing roles. Alice can query list "
#~ "of permissions contained in any role."
#~ msgstr ""

#~ msgid "can_get_all_signatories"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting a list of public "
#~ "keys linked to an `account "
#~ "<../core_concepts/glossary.html#account>`__ within the "
#~ "system."
#~ msgstr ""

#~ msgid ""
#~ "Related API method: `Get Signatories "
#~ "<../api/queries.html#get-signatories>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetAllSignatories``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetAllSignatories``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in a "
#~ "different domain that has only "
#~ "can_get_all_signatories permission. Alice can "
#~ "query a list of public keys "
#~ "related to Admin account."
#~ msgstr ""

#~ msgid "can_get_domain_signatories"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting a list of public "
#~ "keys of any `account "
#~ "<../core_concepts/glossary.html#account>`__ within the "
#~ "same `domain <../core_concepts/glossary.html#domain>`__"
#~ " as the domain of `query "
#~ "<../core_concepts/glossary.html#query>`__ creator account."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetDomainSignatories``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetDomainSignatories``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in the "
#~ "same domain that has only "
#~ "can_get_domain_signatories permission. Alice can "
#~ "query a list of public keys "
#~ "related to Admin account."
#~ msgstr ""

#~ msgid "can_get_my_signatories"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting a list of public "
#~ "keys of `query "
#~ "<../core_concepts/glossary.html#query>`__ creator `account"
#~ " <../core_concepts/glossary.html#account>`__."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetMySignatories``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetMySignatories``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in a "
#~ "domain that has only can_get_my_signatories"
#~ " permission. Alice can query a list"
#~ " of public keys related to own "
#~ "account."
#~ msgstr ""

#~ msgid "can_get_all_txs"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting any `transaction "
#~ "<../core_concepts/glossary.html#transaction>`__ by hash."
#~ msgstr ""

#~ msgid ""
#~ "Related API method: `Get Transactions "
#~ "<../api/queries.html#get-transactions>`__"
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetAllTxs``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetAllTxs``"
#~ msgstr ""

#~ msgid ""
#~ "Admin issues several transactions and "
#~ "creates Alice account in a different "
#~ "domain that has only can_get_all_txs "
#~ "permission. Alice (knowing transactions "
#~ "hashes) can query transactions issued by"
#~ " Admin Account."
#~ msgstr ""

#~ msgid "can_get_my_txs"
#~ msgstr ""

#~ msgid ""
#~ "Allows getting `transaction "
#~ "<../core_concepts/glossary.html#transaction>`__ (that was"
#~ " issued by `query "
#~ "<../core_concepts/glossary.html#query>`__ creator) by "
#~ "hash."
#~ msgstr ""

#~ msgid "Usage in Java bindings: ``Role.kGetMyTxs``"
#~ msgstr ""

#~ msgid "Usage in Python bindings: ``Role_kGetMyTxs``"
#~ msgstr ""

#~ msgid ""
#~ "Admin creates Alice account in a "
#~ "different domain. Alice (knowing transactions"
#~ " hashes) issues several transactions. Alice"
#~ " can query own transactions."
#~ msgstr ""

#~ msgid "Supplementary Sources"
#~ msgstr ""

#~ msgid "commons.py"
#~ msgstr ""

#~ msgid "consts.py"
#~ msgstr ""

